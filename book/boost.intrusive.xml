<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.intrusive">
  <title>Boost.Intrusive</title><indexterm><primary>Boost.Intrusive</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/intrusive">Boost.Intrusive</link> is a library especially suited for use in high performance programs. The library provides tools to create <emphasis role="concept">intrusive containers</emphasis><indexterm><primary>intrusive container, Boost.Intrusive</primary></indexterm>. These containers replace the known containers from the standard library. Their disadvantage is that they can’t be used as easily as, for example, <classname>std::list</classname> or <classname>std::set</classname>. But they have these advantages:</para>
  <itemizedlist>
    <listitem>
      <para>Intrusive containers don’t allocate memory dynamically. A call to <methodname>push_back</methodname> doesn’t lead to a dynamic allocation with <code>new</code>. This is a one reason why intrusive containers can improve performance.</para>
    </listitem>
    <listitem>
      <para>Intrusive containers store the original objects, not copies. After all, they don’t allocate memory dynamically. This leads to another advantage: Member functions such as <methodname>push_back</methodname> don’t throw exceptions because they neither allocate memory nor copy objects.</para>
    </listitem>
  </itemizedlist>
  <para>The advantages are paid for with more complicated code because preconditions must be met to store objects in intrusive containers. You cannot store objects of arbitrary types in intrusive containers. For example, you cannot put strings of type <classname>std::string</classname> in an intrusive container; instead you must use containers from the standard library.</para>
  <para><xref linkend="ex.intrusive_01" xrefstyle="enp"/> prepares a class <classname>animal</classname> to allow objects of this type to be stored in an intrusive list.</para>
  <example xml:id="ex.intrusive_01">
    <title>Using <classname>boost::intrusive::list</classname></title>
    <programlisting><xi:include href="../src/intrusive_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para>In a list, an element is always accessed from another element, usually using a pointer. If an intrusive list is to store objects of type <classname>animal</classname> without dynamic memory allocation, pointers must exist somewhere to concatenate elements.</para>
  <para>To store objects of type <classname>animal</classname> in an intrusive list, the class must provide the variables required by the intrusive list to concatenate elements. Boost.Intrusive provides <emphasis role="concept">hooks</emphasis><indexterm><primary>hook, Boost.Intrusive</primary></indexterm> &#x2013; classes from which the required variables are inherited. To allow objects of the type <classname>animal</classname> to be stored in an intrusive list, <classname>animal</classname> must be derived from the class <classname>boost::intrusive::list_base_hook</classname><indexterm><primary>intrusive::list_base_hook</primary></indexterm><indexterm><primary>list_base_hook, intrusive</primary></indexterm>.</para>
  <para>Hooks make it possible to ignore the implementation details. However, it’s safe to assume that <classname>boost::intrusive::list_base_hook</classname> provides at least two pointers because <classname>boost::intrusive::list</classname><indexterm><primary>intrusive::list</primary></indexterm><indexterm><primary>list, intrusive</primary></indexterm> is a doubly linked list. Thanks to the base class <classname>boost::intrusive::list_base_hook</classname>, <classname>animal</classname> defines these two pointers to allow objects of this type to be concatenated.</para>
  <para>Please note that <classname>boost::intrusive::list_base_hook</classname> is a template that comes with default template parameters. Thus, no types need to be passed explicitly.</para>
  <para>Boost.Intrusive provides the class <classname>boost::intrusive::list</classname> to create an intrusive list. This class is defined in <filename class="headerfile">boost/intrusive/list.hpp</filename> and is used like <classname>std::list</classname>. Elements can be added using <methodname>push_back</methodname><indexterm><primary>intrusive::list::push_back</primary></indexterm><indexterm><primary>push_back, intrusive::list</primary></indexterm>, and it’s also possible to iterate over elements.</para>
  <para>It is important to understand that intrusive containers do not store copies; they store the original objects. <xref linkend="ex.intrusive_01" xrefstyle="enp"/> writes <computeroutput>dog</computeroutput>, <computeroutput>shark</computeroutput>, and <computeroutput>spider</computeroutput> to standard output &#x2013; not <computeroutput>cat</computeroutput>. The object <varname>a1</varname> is linked into the list. That’s why the change of the name is visible when the program iterates over the elements in the list and displays the names.</para>
  <para>Because intrusive containers don’t store copies, you must remove objects from intrusive containers before you destroy them.</para>
  <example xml:id="ex.intrusive_02">
    <title>Removing and destroying dynamically allocated objects</title>
    <programlisting><xi:include href="../src/intrusive_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.intrusive_02" xrefstyle="enp"/> creates an object of type <classname>animal</classname> with <code>new</code> and inserts it to the list <varname>animals</varname>. If you want to destroy the object with <code>delete</code> when you don’t need it anymore, you must remove it from the list. Make sure that you remove the object from the list before you destroy it &#x2013; the order is important. Otherwise, the pointers in the elements of the intrusive container might refer to a memory location that no longer contains an object of type <classname>animal</classname>.</para>
  <para>Because intrusive containers neither allocate nor free memory, objects stored in an intrusive container continue to exist when the intrusive container is destroyed.</para>
  <para>Since removing elements from intrusive containers doesn’t automatically destroy them, the containers provide non-standard extensions. <methodname>pop_back_and_dispose</methodname><indexterm><primary>intrusive::list::pop_back_and_dispose</primary></indexterm><indexterm><primary>pop_back_and_dispose, intrusive::list</primary></indexterm> is one such member function.</para>
  <example xml:id="ex.intrusive_03">
    <title>Removing and destroying with <methodname>pop_back_and_dispose</methodname></title>
    <programlisting><xi:include href="../src/intrusive_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para><methodname>pop_back_and_dispose</methodname> removes an element from a list and destroys it. Because intrusive containers don’t know how an element should be destroyed, you need to pass to <methodname>pop_back_and_dispose</methodname> a function or function object that does know how to destroy the element. <methodname>pop_back_and_dispose</methodname> will remove the object from the list, then call the function or function object and pass it a pointer to the object to be destroyed. <xref linkend="ex.intrusive_03" xrefstyle="enp" /> passes a lambda function that calls <code>delete</code>.</para>
  <para>In <xref linkend="ex.intrusive_03" xrefstyle="enp"/>, only the third element in <varname>animals</varname> can be removed with <methodname>pop_back_and_dispose</methodname>. The other elements in the list haven’t been created with <code>new</code> and, thus, must not be destroyed with <code>delete</code>.</para>
  <para>Boost.Intrusive supports another mechanism to link removing and destroying of elements.</para>
  <example xml:id="ex.intrusive_04">
    <title>Removing and destroying with auto unlink mode</title>
    <programlisting><xi:include href="../src/intrusive_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Hooks support a parameter to set a link mode. The link mode is set with the class template <classname>boost::intrusive::link_mode</classname><indexterm><primary>intrusive::link_mode</primary></indexterm><indexterm><primary>link_mode, intrusive</primary></indexterm>. If <classname>boost::intrusive::auto_unlink</classname><indexterm><primary>intrusive::auto_unlink</primary></indexterm><indexterm><primary>auto_unlink, intrusive</primary></indexterm> is passed as a template parameter, the auto unlink mode is selected.</para>
  <para>The auto unlink mode automatically removes an element from an intrusive container when it is destroyed. <xref linkend="ex.intrusive_04" xrefstyle="enp"/> writes only <computeroutput>cat</computeroutput> and <computeroutput>shark</computeroutput> to standard output.</para>
  <para>The auto unlink mode can only be used if the member function <methodname>size</methodname><indexterm><primary>intrusive::list::size</primary></indexterm><indexterm><primary>size, intrusive::list</primary></indexterm>, which is provided by all intrusive containers, has no <emphasis role="concept">constant complexity</emphasis>. By default, it has constant complexity, which means: the time it takes for <methodname>size</methodname> to return the number of elements doesn’t depend on how many elements are stored in a container. Switching constant complexity on or off is another option to optimize performance.</para>
  <para>To change the complexity of <methodname>size</methodname>, use the class template <classname>boost::intrusive::constant_time_size</classname><indexterm><primary>intrusive::constant_time_size</primary></indexterm><indexterm><primary>constant_time_size, intrusive</primary></indexterm>, which expects either <literal>true</literal> or <literal>false</literal> as a template parameter. <classname>boost::intrusive::constant_time_size</classname> can be passed as a second template parameter to intrusive containers, such as <classname>boost::intrusive::list</classname>, to set the complexity for <methodname>size</methodname>.</para>
  <para>Now that we’ve seen that intrusive containers support link mode and that there is an option to set the complexity for <methodname>size</methodname>, it might seem as though there is still much more to discover, but there actually isn’t. There are, for example, only three link modes supported, and auto unlink mode is the only one you need to know. The default mode used if you don’t pick a link mode is good enough for all other use cases.</para>
  <para>Furthermore, there are no options for other member functions. There are no other classes, other than <classname>boost::intrusive::constant_time_size</classname>, that you need to learn about.</para>
  <para><xref linkend="ex.intrusive_05" xrefstyle="enp"/> introduces a hook mechanism using another intrusive container: <classname>boost::intrusive::set</classname><indexterm><primary>intrusive::set</primary></indexterm><indexterm><primary>set, intrusive</primary></indexterm>.</para>
  <example xml:id="ex.intrusive_05">
    <title>Defining a hook for <classname>boost::intrusive::set</classname> as a member variable</title>
    <programlisting><xi:include href="../src/intrusive_05/main.cpp" parse="text"/></programlisting>
  </example>
  <para>There are two ways to add a hook to a class: either derive the class from a hook or define the hook as a member variable. While the previous examples derived a class from <classname>boost::intrusive::list_base_hook</classname>, <xref linkend="ex.intrusive_05" xrefstyle="enp"/> uses the class <classname>boost::intrusive::set_member_hook</classname><indexterm><primary>intrusive::set_member_hook</primary></indexterm><indexterm><primary>set_member_hook, intrusive</primary></indexterm> to define a member variable.</para>
  <para>Please note that the name of the member variable doesn’t matter. However, the hook class you use depends on the intrusive container. For example, to define a hook as a member variable for an intrusive list, use <classname>boost::intrusive::list_member_hook</classname><indexterm><primary>intrusive::list_member_hook</primary></indexterm><indexterm><primary>list_member_hook, intrusive</primary></indexterm> instead of <classname>boost::intrusive::set_member_hook</classname>.</para>
  <para>Intrusive containers have different hooks because they have different requirements for elements. However, you can use different several hooks to allow objects to be stored in multiple intrusive containers. <classname>boost::intrusive::any_base_hook</classname><indexterm><primary>intrusive::any_base_hook</primary></indexterm><indexterm><primary>any_base_hook, intrusive</primary></indexterm> and <classname>boost::intrusive::any_member_hook</classname><indexterm><primary>intrusive::any_member_hook</primary></indexterm><indexterm><primary>any_member_hook, intrusive</primary></indexterm> let you store objects in any intrusive container. Thanks to these classes, you don’t need to derive from multiple hooks or define multiple member variables as hooks.</para>
  <para>Intrusive containers expect hooks to be defined in base classes by default. If a member variable is used as a hook, as in <xref linkend="ex.intrusive_05" xrefstyle="enp"/>, the intrusive container has to be told which member variable to use. That’s why both <classname>animal</classname> and the type <type>hook</type> are passed to <classname>boost::intrusive::set</classname>. <type>hook</type> is defined with <classname>boost::intrusive::member_hook</classname><indexterm><primary>intrusive::member_hook</primary></indexterm><indexterm><primary>member_hook, intrusive</primary></indexterm>, which is used whenever a member variable serves as a hook. <classname>boost::intrusive::member_hook</classname> expects the element type, the type of the hook, and a pointer to the member variable as template parameters.</para>
  <para><xref linkend="ex.intrusive_05" xrefstyle="enp"/> writes <computeroutput>shark</computeroutput>, <computeroutput>cat</computeroutput>, and <computeroutput>spider</computeroutput>, in that order, to standard output.</para>
  <para>In addition to the classes <classname>boost::intrusive::list</classname> and <classname>boost::intrusive::set</classname> introduced in this chapter, Boost.Intrusive also provides, for example, <classname>boost::intrusive::slist</classname><indexterm><primary>intrusive::slist</primary></indexterm><indexterm><primary>slist, intrusive</primary></indexterm> for singly linked lists and <classname>boost::intrusive::unordered_set</classname><indexterm><primary>intrusive::unordered_set</primary></indexterm><indexterm><primary>unordered_set, intrusive</primary></indexterm> for hash containers.</para>
</chapter>
