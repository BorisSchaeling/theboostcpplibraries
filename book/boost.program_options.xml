<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.program_options">
  <title>Boost.ProgramOptions</title><indexterm><primary>Boost.ProgramOptions</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/program_options">Boost.ProgramOptions</link> is a library that makes it easy to parse command-line options, for example, for console applications. If you develop applications with a graphical user interface, command-line options are usually not important.</para>
  <para>To parse command-line options with Boost.ProgramOptions, the following three steps are required:</para>
  <orderedlist>
    <listitem>
      <para>Define command-line options. You give them names and specify which ones can be set to a value. If a command-line option is parsed as a key/value pair, you also set the type of the value &#x2013; for example, whether it is a string or a number.</para>
    </listitem>
    <listitem>
      <para>Use a parser to evaluate the command line. You get the command line from the two parameters of <function>main</function>, which are usually called <varname>argc</varname> and <varname>argv</varname>.</para>
    </listitem>
    <listitem>
      <para>Store the command-line options evaluated by the parser. Boost.ProgramOptions offers a class derived from <classname>std::map</classname> that saves command-line options as name/value pairs. Afterwards, you can check which options have been stored and what their values are.</para>
    </listitem>
  </orderedlist>
  <para><xref linkend="ex.program_options_01" xrefstyle="enp"/> shows the basic approach for parsing command-line options with Boost.ProgramOptions.</para>
  <example xml:id="ex.program_options_01">
    <title>Basic approach with Boost.ProgramOptions</title>
    <programlisting><xi:include href="../src/program_options_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para>To use Boost.ProgramOptions, include the header file <filename class="headerfile">boost/program_options.hpp</filename>. You can access all classes and functions from this library in the namespace <package>boost::program_options</package>.</para>
  <para>Use the class <classname>boost::program_options::options_description</classname><indexterm><primary>program_options::options_description</primary></indexterm><indexterm><primary>options_description, program_options</primary></indexterm> to describe command-line options. An object of this type can be written to a stream such as <varname>std::cout</varname> to display an overview of available command-line options. The string passed to the constructor gives the overview a name that acts as a title for the command-line options.</para>
  <para><classname>boost::program_options::options_description</classname> defines a member function <methodname>add</methodname><indexterm><primary>program_options::options_description::add</primary></indexterm><indexterm><primary>add, program_options::options_description</primary></indexterm> that expects a parameter of type <classname>boost::program_options::option_description</classname>. You call this function to describe each command-line option. Instead of calling this function for every command-line option, <xref linkend="ex.program_options_01" xrefstyle="enp" /> calls the member function <methodname>add_options</methodname><indexterm><primary>program_options::options_description::add_options</primary></indexterm><indexterm><primary>add_options, program_options::options_description</primary></indexterm>, which makes that task easier.</para>
  <para><methodname>add_options</methodname> returns a proxy object representing an object of type <classname>boost::program_options::options_description</classname>. The type of the proxy object doesn’t matter. It’s more interesting that the proxy object simplifies defining many command-line options. It uses the overloaded operator <methodname role="operator">operator()</methodname>, which you can call to pass the required data to define a command-line option. This operator returns a reference to the same proxy object, which allows you to call <methodname role="operator">operator()</methodname> multiple times.</para>
  <para><xref linkend="ex.program_options_01" xrefstyle="enp"/> defines three command-line options with the help of the proxy object. The first command-line option is <option>--help</option>. The description of this option is set to <quote>Help screen</quote>. The option is a switch, not a name/value pair. You set <option>--help</option> on the command line or omit it. It’s not possible to set <option>--help</option> to a value.</para>
  <para>Please note that the first string passed to <methodname role="operator">operator()</methodname> is <quote>help,h</quote>. You can specify short names for command-line options. A short name must consist of just one letter and is set after a comma. Now the help can be displayed with either <option>--help</option> or <option>-h</option>.</para>
  <para>Besides <option>--help</option>, two more command-line options are defined: <option>--pi</option> and <option>--age</option>. These options aren’t switches, they’re name/value pairs. Both <option>--pi</option> and <option>--age</option> expect to be set to a value.</para>
  <para>You pass a pointer to an object of type <classname>boost::program_options::value_semantic</classname><indexterm><primary>program_options::value_semantic</primary></indexterm><indexterm><primary>value_semantic, program_options</primary></indexterm> as the second parameter to <methodname role="operator">operator()</methodname> to define an option as a name/value pair. You don’t need to access <classname>boost::program_options::value_semantic</classname> directly. You can use the helper function <function>boost::program_options::value</function><indexterm><primary>program_options::value</primary></indexterm><indexterm><primary>value, program_options</primary></indexterm>, which creates an object of type <classname>boost::program_options::value_semantic</classname>. <function>boost::program_options::value</function> returns the object’s address, which you then can pass to the proxy object using <methodname role="operator">operator()</methodname>.</para>
  <para><function>boost::program_options::value</function> is a function template that takes the type of the command-line option value as a template parameter. Thus, the command-line option <option>--age</option> expects an integer and <option>--pi</option> expects a floating point number.</para>
  <para>The object returned from <function>boost::program_options::value</function> provides some useful member functions. For example, you can call <methodname>default_value</methodname><indexterm><primary>program_options::value_semantic::default_value</primary></indexterm><indexterm><primary>default_value, program_options::value_semantic</primary></indexterm> to provide a default value. <xref linkend="ex.program_options_01" xrefstyle="enp"/> sets <option>--pi</option> to 3.14 if that option isn’t used on the command line.</para>
  <para><methodname>notifier</methodname><indexterm><primary>program_options::value_semantic::notifier</primary></indexterm><indexterm><primary>notifier, program_options::value_semantic</primary></indexterm> links a function to a command-line option’s value. That function is then called with the value of the command-line option. In <xref linkend="ex.program_options_01" xrefstyle="enp"/>, the function <function>on_age</function> is linked to <option>--age</option>. If the command-line option <option>--age</option> is used to set an age, the age is passed to <function>on_age</function> which writes it to standard output.</para>
  <para>Processing values with functions like <function>on_age</function> is optional. You don’t have to use <methodname>notifier</methodname> because it’s possible to access values in other ways.</para>
  <para>After all command-line options have been defined, you use a parser. In <xref linkend="ex.program_options_01" xrefstyle="enp"/>, the helper function <function>boost::program_options::parse_command_line</function><indexterm><primary>program_options::parse_command_line</primary></indexterm><indexterm><primary>parse_command_line, program_options</primary></indexterm> is called to parse the command line. This function takes <varname>argc</varname> and <varname>argv</varname>, which define the command line, and <varname>desc</varname>, which contains the option descriptions. <function>boost::program_options::parse_command_line</function> returns the parsed options in an object of type <classname>boost::program_options::parsed_options</classname><indexterm><primary>program_options::parsed_options</primary></indexterm><indexterm><primary>parsed_options, program_options</primary></indexterm>. You usually don’t access this object directly. Instead you pass it to <function>boost::program_options::store</function><indexterm><primary>program_options::store</primary></indexterm><indexterm><primary>store, program_options</primary></indexterm>, which stores the parsed options in a container.</para>
  <para><xref linkend="ex.program_options_01" xrefstyle="enp" /> passes <varname>vm</varname> as a second parameter to <function>boost::program_options::store</function>. <varname>vm</varname> is an object of type <classname>boost::program_options::variables_map</classname><indexterm><primary>program_options::variables_map</primary></indexterm><indexterm><primary>variables_map, program_options</primary></indexterm>. This class is derived from the class <type>std::map&lt;std::string, boost::program_options::variable_value&gt;</type> and, thus, provides the same member functions as <classname>std::map</classname>. For example, you can call <methodname>count</methodname><indexterm><primary>program_options::variables_map::count</primary></indexterm><indexterm><primary>count, program_options::variables_map</primary></indexterm> to check whether a certain command-line option has been used and is stored in the container.</para>
  <para>In <xref linkend="ex.program_options_01" xrefstyle="enp"/>, before <varname>vm</varname> is accessed and <methodname>count</methodname> is called, <function>boost::program_options::notify</function><indexterm><primary>program_options::notify</primary></indexterm><indexterm><primary>notify, program_options</primary></indexterm> is called. This function triggers functions, such as <function>on_age</function>, that are linked to a value using <methodname>notifier</methodname>. Without <function>boost::program_options::notify</function>, <function>on_age</function> would not be called.</para>
  <para><varname>vm</varname> lets you check whether a certain command-line option exists, and it also lets you access the value the command-line option is set to. The value’s type is <classname>boost::program_options::variable_value</classname><indexterm><primary>program_options::variable_value</primary></indexterm><indexterm><primary>variable_value, program_options</primary></indexterm>, a class that uses <classname>boost::any</classname> internally. You can get the object of type <classname>boost::any</classname> from the member function <methodname>value</methodname><indexterm><primary>program_options::variable_value::value</primary></indexterm><indexterm><primary>value, program_options::variable_value</primary></indexterm>.</para>
  <para><xref linkend="ex.program_options_01" xrefstyle="enp"/> calls <methodname>as</methodname><indexterm><primary>program_options::variable_value::as</primary></indexterm><indexterm><primary>as, program_options::variable_value</primary></indexterm>, not <methodname>value</methodname>. This member function converts the value of a command-line option to the type passed as a template parameter. <methodname>as</methodname> uses <function>boost::any_cast</function> for the type conversion.</para>
  <para>Be sure the type you pass to <methodname>as</methodname> matches the type of the command-line option. For example, <xref linkend="ex.program_options_01" xrefstyle="enp"/> expects the command-line option <option>--age</option> to be set to a number of type <type>int</type>, so <type>int</type> must be passed as a template parameter to <methodname>as</methodname>.</para>
  <para>You can start <xref linkend="ex.program_options_01" xrefstyle="enp"/> in many ways. Here is one example:</para>
  <literallayout><command>test</command></literallayout>
  <para>In this case <computeroutput>Pi: 3.14</computeroutput> is displayed. Because <option>--pi</option> isn’t set on the command line, the default value is displayed.</para>
  <para>This example sets a value using <option>--pi</option>:</para>
  <literallayout><command>test --pi 3.1415</command></literallayout>
  <para>The program now displays <computeroutput>Pi: 3.1415</computeroutput>.</para>
  <para>This example also passes an age:</para>
  <literallayout><command>test --pi 3.1415 --age 29</command></literallayout>
  <para>The output is now <computeroutput>On age: 29</computeroutput> and <computeroutput>Age: 29</computeroutput>. The first line is written when <function>boost::program_options::notify</function> is called; this triggers the execution of <function>on_age</function>. There is no output for <option>--pi</option> because the program uses <code>else if</code> statements that only display the value set with <option>--pi</option> if <option>--age</option> is not set.</para>
  <para>This example shows the help:</para>
  <literallayout><command>test -h</command></literallayout>
  <para>You get a complete overview on all command-line options:</para>
  <screen>Options: -h [ --help ]         Help screen --pi arg (=3.1400001) Pi --age arg             Age</screen>
  <para>As you can see, the help can be shown in two different ways because a short name for that command-line option was defined. For <option>--pi</option> the default value is displayed. The command-line options and their descriptions are formatted automatically. You only need to write the object of type <classname>boost::program_options::options_description</classname> to standard output as in <xref linkend="ex.program_options_01" xrefstyle="enp"/>.</para>
  <para>Now, start the example like this:</para>
  <literallayout><command>test --age</command></literallayout>
  <para>The output is the following:</para>
  <screen>the required argument for option '--age' is missing.</screen>
  <para>Because <option>--age</option> isn’t set, the parser used in <function>boost::program_options::parse_command_line</function> throws an exception of type <exceptionname>boost::program_options::error</exceptionname><indexterm><primary>program_options::error</primary></indexterm><indexterm><primary>error, program_options</primary></indexterm>. The exception is caught, and an error message is written to standard output.</para>
  <para><exceptionname>boost::program_options::error</exceptionname> is derived from <exceptionname>std::logic_error</exceptionname>. Boost.ProgramOptions defines additional exceptions, which are all derived from <exceptionname>boost::program_options::error</exceptionname>. One of those exceptions is <exceptionname>boost::program_options::invalid_syntax</exceptionname><indexterm><primary>program_options::invalid_syntax</primary></indexterm><indexterm><primary>invalid_syntax, program_options</primary></indexterm>, which is the exact exception thrown in <xref linkend="ex.program_options_01" xrefstyle="enp"/> if you don’t supply a value for <option>--age</option>.</para>
  <para><xref linkend="ex.program_options_02" xrefstyle="enp"/> introduces more configuration settings available with Boost.ProgramOptions.</para>
  <example xml:id="ex.program_options_02">
    <title>Special configuration settings with Boost.ProgramOptions</title>
    <programlisting><xi:include href="../src/program_options_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.program_options_02" xrefstyle="enp"/> parses command-line options like the previous example does. However, there are some notable differences. For example, <methodname>implicit_value</methodname><indexterm><primary>program_options::value_semantic::implicit_value</primary></indexterm><indexterm><primary>implicit_value, program_options::value_semantic</primary></indexterm> is called, rather than <methodname>default_value</methodname>, when defining the <option>--pi</option> command-line option. This means that pi isn’t set to 3.14 by default. <option>--pi</option> must be set on the command line for pi to be available. However, you don’t need to supply a value to the <option>--pi</option> command-line option if you use <methodname>implicit_value</methodname>. It’s sufficient to pass <option>--pi</option> without setting a value. In that case, pi is set to 3.14 implicitly.</para>
  <para>For the command-line option <option>--age</option>, a pointer to the variable <varname>age</varname> is passed to <function>boost::program_options::value</function>. This stores the value of a command-line option in a variable. Of course, the value is still available in the container <varname>vm</varname>.</para>
  <para>Please note that a value is only stored in <varname>age</varname> if <function>boost::program_options::notify</function> is called. Even though <methodname>notifier</methodname> isn’t used in this example, <function>boost::program_options::notify</function> still must be used. To avoid problems, it’s a good idea to always call <function>boost::program_options::notify</function> after parsed command-line options have been stored with <function>boost::program_options::store</function>.</para>
  <para><xref linkend="ex.program_options_02" xrefstyle="enp"/> supports a new command-line option <option>--phone</option> to pass a phone number to the program. In fact, you can pass multiple phone numbers on the command line. For example, the following command line starts the program with the phone numbers 123 and 456:</para>
  <literallayout><command>test --phone 123 456</command></literallayout>
  <para><xref linkend="ex.program_options_02" xrefstyle="enp"/> supports multiple phone numbers because <methodname>multitoken</methodname><indexterm><primary>program_options::value_semantic::multitoken</primary></indexterm><indexterm><primary>multitoken, program_options::value_semantic</primary></indexterm> is called on this command-line option’s value. And, since <methodname>zero_tokens</methodname><indexterm><primary>program_options::value_semantic::zero_tokens</primary></indexterm><indexterm><primary>zero_tokens, program_options::value_semantic</primary></indexterm> is called, <option>--phone</option> can also be used without passing a phone number.</para>
  <para>You can also pass multiple phone numbers by repeating the <option>--phone</option> option, as shown in the following command line:</para>
  <literallayout><command>test --phone 123 --phone 456</command></literallayout>
  <para>In this case, both phone numbers, 123 and 456, are parsed. The call to <methodname>composing</methodname><indexterm><primary>program_options::value_semantic::composing</primary></indexterm><indexterm><primary>composing, program_options::value_semantic</primary></indexterm> makes it possible to use a command-line option multiple times &#x2013; the values are composed.</para>
  <para>The value of the argument to <option>--phone</option> is of type <type>std::vector&lt;std::string&gt;</type>. You need to use a container to store multiple phone numbers.</para>
  <para><xref linkend="ex.program_options_02" xrefstyle="enp"/> defines another command-line option, <option>--unreg</option>. This is a switch that can’t be set to a value. It is used later in the example to decide whether command-line options that aren’t defined in <varname>desc</varname> should be displayed.</para>
  <para>While <xref linkend="ex.program_options_01" xrefstyle="ewp"/> calls the function <function>boost::program_options::parse_command_line</function> to parse command-line options, <xref linkend="ex.program_options_02" xrefstyle="enp"/> uses a parser of type <classname>boost::program_options::command_line_parser</classname><indexterm><primary>program_options::command_line_parser</primary></indexterm><indexterm><primary>command_line_parser, program_options</primary></indexterm>. <varname>argc</varname> and <varname>argv</varname> are passed to the constructor.</para>
  <para><classname>boost::program_options::command_line_parser</classname> provides several member functions. You must call <methodname>options</methodname><indexterm><primary>program_options::command_line_parser::options</primary></indexterm><indexterm><primary>options, program_options::command_line_parser</primary></indexterm> to pass the definition of command-line options to the parser.</para>
  <para>Like other member functions, <methodname>options</methodname> returns a reference to the same parser. That way, member functions can be easily called one after another. <xref linkend="ex.program_options_02" xrefstyle="enp"/> calls <methodname>allow_unregistered</methodname><indexterm><primary>program_options::command_line_parser::allow_unregistered</primary></indexterm><indexterm><primary>allow_unregistered, program_options::command_line_parser</primary></indexterm> after <methodname>options</methodname> to tell the parser not to throw an exception if unknown command-line options are detected. Finally, <methodname>style</methodname><indexterm><primary>program_options::command_line_parser::style</primary></indexterm><indexterm><primary>style, program_options::command_line_parser</primary></indexterm> is called to tell the parser that short names can be used with a slash. Thus, the short name for the <option>--help</option> option can be either <option>-h</option> or <option>/h</option>.</para>
  <para>Please note that <function>boost::program_options::parse_command_line</function> supports a fourth parameter, which is forwarded to <methodname>style</methodname>. If you want to use an option like <varname>boost::program_options::command_line_style::allow_slash_for_short</varname><indexterm><primary>program_options::command_line_style::allow_slash_for_short</primary></indexterm><indexterm><primary>allow_slash_for_short, program_options::command_line_style</primary></indexterm>, you can still use the function <function>boost::program_options::parse_command_line</function>.</para>
  <para>After the configuration has been set, call <methodname>run</methodname><indexterm><primary>program_options::command_line_parser::run</primary></indexterm><indexterm><primary>run, program_options::command_line_parser</primary></indexterm> on the parser. This member function returns the parsed command-line options in an object of type <classname>boost::program_options::parsed_options</classname>, which you can pass to <function>boost::program_options::store</function> to store the options in <varname>vm</varname>.</para>
  <para>Later in the code, <xref linkend="ex.program_options_02" xrefstyle="enp"/> accesses <varname>vm</varname> again to evaluate command-line options. Only the call to <function>boost::program_options::collect_unrecognized</function><indexterm><primary>program_options::collect_unrecognized</primary></indexterm><indexterm><primary>collect_unrecognized, program_options</primary></indexterm> is new. This function is called for the command-line option <option>--unreg</option>. The function expects an object of type <classname>boost::program_options::parsed_options</classname>, which is returned by <methodname>run</methodname>. It returns all unknown command-line options in a <type>std::vector&lt;std::string&gt;</type>. For example, if you start the program with <command>test --unreg --abc</command>, <computeroutput>--abc</computeroutput> will be written to standard output.</para>
  <para>When <varname>boost::program_options::exclude_positional</varname><indexterm><primary>program_options::exclude_positional</primary></indexterm><indexterm><primary>exclude_positional, program_options</primary></indexterm> is passed as the second parameter to <function>boost::program_options::collect_unrecognized</function>, positional options are ignored. For <xref linkend="ex.program_options_02" xrefstyle="enp"/>, this doesn’t matter because no positional options are defined. However, <function>boost::program_options::collect_unrecognized</function> requires this parameter.</para>
  <para><xref linkend="ex.program_options_03" xrefstyle="enp"/> illustrates positional options.</para>
  <example xml:id="ex.program_options_03">
    <title>Positional options with Boost.ProgramOptions</title>
    <programlisting><xi:include href="../src/program_options_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.program_options_03" xrefstyle="enp"/> defines <option>--phone</option> as a positional option using the class <classname>boost::program_options::positional_options_description</classname><indexterm><primary>program_options::positional_options_description</primary></indexterm><indexterm><primary>positional_options_description, program_options</primary></indexterm>. This class provides the member function <methodname>add</methodname>, which expects the name of the command-line option and a position to be passed. The example passes <quote>phone</quote> and -1.</para>
  <para>With positional options, values can be set on the command line without using command-line options. You can start <xref linkend="ex.program_options_03" xrefstyle="enp"/> like this:</para>
  <literallayout><command>test 123 456</command></literallayout>
  <para>Even though <option>--phone</option> isn’t used, 123 and 456 are recognized as phone numbers.</para>
  <para>Calling <methodname>add</methodname><indexterm><primary>program_options::positional_options_description::add</primary></indexterm><indexterm><primary>add, program_options::positional_options_description</primary></indexterm> on an object of type <classname>boost::program_options::positional_options_description</classname> assigns values on the command line to command-line options using position numbers. When <xref linkend="ex.program_options_03" xrefstyle="enp"/> is called using the command line <command>test 123 456</command>, 123 has the position number 0 and 456 has the position number 1. <xref linkend="ex.program_options_03" xrefstyle="enp" /> passes -1 to <methodname>add</methodname>, which assigns all of the values &#x2013; 123 and 456 &#x2013; to <option>--phone</option>. If you changed <xref linkend="ex.program_options_03" xrefstyle="enp"/> to pass the value 0 to <methodname>add</methodname>, only 123 would be recognized as a phone number. And if 1 was passed to <methodname>add</methodname>, only 456 would be recognized.</para>
  <para><varname>pos_desc</varname> is passed with <methodname>positional</methodname><indexterm><primary>program_options::command_line_parser::positional</primary></indexterm><indexterm><primary>positional, program_options::command_line_parser</primary></indexterm> to the parser. That’s how the parser knows which command-line options are positional.</para>
  <para>Please note that you have to make sure that positional options are defined. In <xref linkend="ex.program_options_03" xrefstyle="enp"/>, for example, <quote>phone</quote> could only be passed to <methodname>add</methodname> because a definition for <option>--phone</option> already existed in <varname>desc</varname>.</para>
  <para>In all previous examples, Boost.ProgramOptions was used to parse command-line options. However, the library supports loading configuration options from a file, too. This can be useful if the same command-line options have to be set repeatedly.</para>
  <example xml:id="ex.program_options_04">
    <title>Loading options from a configuration file</title>
    <programlisting><xi:include href="../src/program_options_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.program_options_04" xrefstyle="enp"/> uses two objects of type <classname>boost::program_options::options_description</classname>. <varname>generalOptions</varname> defines options that must be set on the command line. <varname>fileOptions</varname> defines options that can be loaded from a configuration file.</para>
  <para>It’s not mandatory to define options with two different objects of type <classname>boost::program_options::options_description</classname>. You can use just one if the set of options is the same for both command line and file. In <xref linkend="ex.program_options_04" xrefstyle="enp"/>, separating options makes sense because you don’t want to allow <option>--help</option> to be set in the configuration file. If that was allowed and the user put that option in the configuration file, the program would display the help screen every time.</para>
  <para><xref linkend="ex.program_options_04" xrefstyle="enp"/> loads <option>--age</option> from a configuration file. You can pass the name of the configuration file as a command-line option. In this example, <option>--config</option> is defined in <varname>generalOptions</varname> for that reason.</para>
  <para>After the command-line options have been parsed with <function>boost::program_options::parse_command_line</function> and stored in <varname>vm</varname>, the example checks whether <option>--config</option> is set. If it is, the configuration file is opened with <classname>std::ifstream</classname>. The <classname>std::ifstream</classname> object is passed to the function <function>boost::program_options::parse_config_file</function><indexterm><primary>program_options::parse_config_file</primary></indexterm><indexterm><primary>parse_config_file, program_options</primary></indexterm> along with <varname>fileOptions</varname>, which describes the options. <function>boost::program_options::parse_config_file</function> does the same thing as <function>boost::program_options::parse_command_line</function> and returns parsed options in an object of type <classname>boost::program_options::parsed_options</classname>. This object is passed to <function>boost::program_options::store</function> to store the parsed options in <varname>vm</varname>.</para>
  <para>If you create a file called <filename>config.txt</filename>, put age=29 in that file, and execute the command line below, you will get the result shown.</para>
  <literallayout><command>test --config config.txt</command></literallayout>
  <para>The output is the following:</para>
  <screen>Your age is: 29</screen>
  <para>If you support the same options on the command line and in a configuration file, your program may parse the same option twice &#x2013; once with <function>boost::program_options::parse_command_line</function> and once with <function>boost::program_options::parse_config_file</function>. The order of the function calls determines which value you will find in <varname>vm</varname>. Once a command-line option’s value has been stored in <varname>vm</varname>, that value will not be overwritten. Whether the value is set by an option on the command line or in a configuration file depends only on the order in which you call the <function>store</function> function.</para>
  <para>Boost.ProgramOptions also defines the function <function>boost::program_options::parse_environment</function><indexterm><primary>program_options::parse_environment</primary></indexterm><indexterm><primary>parse_environment, program_options</primary></indexterm>, which can be used to load options from environment variables. The class <classname>boost::environment_iterator</classname><indexterm><primary>environment_iterator, Boost.ProgramOptions</primary></indexterm> lets you iterate over environment variables.</para>
</chapter>
