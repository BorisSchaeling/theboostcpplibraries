<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.smartpointers">
  <title>Boost.SmartPointers</title><indexterm><primary>Boost.SmartPointers</primary></indexterm>
  <para>The library <link xlink:href="http://www.boost.org/libs/smart_ptr">Boost.SmartPointers</link> provides various smart pointers. They help you manage dynamically allocated objects, which are anchored in smart pointers that release the dynamically allocated objects in the destructor. Because destructors are executed when the scope of smart pointers ends, releasing dynamically allocated objects is guaranteed. There can’t be a memory leak if, for example, you forget to call <code>delete</code>.</para>
  <para>The standard library has included the smart pointer <classname>std::auto_ptr</classname> since C++98, but since C++11, <classname>std::auto_ptr</classname> has been deprecated. With C++11, new and better smart pointers were introduced in the standard library. <classname>std::shared_ptr</classname> and <classname>std::weak_ptr</classname> originate from Boost.SmartPointers and are called <classname>boost::shared_ptr</classname> and <classname>boost::weak_ptr</classname> in this library. There is no counterpart to <classname>std::unique_ptr</classname>. However, Boost.SmartPointers provides four additional smart pointers &#x2013; <classname>boost::scoped_ptr</classname>, <classname>boost::scoped_array</classname>, <classname>boost::shared_array</classname>, and <classname>boost::intrusive_ptr</classname> &#x2013; which are not in the standard library.</para>
  <sect1 xml:id="boost.smartpointers-sole-ownership">
    <title>Sole Ownership</title>
    <para><classname>boost::scoped_ptr</classname><indexterm><primary>scoped_ptr, Boost.SmartPointers</primary></indexterm> is a smart pointer that is the sole owner of a dynamically allocated object. <classname>boost::scoped_ptr</classname> cannot be copied or moved. This smart pointer is defined in the header file <filename class="headerfile">boost/scoped_ptr.hpp</filename>.</para>
    <example xml:id="ex.smartpointers_01">
      <title>Using <classname>boost::scoped_ptr</classname></title>
      <programlisting><xi:include href="../src/smartpointers_01/main.cpp" parse="text"/></programlisting>
    </example>
    <para>A smart pointer of type <classname>boost::scoped_ptr</classname> can’t transfer ownership of an object. Once initialized with an address, the dynamically allocated object is released when the destructor is executed or when the member function <methodname>reset</methodname> is called.</para>
    <para><xref linkend="ex.smartpointers_01" xrefstyle="enp"/> uses a smart pointer <varname>p</varname> with the type <type>boost::scoped_ptr&lt;int&gt;</type>. <varname>p</varname> is initialized with a pointer to a dynamically allocated object that stores the number 1. Via <methodname role="operator">operator*</methodname><indexterm><primary>scoped_ptr::operator*</primary></indexterm><indexterm><primary>operator*, scoped_ptr</primary></indexterm>, <varname>p</varname> is de-referenced and <computeroutput>1</computeroutput> written to standard output.</para>
    <para>With <methodname>reset</methodname><indexterm><primary>scoped_ptr::reset</primary></indexterm><indexterm><primary>reset, scoped_ptr</primary></indexterm> a new address can be stored in the smart pointer. That way the example passes the address of a newly allocated <type>int</type> object containing the number 2 to <varname>p</varname>. With the call to <methodname>reset</methodname>, the currently referenced object in <varname>p</varname> is automatically destroyed.</para>
    <para><methodname>get</methodname><indexterm><primary>scoped_ptr::get</primary></indexterm><indexterm><primary>get, scoped_ptr</primary></indexterm> returns the address of the object anchored in the smart pointer. The example de-references the address returned by <methodname>get</methodname> to write <computeroutput>2</computeroutput> to standard output.</para>
    <para><classname>boost::scoped_ptr</classname> overloads the operator <methodname role="operator">operator bool</methodname><indexterm><primary>scoped_ptr::operator bool</primary></indexterm><indexterm><primary>operator bool, scoped_ptr</primary></indexterm>. <methodname role="operator">operator bool</methodname> returns <literal>true</literal> if the smart pointer contains a reference to an object &#x2013; that is, if it isn’t empty. The example writes <computeroutput>false</computeroutput> to standard output because <varname>p</varname> has been reset with a call to <methodname>reset</methodname>.</para>
    <para>The destructor of <classname>boost::scoped_ptr</classname> releases the referenced object with <code>delete</code>. That’s why <classname>boost::scoped_ptr</classname> must not be initialized with the address of a dynamically allocated array, which would have to be released with <code>delete[]</code>. For arrays, Boost.SmartPointers provides the class <classname>boost::scoped_array</classname>.</para>
    <example xml:id="ex.smartpointers_02">
      <title>Using <classname>boost::scoped_array</classname></title>
      <programlisting><xi:include href="../src/smartpointers_02/main.cpp" parse="text"/></programlisting>
    </example>
    <para>The smart pointer <classname>boost::scoped_array</classname><indexterm><primary>scoped_array, Boost.SmartPointers</primary></indexterm> is used like <classname>boost::scoped_ptr</classname>. The crucial difference is that the destructor of <classname>boost::scoped_array</classname> uses the operator <code>delete[]</code> to release the contained object. Because this operator only applies to arrays, a <classname>boost::scoped_array</classname> must be initialized with the address of a dynamically allocated array.</para>
    <para><classname>boost::scoped_array</classname> is defined in <filename class="headerfile">boost/scoped_array.hpp</filename>.</para>
    <para><classname>boost::scoped_array</classname> provides overloads for <methodname role="operator">operator[]</methodname><indexterm><primary>scoped_array::operator[]</primary></indexterm><indexterm><primary>operator[], scoped_array</primary></indexterm> and <methodname role="operator">operator bool</methodname><indexterm><primary>scoped_array::operator bool</primary></indexterm><indexterm><primary>operator bool, scoped_array</primary></indexterm>. Using <methodname role="operator">operator[]</methodname>, a specific element of the array can be accessed. Thus, an object of type <classname>boost::scoped_array</classname> behaves like the array it owns. <xref linkend="ex.smartpointers_02" xrefstyle="enp"/> saves the number 2 as the second element in the array referred to by <varname>p</varname>.</para>
    <para>Like <classname>boost::scoped_ptr</classname>, the member functions <methodname>get</methodname><indexterm><primary>scoped_array::get</primary></indexterm><indexterm><primary>get, scoped_array</primary></indexterm> and <methodname>reset</methodname><indexterm><primary>scoped_array::reset</primary></indexterm><indexterm><primary>reset, scoped_array</primary></indexterm> are provided to retrieve and reinitialize the address of the contained object.</para>
  </sect1>
  <sect1 xml:id="boost.smartpointers-shared-ownership">
    <title>Shared Ownership</title>
    <para>The smart pointer <classname>boost::shared_ptr</classname><indexterm><primary>shared_ptr, Boost.SmartPointers</primary></indexterm> is similar to <classname>boost::scoped_ptr</classname>. The key difference is that <classname>boost::shared_ptr</classname> is not necessarily the exclusive owner of an object. Ownership can be shared with other smart pointers of type <classname>boost::shared_ptr</classname>. In such a case, the shared object is not released until the last copy of the shared pointer referencing the object is destroyed. Because <classname>boost::shared_ptr</classname> can share ownership, the smart pointer can be copied, which isn’t possible with <classname>boost::scoped_ptr</classname>.</para>
    <para><classname>boost::shared_ptr</classname> is defined in the header file <filename class="headerfile">boost/shared_ptr.hpp</filename>.</para>
    <example xml:id="ex.smartpointers_03">
      <title>Using <classname>boost::shared_ptr</classname></title>
      <programlisting><xi:include href="../src/smartpointers_03/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.smartpointers_03" xrefstyle="enp"/> uses two smart pointers, <varname>p1</varname> and <varname>p2</varname>, of the type <classname>boost::shared_ptr</classname>. <varname>p2</varname> is initialized with <varname>p1</varname> which means both smart pointers share ownership of the same <type>int</type> object. When <methodname>reset</methodname><indexterm><primary>shared_ptr::reset</primary></indexterm><indexterm><primary>reset, shared_ptr</primary></indexterm> is called on <varname>p1</varname>, a new <type>int</type> object is anchored in <varname>p1</varname>. This doesn’t mean that the existing <type>int</type> object is destroyed. Since it is also anchored in <varname>p2</varname>, it continues to exist. After the call to <methodname>reset</methodname>, <varname>p1</varname> is the sole owner of the <type>int</type> object with the number 2 and <varname>p2</varname> the sole owner of the <type>int</type> object with the number 1.</para>
    <para><classname>boost::shared_ptr</classname> uses a reference counter internally. Only when <classname>boost::shared_ptr</classname> detects that the last copy of the smart pointer has been destroyed is the contained object released with <code>delete</code>.</para>
    <para>Like <classname>boost::scoped_ptr</classname>, <classname>boost::shared_ptr</classname> overloads <methodname>operator bool</methodname><indexterm><primary>shared_ptr::operator bool</primary></indexterm><indexterm><primary>operator bool, shared_ptr</primary></indexterm>, <methodname>operator*</methodname><indexterm><primary>shared_ptr::operator*</primary></indexterm><indexterm><primary>operator*, shared_ptr</primary></indexterm>, and <methodname>operator-&gt;</methodname><indexterm><primary>shared_ptr::operator-&gt;</primary></indexterm><indexterm><primary>operator-&gt;, shared_ptr</primary></indexterm>. The member functions <methodname>get</methodname><indexterm><primary>shared_ptr::get</primary></indexterm><indexterm><primary>get, shared_ptr</primary></indexterm> and <methodname>reset</methodname> are provided to retrieve the currently stored address or store a new one.</para>
    <para>As a second parameter, a <emphasis role="concept">deleter</emphasis><indexterm><primary>deleter, Boost.SmartPointers</primary></indexterm> can be passed to the constructor of <classname>boost::shared_ptr</classname>. The deleter must be a function or function object that accepts as its sole parameter a pointer of the type <classname>boost::shared_ptr</classname> was instantiated with. The deleter is called in the destructor instead of <code>delete</code>. This makes it possible to manage resources other than dynamically allocated objects in a <classname>boost::shared_ptr</classname>.</para>
    <example xml:id="ex.smartpointers_04">
      <title><classname>boost::shared_ptr</classname> with a user-defined deleter</title>
      <programlisting><xi:include href="../src/smartpointers_04/main.cpp" parse="text"/></programlisting>
    </example>
    <para>In <xref linkend="ex.smartpointers_04" xrefstyle="enp"/> <classname>boost::shared_ptr</classname> is instantiated with <type>void</type>. The first parameter passed to the constructor is the return value from <function>OpenProcess</function>. <function>OpenProcess</function> is a Windows function to get a handle to a process. In the example, <function>OpenProcess</function> returns a handle to the current process &#x2013; to the example itself.</para>
    <para>Windows uses handles to refer to resources. Once a resource isn’t used anymore, the handle must be closed with <function>CloseHandle</function>. The only parameter expected by <function>CloseHandle</function> is the handle to close. In the example, <function>CloseHandle</function> is passed as a second parameter to the constructor of <classname>boost::shared_ptr</classname>. <function>CloseHandle</function> is the deleter for <varname>handle</varname>. When <varname>handle</varname> is destroyed at the end of <function>main</function>, the destructor calls <function>CloseHandle</function> to close the handle that was passed as a first parameter to the constructor.</para>
    <note>
      <para><xref linkend="ex.smartpointers_04" xrefstyle="enp" /> only works because a Windows handle is defined as <type>void*</type>. If <function>OpenProcess</function> didn’t return a value of type <type>void*</type> and if <function>CloseHandle</function> didn’t expect a parameter of type <type>void*</type>, it wouldn’t be possible to use <classname>boost::shared_ptr</classname> in this example. The deleter does not make <classname>boost::shared_ptr</classname> a silver bullet to manage arbitrary resources.</para>
    </note>
    <example xml:id="ex.smartpointers_05">
      <title>Using <classname>boost::make_shared</classname></title>
      <programlisting><xi:include href="../src/smartpointers_05/main.cpp" parse="text"/></programlisting>
    </example>
    <para>Boost.SmartPointers provides a helper function <function>boost::make_shared</function><indexterm><primary>make_shared, Boost.SmartPointers</primary></indexterm> in <filename class="headerfile">boost/make_shared.hpp</filename>. With <function>boost::make_shared</function> you can create a smart pointer of type <classname>boost::shared_ptr</classname> without having to calling the constructor of <classname>boost::shared_ptr</classname> yourself.</para>
    <para>The advantage of <function>boost::make_shared</function> is that the memory for the object that has to be allocated dynamically and the memory for the reference counter used by the smart pointer internally can be reserved in one chunk. Using <function>boost::make_shared</function> is more efficient than calling <code>new</code> to create a dynamically allocated object and calling <code>new</code> again in the constructor of <classname>boost::shared_ptr</classname> to allocate memory for the reference counter.</para>
    <para>You can use <function>boost::make_shared</function> for arrays, too. With the second call to <function>boost::make_shared</function> in <xref linkend="ex.smartpointers_05" xrefstyle="enp"/>, an <type>int</type> array with ten elements is anchored in <varname>p2</varname>.</para>
    <para><classname>boost::shared_ptr</classname> has only supported arrays since Boost 1.53.0. <classname>boost::shared_array</classname> provides a smart pointer that is analogous to <classname>boost::shared_ptr</classname> in the same way that <classname>boost::scoped_array</classname> is analogous to <classname>boost::scoped_ptr</classname>. When built with Visual C++ 2013 and Boost 1.53.0 or newer, <xref linkend="ex.smartpointers_05" xrefstyle="enp"/> prints <computeroutput>class boost::shared_ptr&lt;int [0]&gt;</computeroutput> for <varname>p2</varname>.</para>
    <para>Since Boost 1.53.0, <classname>boost::shared_ptr</classname> supports single objects and arrays and detects whether it has to release resources with <code>delete</code> or <code>delete[]</code>. Because <classname>boost::shared_ptr</classname> also overloads <methodname role="operator">operator[]</methodname> (since Boost 1.53.0), this smart pointer is an alternative for <classname>boost::shared_array</classname>.</para>
    <example xml:id="ex.smartpointers_06">
      <title>Using <classname>boost::shared_array</classname></title>
      <programlisting><xi:include href="../src/smartpointers_06/main.cpp" parse="text"/></programlisting>
    </example>
    <para><classname>boost::shared_array</classname> complements <classname>boost::shared_ptr</classname>: Since <classname>boost::shared_array</classname> calls <code>delete[]</code> in the destructor, this smart pointer can be used for arrays. For versions older than Boost 1.53.0, <classname>boost::shared_array</classname> had to be used for arrays because <classname>boost::shared_ptr</classname> didn’t support arrays.</para>
    <para><classname>boost::shared_array</classname> is defined in <filename class="headerfile">boost/shared_array.hpp</filename>.</para>
    <para>In <xref linkend="ex.smartpointers_06" xrefstyle="enp"/>, the smart pointers <varname>p1</varname> and <varname>p2</varname> share ownership of the dynamically allocated <type>int</type> array. When the array in <varname>p2</varname> is accessed with <methodname role="operator">operator[]</methodname><indexterm><primary>shared_array::operator[]</primary></indexterm><indexterm><primary>operator[], shared_array</primary></indexterm> to store the number 1, the same array is accessed with <varname>p1</varname>. Thus, the example writes <computeroutput>1</computeroutput> to standard output.</para>
    <para>Like <classname>boost::shared_ptr</classname>, <classname>boost::shared_array</classname> uses a reference counter. The dynamically allocated array is not released when <varname>p2</varname> is destroyed because <varname>p1</varname> still contains a reference to that array. The array is only destroyed at the end of <function>main</function> when the scope ends for <varname>p1</varname>.</para>
    <para><classname>boost::shared_array</classname> also provides the member functions <methodname>get</methodname><indexterm><primary>shared_array::get</primary></indexterm><indexterm><primary>get, shared_array</primary></indexterm> and <methodname>reset</methodname><indexterm><primary>shared_array::reset</primary></indexterm><indexterm><primary>reset, shared_array</primary></indexterm>. Furthermore, it overloads the operator <methodname role="operator">operator bool</methodname><indexterm><primary>shared_array::operator bool</primary></indexterm><indexterm><primary>operator bool, shared_array</primary></indexterm>.</para>
    <example xml:id="ex.smartpointers_07">
      <title><classname>boost::shared_ptr</classname> with <code>BOOST_SP_USE_QUICK_ALLOCATOR</code></title>
      <programlisting><xi:include href="../src/smartpointers_07/main.cpp" parse="text"/></programlisting>
    </example>
    <para>It can make sense to prefer a smart pointer like <classname>boost::shared_ptr</classname> over the ones from the standard library. Boost.SmartPointers supports macros to optimize the behavior of the smart pointers. <xref linkend="ex.smartpointers_07" xrefstyle="enp" /> uses the macro <code>BOOST_SP_USE_QUICK_ALLOCATOR</code><indexterm><primary>BOOST_SP_USE_QUICK_ALLOCATOR, Boost.SmartPointers</primary></indexterm> to activate an allocator shipped with Boost.SmartPointers. This allocator manages memory chunks to reduce the number of calls to <code>new</code> and <code>delete</code> for reference counters. The example calls <function>std::time</function> to measure the time before and after the loop. While the time it takes to execute the loop depends on the computer, the example may run faster with <code>BOOST_SP_USE_QUICK_ALLOCATOR</code> than without. The documentation for Boost.SmartPointers doesn’t mention <code>BOOST_SP_USE_QUICK_ALLOCATOR</code>. Thus, you should profile your program and compare the results you get with and without <code>BOOST_SP_USE_QUICK_ALLOCATOR</code>.</para>
    <tip>
      <para>In addition to <code>BOOST_SP_USE_QUICK_ALLOCATOR</code>, Boost.SmartPointers supports macros like <code>BOOST_SP_ENABLE_DEBUG_HOOKS</code><indexterm><primary>BOOST_SP_ENABLE_DEBUG_HOOKS, Boost.SmartPointers</primary></indexterm>. The names of the macros start with BOOST_SP_ which makes it easy to search for them in the header files to get an overview on the available macros.</para>
    </tip>
  </sect1>
  <sect1 xml:id="boost.smartpointers-special-smart-pointers">
    <title>Special Smart Pointers</title>
    <para>Every smart pointer introduced so far can be used individually in different scenarios. However, <classname>boost::weak_ptr</classname><indexterm><primary>weak_ptr, Boost.SmartPointers</primary></indexterm> only makes sense if used in conjunction with <classname>boost::shared_ptr</classname>. <classname>boost::weak_ptr</classname> is defined in <filename class="headerfile">boost/weak_ptr.hpp</filename>.</para>
    <example xml:id="ex.smartpointers_08">
      <title>Using <classname>boost::weak_ptr</classname></title>
      <programlisting><xi:include href="../src/smartpointers_08/main.cpp" parse="text"/></programlisting>
    </example>
    <para><classname>boost::weak_ptr</classname> must be initialized with a <classname>boost::shared_ptr</classname>. Its most important member function is <methodname>lock</methodname><indexterm><primary>weak_ptr::lock</primary></indexterm><indexterm><primary>lock, weak_ptr</primary></indexterm>. <methodname>lock</methodname> returns a <classname>boost::shared_ptr</classname> that shares ownership with the shared pointer used to initialize the weak pointer. In case the shared pointer is empty, the returned pointer will be empty as well.</para>
    <para><classname>boost::weak_ptr</classname> makes sense whenever a function is expected to work with an object managed by a shared pointer, but the lifetime of the object does not depend on the function itself. The function can only use the object as long as it is owned by at least one shared pointer somewhere else in the program. In case the shared pointer is reset, the object cannot be kept alive because of an additional shared pointer inside the corresponding function.</para>
    <para><xref linkend="ex.smartpointers_08" xrefstyle="enp"/> creates two threads in <function>main</function>. The first thread executes the function <function>reset</function>, which receives a reference to a shared pointer. The second thread executes the function <function>print</function>, which receives a reference to a weak pointer. This weak pointer has been previously initialized with the shared pointer.</para>
    <para>Once the program is launched, both <function>reset</function> and <function>print</function> are executed at the same time. However, the order of execution cannot be predicted. This leads to the potential problem of <function>reset</function> destroying the object while it is being accessed by <function>print</function>.</para>
    <para>The weak pointer solves this issue as follows: invoking <methodname>lock</methodname> returns a shared pointer that points to a valid object if one exists at the time of the call. If not, the shared pointer is set to 0 and is equivalent to a null pointer.</para>
    <para><classname>boost::weak_ptr</classname> itself does not have any impact on the lifetime of an object. To safely access the object within the <function>print</function> function, <methodname>lock</methodname> returns a <classname>boost::shared_ptr</classname>. This guarantees that even if a different thread attempts to release the object, it will continue to exist thanks to the returned shared pointer.</para>
    <example xml:id="ex.smartpointers_09">
      <title>Using <classname>boost::intrusive_ptr</classname></title>
      <?dbfo keep-together="auto"?>
      <programlisting><xi:include href="../src/smartpointers_09/main.cpp" parse="text"/></programlisting>
    </example>
    <para>In general, <classname>boost::intrusive_ptr</classname><indexterm><primary>intrusive_ptr, Boost.SmartPointers</primary></indexterm> works the same as <classname>boost::shared_ptr</classname>. However, while <classname>boost::shared_ptr</classname> keeps track of the number of shared pointers referencing a particular object, the developer has to do this when using <classname>boost::intrusive_ptr</classname>. This can make sense if other classes already keep track of references.</para>
    <para><classname>boost::intrusive_ptr</classname> is defined in <filename class="headerfile">boost/intrusive_ptr.hpp</filename>.</para>
    <para><xref linkend="ex.smartpointers_09" xrefstyle="enp"/> uses functions provided by <acronym>COM</acronym> and, thus, can only be built and run on Windows. <acronym>COM</acronym> objects are a good example for <classname>boost::intrusive_ptr</classname> because they track the number of pointers referencing them. The internal reference counter can be incremented or decremented by 1 with the member functions <methodname>AddRef</methodname> and <methodname>Release</methodname>. Once the counter reaches 0, the <acronym>COM</acronym> object is automatically destroyed.</para>
    <para>The two member functions <methodname>AddRef</methodname> and <methodname>Release</methodname> are called from <function>intrusive_ptr_add_ref</function><indexterm><primary>intrusive_ptr_add_ref, Boost.SmartPointers</primary></indexterm> and <function>intrusive_ptr_release</function><indexterm><primary>intrusive_ptr_release, Boost.SmartPointers</primary></indexterm>. Boost.Intrusive expects a developer to define these two functions, which are automatically called whenever a reference counter must be incremented or decremented. The parameter passed to these functions is a pointer to the type that was used to instantiate the class template <classname>boost::intrusive_ptr</classname>.</para>
    <para>The <acronym>COM</acronym> object used in this example is called FileSystemObject and is available on Windows by default. It provides access to the underlying file system to, for example, check whether a given directory exists. In <xref linkend="ex.smartpointers_09" xrefstyle="enp"/>, the existence of a directory called <filename class="directory">C:\Windows</filename> is checked. How that works internally depends solely on <acronym>COM</acronym> and is irrelevant to the functionality of <classname>boost::intrusive_ptr</classname>. The crucial point is that once the intrusive pointer <varname>disp</varname> goes out of scope at the end of <function>check_windows_folder</function>, the function <function>intrusive_ptr_release</function> is called automatically. This in turn will decrement the internal reference counter of FileSystemObject to 0 and destroy the object.</para>
    <para>The parameter <literal>false</literal> passed to the constructor of <classname>boost::intrusive_ptr</classname> prevents <function>intrusive_ptr_add_ref</function> from being called. When a <acronym>COM</acronym> object is created with <function>CoCreateInstance</function>, the counter is already set to 1. Therefore, it must not be incremented with <function>intrusive_ptr_add_ref</function>.</para>
  </sect1>
</chapter>
