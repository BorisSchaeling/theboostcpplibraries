<?xml version="1.0" encoding="utf-8"?> <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.algorithm">
  <title>Boost.Algorithm</title><indexterm><primary>Boost.Algorithm</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/algorithm">Boost.Algorithm</link> provides algorithms that complement the algorithms from the standard library. Unlike Boost.Range, Boost.Algorithm doesn’t introduce new concepts. The algorithms defined by Boost.Algorithm resemble the algorithms from the standard library.</para>
  <para>Please note that there are numerous algorithms provided by other Boost libraries. For example, you will find algorithms to process strings in Boost.StringAlgorithms. The algorithms provided by Boost.Algorithm are not bound to particular classes, such as <classname>std::string</classname>. Like the algorithms from the standard library, they can be used with any container.</para>
  <example xml:id="ex.algorithm_01">
    <title>Testing for exactly one value with <function>boost::algorithm::one_of_equal</function></title>
    <programlisting><xi:include href="../src/algorithm_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><function>boost::algorithm::one_of</function><indexterm><primary>algorithm::one_of</primary></indexterm><indexterm><primary>one_of, algorithm</primary></indexterm> tests whether a condition is met exactly once. The condition to test is passed as a predicate. In <xref linkend="ex.algorithm_01" xrefstyle="enp"/> the call to <function>boost::algorithm::one_of</function> returns <literal>true</literal> since the number 4 is stored exactly once in <varname>a</varname>.</para>
  <para>To test elements in a container for equality, call <function>boost::algorithm::one_of_equal</function><indexterm><primary>algorithm::one_of_equal</primary></indexterm><indexterm><primary>one_of_equal, algorithm</primary></indexterm>. You don’t pass a predicate. Instead, you pass a value to compare to <function>boost::algorithm::one_of_equal</function>. In <xref linkend="ex.algorithm_01" xrefstyle="enp"/> the call to <function>boost::algorithm::one_of_equal</function> also returns <literal>true</literal>.</para>
  <para><function>boost::algorithm::one_of</function> complements the algorithms <function>std::all_of</function>, <function>std::any_of</function>, and <function>std::none_of</function>, which were added to the standard library with C++11. However, Boost.Algorithm provides the functions <function>boost::algorithm::all_of</function><indexterm><primary>algorithm::all_of</primary></indexterm><indexterm><primary>all_of, algorithm</primary></indexterm>, <function>boost::algorithm::any_of</function><indexterm><primary>algorithm::any_of</primary></indexterm><indexterm><primary>any_of, algorithm</primary></indexterm>, and <function>boost::algorithm::none_of</function><indexterm><primary>algorithm::none_of</primary></indexterm><indexterm><primary>none_of, algorithm</primary></indexterm> for developers whose development environment doesn’t support C++11. You will find these algorithms in the header files <filename class="headerfile">boost/algorithm/cxx11/all_of.hpp</filename>, <filename class="headerfile">boost/algorithm/cxx11/any_of.hpp</filename>, and <filename class="headerfile">boost/algorithm/cxx11/none_of.hpp</filename>.</para>
  <para>Boost.Algorithm also defines the following functions: <function>boost::algorithm::all_of_equal</function><indexterm><primary>algorithm::all_of_equal</primary></indexterm><indexterm><primary>all_of_equal, algorithm</primary></indexterm>, <function>boost::algorithm::any_of_equal</function><indexterm><primary>algorithm::any_of_equal</primary></indexterm><indexterm><primary>any_of_equal, algorithm</primary></indexterm>, and <function>boost::algorithm::none_of_equal</function><indexterm><primary>algorithm::none_of_equal</primary></indexterm><indexterm><primary>none_of_equal, algorithm</primary></indexterm>.</para>
  <para>Boost.Algorithm provides more algorithms from the C++11 standard library. For example, you have access to <function>boost::algorithm::is_partitioned</function><indexterm><primary>algorithm::is_partitioned</primary></indexterm><indexterm><primary>is_partitioned, algorithm</primary></indexterm>, <function>boost::algorithm::is_permutation</function><indexterm><primary>algorithm::is_permutation</primary></indexterm><indexterm><primary>is_permutation, algorithm</primary></indexterm>, <function>boost::algorithm::copy_n</function><indexterm><primary>algorithm::copy_n</primary></indexterm><indexterm><primary>copy_n, algorithm</primary></indexterm>, <function>boost::algorithm::find_if_not</function><indexterm><primary>algorithm::find_if_not</primary></indexterm><indexterm><primary>find_if_not, algorithm</primary></indexterm> and <function>boost::algorithm::iota</function><indexterm><primary>algorithm::iota</primary></indexterm><indexterm><primary>iota, algorithm</primary></indexterm>. These functions work like the identically named functions from the C++11 standard library and are provided for developers who don’t use C++11. However, Boost.Algorithm provides a few function variants that could be useful for C++11 developers, too.</para>
  <example xml:id="ex.algorithm_02">
    <title>More variants of C++11 algorithms</title>
    <programlisting><xi:include href="../src/algorithm_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Boost.Algorithm provides the C++11 algorithm <function>boost::algorithm::iota</function><indexterm><primary>algorithm::iota</primary></indexterm><indexterm><primary>iota, algorithm</primary></indexterm> in the header file <filename class="headerfile">boost/algorithm/cxx11/iota.hpp</filename>. This function generates sequentially increasing numbers. It expects two iterators for the beginning and end of a container. The elements in the container are then overwritten with sequentially increasing numbers.</para>
  <para>Instead of <function>boost::algorithm::iota</function>, <xref linkend="ex.algorithm_02" xrefstyle="enp"/> uses <function>boost::algorithm::iota_n</function><indexterm><primary>algorithm::iota_n</primary></indexterm><indexterm><primary>iota_n, algorithm</primary></indexterm>. This function expects one iterator to write the numbers to. The number of numbers to generate is passed as a third parameter to <function>boost::algorithm::iota_n</function>.</para>
  <para><function>boost::algorithm::is_increasing</function><indexterm><primary>algorithm::is_increasing</primary></indexterm><indexterm><primary>is_increasing, algorithm</primary></indexterm> and <function>boost::algorithm::is_sorted</function> are defined in the header file <filename class="headerfile">boost/algorithm/cxx11/is_sorted.hpp</filename>. <function>boost::algorithm::is_increasing</function> has the same function as <function>boost::algorithm::is_sorted</function>, but the function name expresses more clearly that the function checks that values are in increasing order. The header file also defines the related function <function>boost::algorithm::is_decreasing</function><indexterm><primary>algorithm::is_decreasing</primary></indexterm><indexterm><primary>is_decreasing, algorithm</primary></indexterm>.</para>
  <para>In <xref linkend="ex.algorithm_02" xrefstyle="enp"/>, <varname>v</varname> is passed directly to <function>boost::algorithm::is_increasing</function>. All functions provided by Boost.Algorithm have a variant that operates based on ranges. Containers can be passed directly to these functions.</para>
  <para><function>boost::algorithm::copy_until</function><indexterm><primary>algorithm::copy_until</primary></indexterm><indexterm><primary>copy_until, algorithm</primary></indexterm> is defined in <filename class="headerfile">boost/algorithm/cxx11/copy_if.hpp</filename>. This is another variant of <function>std::copy</function>. Boost.Algorithm also provides <function>boost::algorithm::copy_while</function><indexterm><primary>algorithm::copy_while</primary></indexterm><indexterm><primary>copy_while, algorithm</primary></indexterm>.</para>
  <para><xref linkend="ex.algorithm_02" xrefstyle="enp"/> displays <computeroutput>true</computeroutput> as a result from <function>boost::algorithm::is_increasing</function>, and <function>boost::algorithm::copy_until</function> writes the numbers <computeroutput>10</computeroutput>, <computeroutput>11</computeroutput>, and <computeroutput>12</computeroutput> to standard output.</para>
  <example xml:id="ex.algorithm_03">
    <title>C++14 algorithms from Boost.Algorithm</title>
    <programlisting><xi:include href="../src/algorithm_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Besides the algorithms from the C++11 standard library, Boost.Algorithm also defines algorithms that will very likely be added to the standard library with C++14. <xref linkend="ex.algorithm_03" xrefstyle="enp" /> uses new variants of two of these functions, <function>boost::algorithm::equal</function><indexterm><primary>algorithm::equal</primary></indexterm><indexterm><primary>equal, algorithm</primary></indexterm> and <function>boost::algorithm::mismatch</function><indexterm><primary>algorithm::mismatch</primary></indexterm><indexterm><primary>mismatch, algorithm</primary></indexterm>. In contrast to the identically named functions that have been part of the standard library since C++98, four iterators, rather than three, are passed to these new functions. The algorithms in <xref linkend="ex.algorithm_03" xrefstyle="enp" /> don’t expect the second sequence to contain as many elements as the first sequence.</para>
  <para>While <function>boost::algorithm::equal</function> returns a <type>bool</type>, <function>boost::algorithm::mismatch</function> returns two iterators in a <classname>std::pair</classname>. <varname>first</varname> and <varname>second</varname> refer to the elements in the first and second sequence that are the first ones mismatching. These iterators may also refer to the end of a sequence.</para>
  <para><xref linkend="ex.algorithm_03" xrefstyle="enp"/> writes <computeroutput>false</computeroutput> and <computeroutput>3</computeroutput> to standard output. <literal>false</literal> is the return value of <function>boost::algorithm::equal</function>, <computeroutput>3</computeroutput> the third element in <varname>w</varname>. Because the first two elements in <varname>v</varname> and <varname>w</varname> are equal, <function>boost::algorithm::mismatch</function> returns, in <varname>first</varname>, an iterator to the end of <varname>v</varname> and, in <varname>second</varname>, an iterator to the third element of <varname>w</varname>. Because <varname>first</varname> refers to the end of <varname>v</varname>, the iterator isn’t de-referenced, and there is no output.</para>
  <example xml:id="ex.algorithm_04">
    <title>Using <function>boost::algorithm::hex</function> and <function>boost::algorithm::unhex</function></title>
    <programlisting><xi:include href="../src/algorithm_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.algorithm_04" xrefstyle="enp"/> uses the two functions <function>boost::algorithm::hex</function><indexterm><primary>algorithm::hex</primary></indexterm><indexterm><primary>hex, algorithm</primary></indexterm> and <function>boost::algorithm::unhex</function><indexterm><primary>algorithm::unhex</primary></indexterm><indexterm><primary>unhex, algorithm</primary></indexterm>. These functions are designed after the identically named functions from the database system MySQL. They convert characters to hexadecimal values or hexadecimal values to characters.</para>
  <para><xref linkend="ex.algorithm_04" xrefstyle="enp"/> passes the vector <varname>v</varname> with the characters <quote role="reverse">C</quote>, <quote role="reverse">+</quote>, and <quote role="reverse">+</quote> to <function>boost::algorithm::hex</function>. This function expects an iterator as the second parameter to write the hexadecimal values to. The example writes <computeroutput>43</computeroutput> for <quote role="reverse">C</quote> and <computeroutput>2B</computeroutput> (twice) for the two instances of <quote role="reverse">+</quote> to standard output. The second call to <function>boost::algorithm::hex</function> does the same thing except that <quote>C++</quote> is passed as a string and <quote>432B2B</quote> is returned as a string.</para>
  <para><function>boost::algorithm::unhex</function> is the opposite of <function>boost::algorithm::hex</function>. If the array <varname>w</varname> from <xref linkend="ex.algorithm_04" xrefstyle="enp"/> is passed with six hexadecimal values, each of the three pairs of values is interpreted as <acronym>ASCII</acronym>-Code. The same happens with the second call to <function>boost::algorithm::unhex</function> when six hexadecimal values are passed as a string. In both cases <computeroutput>C++</computeroutput> is written to standard output.</para>
  <para>Boost.Algorithm provides even more algorithms. For example, there are several string matching algorithms that search text efficiently. The documentation contains an overview of all available algorithms.</para>
  <simplesect role="exercises" xml:id="boost.algorithm-exercises">
    <title>Exercise</title>
    <para>Use a function from Boost.Algorithm to assign the numbers 51 to 56 in ascending order to an array with six elements. Interpret the numbers in the array as hexadecimal values, convert them to characters and write the result to standard output.</para>
  </simplesect>
</chapter>
