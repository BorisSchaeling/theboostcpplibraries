<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.iostreams">
  <title>Boost.IOStreams</title><indexterm><primary>Boost.IOStreams</primary></indexterm>
  <para>This chapter introduces the library <link xlink:href="http://www.boost.org/libs/iostreams">Boost.IOStreams</link>. Boost.IOStreams breaks up the well-known streams from the standard library into smaller components. The library defines two concepts: <emphasis role="concept">device</emphasis><indexterm><primary>device, Boost.IOStreams</primary></indexterm>, which describes data sources and sinks, and <emphasis role="concept">stream</emphasis><indexterm><primary>stream, Boost.IOStreams</primary></indexterm>, which describes an interface for formatted input/output based on the interface from the standard library. A stream defined by Boost.IOStreams isn’t automatically connected to a data source or sink.</para>
  <para>Boost.IOStreams provides numerous implementations of the two concepts. For example, there is the device <classname>boost::iostreams::mapped_file</classname>, which loads a file partially or completely into memory. The stream <classname>boost::iostreams::stream</classname> can be connected to a device like <classname>boost::iostreams::mapped_file</classname> to use the familiar stream operators <methodname role="operator">operator&lt;&lt;</methodname> and <methodname role="operator">operator&gt;&gt;</methodname> to read and write data.</para>
  <para>In addition to <classname>boost::iostreams::stream</classname>, Boost.IOStreams provides the stream <classname>boost::iostreams::filtering_stream</classname>, which lets you add data filters. For example, you can use <classname>boost::iostreams::gzip_compressor</classname> to write data compressed in the GZIP format.</para>
  <para>Boost.IOStreams can also be used to connect to platform-specific objects. The library provides devices to connect to a Windows handle or a file descriptor. That way objects from low-level APIs can be made available in platform-independent C++ code.</para>
  <para>The classes and functions provided by Boost.IOStreams are defined in the namespace <package>boost::iostreams</package>. There is no master header file. Because Boost.IOStreams contains more than header files, it must be prebuilt. This can be important because, depending on how Boost.IOStreams has been prebuilt, support for some features could be missing.</para>
  <sect1 xml:id="boost.iostreams-devices">
    <title>Devices</title>
    <para>Devices are classes that provide read and write access to objects that are usually outside of a process &#x2013; for example, files. However, you can also access internal objects, such as arrays, as devices.</para>
    <para>A device is nothing more than a class with the member function <methodname>read</methodname> or <methodname>write</methodname>. A device can be connected with a stream so you can read and write formatted data rather than using the <methodname>read</methodname> and <methodname>write</methodname> member functions directly.</para>
    <example xml:id="ex.iostreams_01">
      <title>Using an array as a device with <classname>boost::iostreams::array_sink</classname></title>
      <programlisting><xi:include href="../src/iostreams_01/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.iostreams_01" xrefstyle="enp"/> uses the device <classname>boost::iostreams::array_sink</classname><indexterm><primary>iostreams::array_sink</primary></indexterm><indexterm><primary>array_sink, iostreams</primary></indexterm> to write data to an array. The array is passed as a parameter to the constructor. Afterwards, the device is connected with a stream of type <classname>boost::iostreams::stream</classname><indexterm><primary>iostreams::stream</primary></indexterm><indexterm><primary>stream, iostreams</primary></indexterm>. A reference to the device is passed to the constructor of <classname>boost::iostreams::stream</classname>, and the type of the device is passed as a template parameter to <classname>boost::iostreams::stream</classname>.</para>
    <para>The example uses the operator <methodname role="operator">operator&lt;&lt;</methodname> to write <quote>Boost</quote> to the stream. The stream forwards the data to the device. Because the device is connected to the array, <quote>Boost</quote> is stored in the first five elements of the array. Since the array’s contents are written to standard output, <computeroutput>Boost</computeroutput> will be displayed when you run the example.</para>
    <example xml:id="ex.iostreams_02">
      <title>Using an array as a device with <classname>boost::iostreams::array_source</classname></title>
      <programlisting><xi:include href="../src/iostreams_02/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.iostreams_02" xrefstyle="enp"/> is based on the previous example. The string written with <classname>boost::iostreams::array_sink</classname> to an array is read with <classname>boost::iostreams::array_source</classname><indexterm><primary>iostreams::array_source</primary></indexterm><indexterm><primary>array_source, iostreams</primary></indexterm>.</para>
    <para><classname>boost::iostreams::array_source</classname> is used like <classname>boost::iostreams::array_sink</classname>. While <classname>boost::iostreams::array_sink</classname> supports only write operations, <classname>boost::iostreams::array_source</classname> supports only read. <classname>boost::iostreams::array</classname><indexterm><primary>iostreams::array</primary></indexterm><indexterm><primary>array, iostreams</primary></indexterm> supports both write and read operations.</para>
    <para>Please note that <classname>boost::iostreams::array_source</classname> and <classname>boost::iostreams::array_sink</classname> receive a reference to an array. The array must not be destroyed while the devices are still in use.</para>
    <example xml:id="ex.iostreams_03">
      <title>Using a vector as a device with <classname>boost::iostreams::back_insert_device</classname></title>
      <programlisting><xi:include href="../src/iostreams_03/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.iostreams_03" xrefstyle="enp"/> uses a device of type <classname>boost::iostreams::back_insert_device</classname><indexterm><primary>iostreams::back_insert_device</primary></indexterm><indexterm><primary>back_insert_device, iostreams</primary></indexterm>, instead of <classname>boost::iostreams::array_sink</classname>. This device can be used to write data to any container that provides the member function <methodname>insert</methodname>. The device calls this member function to forward data to the container.</para>
    <para>The example uses <classname>boost::iostreams::back_insert_device</classname> to write <quote>Boost</quote> to a vector. Afterwards, <quote>Boost</quote> is read from <classname>boost::iostreams::array_source</classname>. The address of the beginning of the vector and the size are passed as parameters to the constructor of <classname>boost::iostreams::array_source</classname>.</para>
    <para><xref linkend="ex.iostreams_03" xrefstyle="enp"/> displays <computeroutput>Boost</computeroutput>.</para>
    <example xml:id="ex.iostreams_04">
      <title>Using a file as a device with <classname>boost::iostreams::file_source</classname></title>
      <programlisting><xi:include href="../src/iostreams_04/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.iostreams_04" xrefstyle="enp" /> uses the device <classname>boost::iostreams::file_source</classname><indexterm><primary>iostreams::file_source</primary></indexterm><indexterm><primary>file_source, iostreams</primary></indexterm> to read files. While the previously introduced devices don’t provide member functions, <classname>boost::iostreams::file_source</classname> provides <methodname>is_open</methodname><indexterm><primary>iostreams::file_source::is_open</primary></indexterm><indexterm><primary>is_open, iostreams::file_source</primary></indexterm> to test whether a file was opened successfully. It also provides the member function <methodname>close</methodname><indexterm><primary>iostreams::file_source::close</primary></indexterm><indexterm><primary>close, iostreams::file_source</primary></indexterm> to explicitly close a file. You don’t need to call <methodname>close</methodname> because the destructor of <classname>boost::iostreams::file_source</classname> closes a file automatically.</para>
    <para>Besides <classname>boost::iostreams::file_source</classname>, Boost.IOStreams also provides the device <classname>boost::iostreams::mapped_file_source</classname><indexterm><primary>iostreams::mapped_file_source</primary></indexterm><indexterm><primary>mapped_file_source, iostreams</primary></indexterm> to load a file partially or completely into memory. <classname>boost::iostreams::mapped_file_source</classname> defines a member function <methodname>data</methodname><indexterm><primary>iostreams::mapped_file_source::data</primary></indexterm><indexterm><primary>data, iostreams::mapped_file_source</primary></indexterm> to receive a pointer to the respective memory area. That way, data can be randomly accessed in a file without having to read the file sequentially.</para>
    <para>For write access to files, Boost.IOStreams provides the devices <classname>boost::iostreams::file_sink</classname><indexterm><primary>iostreams::file_sink</primary></indexterm><indexterm><primary>file_sink, iostreams</primary></indexterm> and <classname>boost::iostreams::mapped_file_sink</classname><indexterm><primary>iostreams::mapped_file_sink</primary></indexterm><indexterm><primary>mapped_file_sink, iostreams</primary></indexterm>.</para>
    <example xml:id="ex.iostreams_05">
      <title>Using <classname>file_descriptor_source</classname> and <classname>file_descriptor_sink</classname></title>
      <programlisting><xi:include href="../src/iostreams_05/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.iostreams_05" xrefstyle="enp"/> uses the devices <classname>boost::iostreams::file_descriptor_source</classname><indexterm><primary>iostreams::file_descriptor_source</primary></indexterm><indexterm><primary>file_descriptor_source, iostreams</primary></indexterm> and <classname>boost::iostreams::file_descriptor_sink</classname><indexterm><primary>iostreams::file_descriptor_sink</primary></indexterm><indexterm><primary>file_descriptor_sink, iostreams</primary></indexterm>. These devices support read and write operations on platform-specific objects. On Windows these objects are handles, and on POSIX operating systems they are file descriptors.</para>
    <para><xref linkend="ex.iostreams_05" xrefstyle="enp"/> calls the Windows function <function>CreatePipe</function> to create a pipe. The read and write ends of the pipe are received in the array <varname>handles</varname>. The read end of the pipe is passed to the device <classname>boost::iostreams::file_descriptor_source</classname>, and the write end is passed to the device <classname>boost::iostreams::file_descriptor_sink</classname>. Everything written to the stream <varname>os</varname>, which is connected to the write end, can be read from the stream <varname>is</varname>, which is connected to the read end. <xref linkend="ex.iostreams_05" xrefstyle="enp"/> sends <quote>Boost</quote> through the pipe and to standard output.</para>
    <para>The constructors of <classname>boost::iostreams::file_descriptor_source</classname> and <classname>boost::iostreams::file_descriptor_sink</classname> expect two parameters. The first parameter is a Windows handle or &#x2013; if the program is run on a POSIX system &#x2013; a file descriptor. The second parameter must be either <varname>boost::iostreams::close_handle</varname><indexterm><primary>iostreams::close_handle</primary></indexterm><indexterm><primary>close_handle, iostreams</primary></indexterm> or <varname>boost::iostreams::never_close_handle</varname><indexterm><primary>iostreams::never_close_handle</primary></indexterm><indexterm><primary>never_close_handle, iostreams</primary></indexterm>. This parameter specifies whether or not the destructor closes the Windows handle or file descriptor.</para>
  </sect1>
  <sect1 xml:id="boost.iostreams-filters">
    <title>Filters</title>
    <para>Besides devices, Boost.IOStreams also provides filters, which operate in front of devices to filter data read from or written to devices. The following examples use <classname>boost::iostreams::filtering_istream</classname><indexterm><primary>iostreams::filtering_istream</primary></indexterm><indexterm><primary>filtering_istream, iostreams</primary></indexterm> and <classname>boost::iostreams::filtering_ostream</classname><indexterm><primary>iostreams::filtering_ostream</primary></indexterm><indexterm><primary>filtering_ostream, iostreams</primary></indexterm>. They replace <classname>boost::iostreams::stream</classname>, which doesn’t support filters.</para>
    <example xml:id="ex.iostreams_06">
      <title>Using <classname>boost::iostreams::regex_filter</classname></title>
      <programlisting><xi:include href="../src/iostreams_06/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.iostreams_06" xrefstyle="enp"/> uses the device <classname>boost::iostreams::array_sink</classname> to write data to an array. The data is sent through a filter of type <classname>boost::iostreams::regex_filter</classname><indexterm><primary>iostreams::regex_filter</primary></indexterm><indexterm><primary>regex_filter, iostreams</primary></indexterm>, which replaces characters. The filter expects a regular expression and a format string. The regular expression describes what to replace. The format string specifies what the characters should be replaced with. The example replaces <quote>Boost</quote> with <quote>C++</quote>. The filter will match one or more consecutive instances of the letter <quote>o</quote> in <quote>Boost,</quote> but not zero instances.</para>
    <para>The filter and the device are connected with the stream <classname>boost::iostreams::filtering_ostream</classname>. This class provides a member function <methodname>push</methodname><indexterm><primary>iostreams::filtering_ostream::push</primary></indexterm><indexterm><primary>push, iostreams::filtering_ostream</primary></indexterm>, which the filter and the device are passed to.</para>
    <para>The filter(s) must be passed before the device; the order is important. You can pass one or more filters, but once a device has been passed, the stream is complete, and you must not call <methodname>push</methodname> again.</para>
    <para>The filter <classname>boost::iostreams::regex_filter</classname> can’t process data character by character because regular expressions need to look at character groups. That’s why <classname>boost::iostreams::regex_filter</classname> starts filtering only after a write operation is complete and all data is available. This happens when the device is removed from the stream with the member function <methodname>pop</methodname><indexterm><primary>iostreams::filtering_ostream::pop</primary></indexterm><indexterm><primary>pop, iostreams::filtering_ostream</primary></indexterm>. <xref linkend="ex.iostreams_06" xrefstyle="enp"/> calls <methodname>pop</methodname> after <quote>Boost</quote> has been written to the stream. Without the call to <methodname>pop</methodname>, <classname>boost::iostreams::regex_filter</classname> won’t process any data and won’t forward data to the device.</para>
    <para>Please note that you must not use a stream that isn’t connected with a device. However, you can complete a stream if you add a device with <methodname>push</methodname> after a call to <methodname>pop</methodname>.</para>
    <para><xref linkend="ex.iostreams_06" xrefstyle="enp"/> displays <computeroutput>C++</computeroutput>.</para>
    <example xml:id="ex.iostreams_07">
      <title>Accessing filters in <classname>boost::iostreams::filtering_ostream</classname></title>
      <programlisting><xi:include href="../src/iostreams_07/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.iostreams_07" xrefstyle="enp"/> uses the filter <classname>boost::iostreams::counter</classname><indexterm><primary>iostreams::counter</primary></indexterm><indexterm><primary>counter, iostreams</primary></indexterm>, which counts characters and lines. This class provides the member functions <methodname>characters</methodname><indexterm><primary>iostreams::counter::characters</primary></indexterm><indexterm><primary>characters, iostreams::counter</primary></indexterm> and <methodname>lines</methodname><indexterm><primary>iostreams::counter::lines</primary></indexterm><indexterm><primary>lines, iostreams::counter</primary></indexterm>.</para>
    <para><classname>boost::iostreams::filtering_stream</classname> provides the member function <methodname>component</methodname><indexterm><primary>iostreams::filtering_stream::component</primary></indexterm><indexterm><primary>component, iostreams::filtering_stream</primary></indexterm> to access a filter. The index of the respective filter must be passed as a parameter. Because <methodname>component</methodname> is a template, the type of the filter must be passed as a template parameter. <methodname>component</methodname> returns a pointer to the filter. It returns 0 if an incorrect filter type is passed as a template parameter.</para>
    <para><xref linkend="ex.iostreams_07" xrefstyle="enp"/> writes five characters to the stream. It does not write a newline (<quote>\n</quote>). Thus, the example displays <computeroutput>5</computeroutput> and <computeroutput>0</computeroutput>.</para>
    <example xml:id="ex.iostreams_08">
      <title>Writing and reading data compressed with ZLIB</title>
      <programlisting><xi:include href="../src/iostreams_08/main.cpp" parse="text"/><?dbhtml source="src/iostreams_08/main.cpp"?></programlisting>
    </example>
    <para><xref linkend="ex.iostreams_08" xrefstyle="enp"/> uses the stream <classname>boost::iostreams::filtering_istream</classname> in addition to <classname>boost::iostreams::filtering_ostream</classname>. This stream is used when you want to read data with filters. In the example, compressed data is written and read again.</para>
    <para>Boost.IOStreams provides several data compression filters. The class <classname>boost::iostreams::zlib_compressor</classname><indexterm><primary>iostreams::zlib_compressor</primary></indexterm><indexterm><primary>zlib_compressor, iostreams</primary></indexterm> compresses data in the ZLIB format. To uncompress data in the ZLIB format, use the class <classname>boost::iostreams::zlib_decompressor</classname><indexterm><primary>iostreams::zlib_decompressor</primary></indexterm><indexterm><primary>zlib_decompressor, iostreams</primary></indexterm>. These filters are added to the streams using <methodname>push</methodname>.</para>
    <para><xref linkend="ex.iostreams_08" xrefstyle="enp"/> writes <quote>Boost</quote> to the vector <varname>v</varname> in compressed form and to the string <varname>s</varname> in uncompressed form. The example displays <computeroutput>Boost</computeroutput>.</para>
    <note>
      <para>Please note that on Windows, the Boost.IOStreams prebuilt library doesn’t support data compression because, by default, the library is built with the macro <code>NO_ZLIB</code><indexterm><primary>NO_ZLIB, Boost.IOStreams</primary></indexterm> on Windows. You must undefine this macro, define <code>ZLIB_LIBPATH</code><indexterm><primary>ZLIB_LIBPATH, Boost.IOStreams</primary></indexterm> and <code>ZLIB_SOURCE</code><indexterm><primary>ZLIB_SOURCE, Boost.IOStreams</primary></indexterm>, and rebuild to get ZLIB support on Windows.</para>
    </note>
    <simplesect role="exercises" xml:id="boost.iostreams-filters-exercises">
      <title>Exercise</title>
      <para>Create two command line programs which can compress and uncompress a file.</para>
    </simplesect>
  </sect1>
</chapter>
