<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.accumulators">
  <title>Boost.Accumulators</title><indexterm><primary>Boost.Accumulators</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/accumulators">Boost.Accumulators</link> provides classes to process samples. For example, you can find the largest or smallest sample, or calculate the total of all samples. While the standard library supports some of these operations, Boost.Accumulators also supports statistical calculations, such as mean and standard deviation.</para>
  <para>The library is called Boost.Accumulators because the <emphasis role="concept">accumulator</emphasis><indexterm><primary>accumulator, Boost.Accumulators</primary></indexterm> is an essential concept. An accumulator is a container that calculates a new result every time a value is inserted. The value isn’t necessarily stored in the accumulator. Instead the accumulator continuously updates intermediary results as it is fed new values.</para>
  <para>Boost.Accumulators contains three parts:</para>
  <itemizedlist>
    <listitem>
      <para>The framework provides the overall structure of the library. It provides the class <classname>boost::accumulators::accumulator_set</classname><indexterm><primary>accumulators::accumulator_set</primary></indexterm><indexterm><primary>accumulator_set, accumulators</primary></indexterm>, which is always used with Boost.Accumulators. While you need to know about this and a few other classes from the framework, the details don’t matter unless you want to develop your own accumulators. The header file <filename class="headerfile">boost/accumulators/accumulators.hpp</filename> gives you access to <classname>boost::accumulators::accumulator_set</classname> and other classes from the framework.</para>
    </listitem>
    <listitem>
      <para>Boost.Accumulators provides numerous accumulators that perform calculations. You can access and use all of these accumulators once you include <filename class="headerfile">boost/accumulators/statistics.hpp</filename>.</para>
    </listitem>
    <listitem>
      <para>Boost.Accumulators provides operators to, for example, multiply a complex number of type <classname>std::complex</classname> with an <type>int</type> value or add two vectors. The header file <filename class="headerfile">boost/accumulators/numeric/functional.hpp</filename> defines operators for <classname>std::complex</classname>, <classname>std::valarray</classname>, and <classname>std::vector</classname>. You don’t need to include the header file yourself because it is included in the header files for the accumulators. However, you have to define the macros <code>BOOST_NUMERIC_FUNCTIONAL_STD_COMPLEX_SUPPORT</code><indexterm><primary>BOOST_NUMERIC_FUNCTIONAL_STD_COMPLEX_SUPPORT, Boost.Accumulators</primary></indexterm>, <code>BOOST_NUMERIC_FUNCTIONAL_STD_VALARRAY_SUPPORT</code><indexterm><primary>BOOST_NUMERIC_FUNCTIONAL_STD_VALARRAY_SUPPORT, Boost.Accumulators</primary></indexterm>, and <code>BOOST_NUMERIC_FUNCTIONAL_STD_VECTOR_SUPPORT</code><indexterm><primary>BOOST_NUMERIC_FUNCTIONAL_STD_VECTOR_SUPPORT, Boost.Accumulators</primary></indexterm> to make the operators available.</para>
    </listitem>
  </itemizedlist>
  <para>All classes and functions provided by Boost.Accumulators are defined in <package>boost::accumulators</package> or nested namespaces. For example, all accumulators are defined in <package>boost::accumulators::tag</package>.</para>
  <example xml:id="ex.accumulators_01">
    <title>Counting with <classname>boost::accumulators::tag::count</classname></title>
    <programlisting><xi:include href="../src/accumulators_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.accumulators_01" xrefstyle="enp"/> uses <classname>boost::accumulators::tag::count</classname><indexterm><primary>accumulators::tag::count</primary></indexterm><indexterm><primary>count, accumulators::tag</primary></indexterm>, a simple accumulator that counts the number of values passed to it. Thus, since three values are passed, this example writes <computeroutput>3</computeroutput> to standard output. To use an accumulator, you access the class <classname>boost::accumulators::accumulator_set</classname>, which is a template that expects as its first parameter the type of the values that will be processed. <xref linkend="ex.accumulators_01" xrefstyle="enp"/> passes <type>int</type> as the first parameter.</para>
  <para>The second parameter specifies the accumulators you want to use. You can use multiple accumulators. The class name <classname>boost::accumulators::accumulator_set</classname> indicates that any number of accumulators can be managed.</para>
  <para>Strictly speaking, you specify <emphasis role="concept">features</emphasis><indexterm><primary>feature, Boost.Accumulators</primary></indexterm>, not accumulators. Features define what should be calculated. You determine the what, not the how. There can be different implementations for features. The implementations are the accumulators.</para>
  <para><xref linkend="ex.accumulators_01" xrefstyle="enp"/> uses <classname>boost::accumulators::tag::count</classname><indexterm><primary>accumulators::tag::count</primary></indexterm><indexterm><primary>count, accumulators::tag</primary></indexterm> to select an accumulator that counts values. If several accumulators exist that can count values, Boost.Accumulators selects the default accumulator.</para>
  <para>Please note that you can’t pass features directly to <classname>boost::accumulators::accumulator_set</classname>. You need to use <classname>boost::accumulators::features</classname><indexterm><primary>accumulators::features</primary></indexterm><indexterm><primary>features, accumulators</primary></indexterm>.</para>
  <para>An object of type <classname>boost::accumulators::accumulator_set</classname> can be used like a function. Values can be passed by calling <methodname role="operator">operator()</methodname>. They are immediately processed. The values passed must have the same type as was passed as the first template parameter to <classname>boost::accumulators::accumulator_set</classname>.</para>
  <para>For every feature, there is an identically named <emphasis role="concept">extractor</emphasis><indexterm><primary>extractor, Boost.Accumulators</primary></indexterm>. An extractor receives the current result of an accumulator. <xref linkend="ex.accumulators_01" xrefstyle="enp"/> uses the extractor <function>boost::accumulators::count</function><indexterm><primary>accumulators::count</primary></indexterm><indexterm><primary>count, accumulators</primary></indexterm>. The only parameter passed is <varname>acc</varname>. <function>boost::accumulators::count</function> returns 3.</para>
  <example xml:id="ex.accumulators_02">
    <title>Using <classname>mean</classname> and <classname>variance</classname></title>
    <programlisting><xi:include href="../src/accumulators_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.accumulators_02" xrefstyle="enp"/> uses the two features <classname>boost::accumulators::tag::mean</classname><indexterm><primary>accumulators::tag::mean</primary></indexterm><indexterm><primary>mean, accumulators::tag</primary></indexterm> and <classname>boost::accumulators::tag::variance</classname><indexterm><primary>accumulators::tag::variance</primary></indexterm><indexterm><primary>variance, accumulators::tag</primary></indexterm> to calculate the mean and the variance of five values. The example writes <computeroutput>10</computeroutput> and <computeroutput>2</computeroutput> to standard output.</para>
  <para>The variance is 2 because Boost.Accumulators assigns a weight of 0.2 to each of the five values. The accumulator selected with <classname>boost::accumulators::tag::variance</classname> uses weights. If weights are not set explicitly, all values are given the same weight.</para>
  <example xml:id="ex.accumulators_03">
    <title>Calculating the weighted variance</title>
    <programlisting><xi:include href="../src/accumulators_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.accumulators_03" xrefstyle="enp"/> passes <type>int</type> as a third template parameter to <classname>boost::accumulators::accumulator_set</classname>. This parameter specifies the data type of the weights. In this example, weights are assigned to every value.</para>
  <para>Boost.Accumulators uses Boost.Parameter to pass additional parameters, such as weights, as name/value pairs. The parameter name for weights is <varname>weight</varname>. You can treat the parameter like a variable and assign a value. The name/value pair is passed as an additional parameter after every value to the accumulator.</para>
  <para>In <xref linkend="ex.accumulators_03" xrefstyle="enp"/>, the value 10 has a weight of 4 while all other values have a weight of 1. The mean is still 10 since weights don’t matter for means. However, the variance is now 1.25. It has decreased compared to the previous example because the middle value has a higher weight than the other values.</para>
  <para>Boost.Accumulators provides many more accumulators. They are used like the accumulators introduced in this chapter. The documentation of the library contains an overview on all available accumulators.</para>
</chapter>
