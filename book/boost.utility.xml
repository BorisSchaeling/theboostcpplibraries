<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.utility">
  <title>Boost.Utility</title><indexterm><primary>Boost.Utility</primary></indexterm>
  <para>The library <link xlink:href="http://www.boost.org/libs/utility">Boost.Utility</link> is a conglomeration of miscellaneous, useful classes and functions that are too small to justify being maintained in stand-alone libraries. While the utilities are small and can be learned quickly, they are completely unrelated. Unlike the examples in other chapters, the code samples here do not build on each other, since they are independent utilities.</para>
  <para>While most utilities are defined in <filename class="headerfile">boost/utility.hpp</filename>, some have their own header files. The following examples include the appropriate header file for the utility being introduced.</para>
  <example xml:id="ex.utility_01">
    <title>Using <function>boost::checked_delete</function></title>
    <programlisting><xi:include href="../src/utility_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.utility_01" xrefstyle="enp"/> passes the function <function>boost::checked_delete</function><indexterm><primary>checked_delete, Boost.Utility</primary></indexterm> as a parameter to the member function <methodname>pop_back_and_dispose</methodname>, which is provided by the class <classname>boost::intrusive::list</classname> from Boost.Intrusive. <classname>boost::intrusive::list</classname> and <methodname>pop_back_and_dispose</methodname> are introduced in <xref linkend="boost.intrusive" xrefstyle="wtp"/>, while <function>boost::checked_delete</function> is provided by Boost.Utility and defined in <filename class="headerfile">boost/checked_delete.hpp</filename>.</para>
  <para><function>boost::checked_delete</function> expects as its sole parameter a pointer to the object that will be deleted by <code>delete</code>. Because <methodname>pop_back_and_dispose</methodname> expects a function that takes a pointer to destroy the corresponding object, it makes sense to pass in <function>boost::checked_delete</function> &#x2013; that way, you don’t need to define a similar function.</para>
  <para>Unlike <code>delete</code>, <function>boost::checked_delete</function> ensures that the type of the object to be destroyed is complete. <code>delete</code> will accept a pointer to an object with an incomplete type. While this concerns a detail of the C++ standard that you can usually ignore, you should note that <function>boost::checked_delete</function> is not completely identical to a call to <code>delete</code> because it puts higher demands on its parameter.</para>
  <para>Boost.Utility also provides <function>boost::checked_array_delete</function><indexterm><primary>checked_array_delete, Boost.Utility</primary></indexterm>, which can be used to destroy arrays. It calls <code>delete[]</code> rather than <code>delete</code>.</para>
  <para>Additionally, two classes, <classname>boost::checked_deleter</classname><indexterm><primary>checked_deleter, Boost.Utility</primary></indexterm> and <classname>boost::checked_array_deleter</classname><indexterm><primary>checked_array_deleter, Boost.Utility</primary></indexterm>, are available to create function objects that behave like <function>boost::checked_delete</function> and <function>boost::checked_array_delete</function>, respectively.</para>
  <example xml:id="ex.utility_02">
    <title>Using <code>BOOST_CURRENT_FUNCTION</code></title>
    <programlisting><xi:include href="../src/utility_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.utility_02" xrefstyle="enp"/> uses the macro <code>BOOST_CURRENT_FUNCTION</code><indexterm><primary>BOOST_CURRENT_FUNCTION, Boost.Utility</primary></indexterm>, defined in <filename class="headerfile">boost/current_function.hpp</filename>, to return the name of the surrounding function as a string.</para>
  <para><code>BOOST_CURRENT_FUNCTION</code> provides a platform-independent way to retrieve the name of a function. Starting with C++11, you can do the same thing with the standardized macro <code>__func__</code>. Before C++11, compilers like Visual C++ and GCC supported the macro <code>__FUNCTION__</code> as an extension. <code>BOOST_CURRENT_FUNCTION</code> uses whatever macro is supported by the compiler.</para>
  <para>If compiled with Visual C++ 2013, <xref linkend="ex.utility_02" xrefstyle="enp"/> displays <computeroutput>int __cdecl main(void)</computeroutput>.</para>
  <example xml:id="ex.utility_03">
    <title>Using <function>boost::prior</function> and <function>boost::next</function></title>
    <programlisting><xi:include href="../src/utility_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Boost.Utility provides two functions, <function>boost::prior</function><indexterm><primary>prior, Boost.Utility</primary></indexterm> and <function>boost::next</function><indexterm><primary>next, Boost.Utility</primary></indexterm>, that return an iterator relative to another iterator. In <xref linkend="ex.utility_03" xrefstyle="enp" />, <varname>it</varname> points to <quote role="reverse">b</quote> in the array, <varname>prior</varname> points to <quote role="reverse">a</quote>, and <varname>next</varname> to <quote role="reverse">d</quote>.</para>
  <para>Unlike <function>std::advance</function>, <function>boost::prior</function> and <function>boost::next</function> return a new iterator and do not modify the iterator that was passed in.</para>
  <para>In addition to the iterator, both functions accept a second parameter that indicates the number of steps to move forward or backward. In <xref linkend="ex.utility_03" xrefstyle="enp"/>, the iterator is moved two steps backward in the call to <function>boost::prior</function> and one step forward in the call to <function>boost::next</function>.</para>
  <para>The number of steps is always a positive number, even for <function>boost::prior</function>, which moves backwards.</para>
  <para>To use <function>boost::prior</function> and <function>boost::next</function>, include the header file <filename class="headerfile">boost/next_prior.hpp</filename>.</para>
  <para>Both functions were added to the standard library in C++11, where they are called <function>std::prev</function> and <function>std::next</function>. They are defined in the header file <filename class="headerfile">iterator</filename>.</para>
  <example xml:id="ex.utility_04">
    <title>Using <classname>boost::noncopyable</classname></title>
    <programlisting><xi:include href="../src/utility_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Boost.Utility provides the class <classname>boost::noncopyable</classname><indexterm><primary>noncopyable, Boost.Utility</primary></indexterm>, which is defined in <filename class="headerfile">boost/noncopyable.hpp</filename>. This class makes it impossible to copy (and move) objects.</para>
  <para>The same effect can be achieved by defining the copy constructor and assignment operator as private member functions or &#x2013; since C++11 &#x2013; by removing the copy constructor and assignment operator with <code>delete</code>. However, deriving from <classname>boost::noncopyable</classname> explicitly states the intention that objects of a class should be non-copyable.</para>
  <note>
    <para>Some developers prefer <classname>boost::noncopyable</classname> while others prefer to remove member functions explicitly with <code>delete</code>. You will find arguments for both approaches at <link xlink:href="http://stackoverflow.com/questions/7823990/what-are-the-advantages-of-boostnoncopyable">Stack Overflow</link>, among other places.</para>
  </note>
  <para><xref linkend="ex.utility_04" xrefstyle="enp"/> can be compiled and executed. However, if the signature of the <function>print</function> function is modified to take an object of type <classname>animal</classname> by value rather than by reference, the resulting code will no longer compile.</para>
  <example xml:id="ex.utility_05">
    <title>Using <function>boost::addressof</function></title>
    <programlisting><xi:include href="../src/utility_05/main.cpp" parse="text"/></programlisting>
  </example>
  <para>To retrieve the address of a particular object, even if <methodname role="operator">operator&amp;</methodname> has been overloaded, Boost.Utility provides the function <function>boost::addressof</function><indexterm><primary>addressof, Boost.Utility</primary></indexterm>, which is defined in <filename class="headerfile">boost/utility/addressof.hpp</filename> (see <xref linkend="ex.utility_05" xrefstyle="enp"/>). With C++11, this function became part of the standard library and is available as <function>std::addressof</function> in the header file <filename class="headerfile">memory</filename>.</para>
  <example xml:id="ex.utility_06">
    <title>Using <code>BOOST_BINARY</code></title>
    <programlisting><xi:include href="../src/utility_06/main.cpp" parse="text"/></programlisting>
  </example>
  <para>The macro <code>BOOST_BINARY</code><indexterm><primary>BOOST_BINARY, Boost.Utility</primary></indexterm> lets you create numbers in binary form. Standard C++ only supports hexadecimal and octal forms, using the prefixes <code>0x</code> and <code>0</code>. C++11 introduced user-defined literals, which allows you to define custom suffixes, but there still is no standard way of using numbers in binary form in C++11.</para>
  <para><xref linkend="ex.utility_06" xrefstyle="enp"/> displays <computeroutput>145</computeroutput> and <computeroutput>-32768</computeroutput>. The bit sequence stored in <varname>s</varname> represents a negative number because the 16-bit type <code>short</code> uses the 16<superscript>th</superscript> bit &#x2013; the most significant bit in <code>short</code> &#x2013; as the sign bit.</para>
  <para><code>BOOST_BINARY</code> simply offers another option to write numbers. Because, in C++, the default type for numbers is <code>int</code>, <code>BOOST_BINARY</code> also uses <code>int</code>. To define a number of type <code>long</code>, use the macro <code>BOOST_BINARY_L</code><indexterm><primary>BOOST_BINARY_L, Boost.Utility</primary></indexterm>, which generates the equivalent of a number suffixed with the letter L.</para>
  <para>Boost.Utility includes additional macros such as <code>BOOST_BINARY_U</code><indexterm><primary>BOOST_BINARY_U, Boost.Utility</primary></indexterm>, which initializes a variable without a sign bit. All of these macros are defined in the header file <filename class="headerfile">boost/utility/binary.hpp</filename>.</para>
  <example xml:id="ex.utility_07">
    <title>Using <classname>boost::string_ref</classname></title>
    <programlisting><xi:include href="../src/utility_07/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.utility_07" xrefstyle="enp"/> introduces the class <classname>boost::string_ref</classname><indexterm><primary>string_ref, Boost.Utility</primary></indexterm>, which is a reference to a string that only supports read access. To a certain extent, the reference is comparable with <code>const std::string&amp;</code>. However, <code>const std::string&amp;</code> requires the existence of an object of type <classname>std::string</classname>. <classname>boost::string_ref</classname> can also be used without <classname>std::string</classname>. The benefit of <classname>boost::string_ref</classname> is that, unlike <classname>std::string</classname>, it requires no memory to be allocated.</para>
  <para><xref linkend="ex.utility_07" xrefstyle="enp"/> looks for the word <quote>Boost</quote> in a string. If found, a string starting with that word is displayed. If the word <quote>Boost</quote> isn’t found, an empty string is displayed. The type of the string <varname>s</varname> in <function>main</function> isn’t <classname>std::string</classname>, it’s <classname>boost::string_ref</classname>. Thus no memory is allocated with <code>new</code> and no copy is created. <varname>s</varname> points to the literal string <quote>The Boost C++ Libraries</quote> directly.</para>
  <para>The type of the return value of <function>start_at_boost</function> is <classname>boost::string_ref</classname>, not <classname>std::string</classname>. The function doesn’t return a new string, it returns a reference. This reference is to either a substring of the parameter or an empty string. <function>start_at_boost</function> requires that the original string remains valid as long as references of type <classname>boost::string_ref</classname> are in use. If this is guaranteed, as in <xref linkend="ex.utility_07" xrefstyle="np"/>, memory allocations can be avoided.</para>
  <para>Additional utilities are also available, but they are beyond the scope of this book because they are mostly used by the developers of Boost libraries or for template meta programming. The documentation of Boost.Utility provides a fairly comprehensive overview of these additional utilities and can serve as a starting point if you are interested.</para>
</chapter>
