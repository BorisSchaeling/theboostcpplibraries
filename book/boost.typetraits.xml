<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.typetraits">
  <title>Boost.TypeTraits</title><indexterm><primary>Boost.TypeTraits</primary></indexterm>
  <para>Types have different properties that generic programming takes advantage of. The <link xlink:href="http://www.boost.org/libs/type_traits">Boost.TypeTraits</link> library provides the tools needed to determine a typeâ€™s properties and change them.</para>
  <para>Since C++11, some functions provided by Boost.TypeTraits can be found in the standard library. You can access those functions through the header file <filename class="headerfile">type_traits</filename>. However, Boost.TypeTraits provides additional functions.</para>
  <example xml:id="ex.typetraits_01">
    <title>Determining type categories</title>
    <programlisting><xi:include href="../src/typetraits_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.typetraits_01" xrefstyle="enp"/> calls several functions to determine type categories. <classname>boost::is_integral</classname><indexterm><primary>is_integral, Boost.TypeTraits</primary></indexterm> checks whether a type is integral &#x2013; whether it can store integers. <classname>boost::is_floating_point</classname><indexterm><primary>is_floating_point, Boost.TypeTraits</primary></indexterm> checks whether a type stores floating point numbers. <classname>boost::is_arithmetic</classname><indexterm><primary>is_arithmetic, Boost.TypeTraits</primary></indexterm> checks whether a type supports arithmetic operators. And <classname>boost::is_reference</classname><indexterm><primary>is_reference, Boost.TypeTraits</primary></indexterm> can be used to determine whether a type is a reference.</para>
  <para><classname>boost::is_integral</classname> and <classname>boost::is_floating_point</classname> are mutually exclusive. A type either stores an integer or a floating point number. However, <classname>boost::is_arithmetic</classname> and <classname>boost::is_reference</classname> can apply to multiple categories. For example, both integer and floating point types support arithmetic operations.</para>
  <para>All functions from Boost.TypeTraits provide a result in <varname>value</varname> that is either <literal>true</literal> or <literal>false</literal>. <xref linkend="ex.typetraits_01" xrefstyle="enp"/> outputs <computeroutput>true</computeroutput> for <code>is_integral&lt;int&gt;</code> and <code>is_arithmetic&lt;int&gt;</code> and outputs <computeroutput>false</computeroutput> for <code>is_floating_point&lt;int&gt;</code> and <code>is_reference&lt;int&gt;</code>. Because all of these functions are templates, nothing is processed at run time. The example behaves at run time as though the values <literal>true</literal> and <literal>false</literal> were directly used in the code.</para>
  <para>In <xref linkend="ex.typetraits_01" xrefstyle="enp"/>, the result of the various functions is a value of type <type>bool</type>, which can be written directly to standard output. If the result is to be processed by a function template, it should be forwarded as a type, not as a <type>bool</type> value.</para>
  <example xml:id="ex.typetraits_02">
    <title><classname>boost::true_type</classname> and <classname>boost::false_type</classname></title>
    <programlisting><xi:include href="../src/typetraits_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Besides <varname>value</varname>, functions from Boost.TypeTraits also provide the result in <type>type</type>. While <varname>value</varname> is a <type>bool</type> value, <type>type</type> is a type. Just like <varname>value</varname>, which can only be set to <literal>true</literal> or <literal>false</literal>, <type>type</type> can only be set to one of two types: <classname>boost::true_type</classname><indexterm><primary>true_type, Boost.TypeTraits</primary></indexterm> or <classname>boost::false_type</classname><indexterm><primary>false_type, Boost.TypeTraits</primary></indexterm>. <type>type</type> lets you pass the result of a function as a type to another function.</para>
  <para><xref linkend="ex.typetraits_02" xrefstyle="enp" /> uses another function from Boost.TypeTraits called <classname>boost::is_same</classname><indexterm><primary>is_same, Boost.TypeTraits</primary></indexterm>. This function expects two types as parameters and checks whether they are the same. To pass the results of <classname>boost::is_integral</classname>, <classname>boost::is_floating_point</classname>, <classname>boost::is_arithmetic</classname>, and <classname>boost::is_reference</classname> to <classname>boost::is_same</classname>, <type>type</type> must be accessed. <type>type</type> is then compared with <classname>boost::true_type</classname> or <classname>boost::false_type</classname>. The results from <classname>boost::is_same</classname> are then read through <varname>value</varname> again. Because this is a <type>bool</type> value, it can be written to standard output.</para>
  <example xml:id="ex.typetraits_03">
    <title>Checking type properties with Boost.TypeTraits</title>
    <programlisting><xi:include href="../src/typetraits_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.typetraits_03" xrefstyle="enp"/> introduces functions that check properties of types. <classname>boost::has_plus</classname><indexterm><primary>has_plus, Boost.TypeTraits</primary></indexterm> checks whether a type supports the operator <methodname role="operator">operator+</methodname> and whether two objects of the same type can be concatenated. <classname>boost::has_pre_increment</classname><indexterm><primary>has_pre_increment, Boost.TypeTraits</primary></indexterm> checks whether a type supports the pre-increment operator <methodname role="operator">operator++</methodname>. <classname>boost::has_trivial_copy</classname><indexterm><primary>has_trivial_copy, Boost.TypeTraits</primary></indexterm> checks whether a type has a trivial copy constructor. And <classname>boost::has_virtual_destructor</classname><indexterm><primary>has_virtual_destructor, Boost.TypeTraits</primary></indexterm> checks whether a type has a virtual destructor.</para>
  <para><xref linkend="ex.typetraits_03" xrefstyle="enp"/> displays <computeroutput>true</computeroutput> three times and <computeroutput>false</computeroutput> once.</para>
  <example xml:id="ex.typetraits_04">
    <title>Changing type properties with Boost.TypeTraits</title>
    <programlisting><xi:include href="../src/typetraits_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.typetraits_04" xrefstyle="enp"/> illustrates how type properties can be changed. <classname>boost::add_const</classname><indexterm><primary>add_const, Boost.TypeTraits</primary></indexterm> adds <code>const</code> to a type. If the type is already constant, nothing changes. The code compiles without problems, and the type remains constant.</para>
  <para><classname>boost::remove_pointer</classname><indexterm><primary>remove_pointer, Boost.TypeTraits</primary></indexterm> removes the asterisk from a pointer type and returns the type the pointer refers to. <classname>boost::make_unsigned</classname><indexterm><primary>make_unsigned, Boost.TypeTraits</primary></indexterm> turns a type with a sign into a type without a sign. And <classname>boost::add_rvalue_reference</classname><indexterm><primary>add_rvalue_reference, Boost.TypeTraits</primary></indexterm> transforms a type into a rvalue reference.</para>
  <para><xref linkend="ex.typetraits_04" xrefstyle="enp"/> writes <computeroutput>true</computeroutput> four times to standard output.</para>
</chapter>
