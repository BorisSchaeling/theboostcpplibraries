<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.lambda">
  <title>Boost.Lambda</title><indexterm><primary>Boost.Lambda</primary></indexterm>
  <para>Before C++11, you needed to use a library like <link xlink:href="http://www.boost.org/libs/lambda">Boost.Lambda</link> to take advantage of lambda functions. Since C++11, this library can be regarded as deprecated because lambda functions are now part of the programming language. If you work in a development environment that doesn’t support C++11, you should consider Boost.Phoenix before you turn to Boost.Lambda. Boost.Phoenix is a newer library and probably the better choice if you need to use lambda functions without C++11.</para>
  <para>The purpose of lambda functions is to make code more compact and easier to understand (see <xref linkend="ex.lambda_01" xrefstyle="enp"/>).</para>
  <example xml:id="ex.lambda_01">
    <title><function>std::for_each</function> with a lambda function</title>
    <programlisting><xi:include href="../src/lambda_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Boost.Lambda provides several helpers to create nameless functions. Code is written where it should be executed, without needing to be wrapped in a function and without having to call a function explicitly. In <xref linkend="ex.lambda_01" xrefstyle="enp"/>, <code>std::cout &lt;&lt; boost::lambda::_1 &lt;&lt; "\n"</code> is a lambda function that expects one parameter, which it writes, followed by a new line, to standard output.</para>
  <para><varname>boost::lambda::_1</varname><indexterm><primary>lambda::_1</primary></indexterm><indexterm><primary>_1, lambda</primary></indexterm> is a placeholder that creates a lambda function that expects one parameter. The number in the placeholder determines the number of expected parameters, so <varname>boost::lambda::_2</varname><indexterm><primary>lambda::_2</primary></indexterm><indexterm><primary>_2, lambda</primary></indexterm> expects two parameters and <varname>boost::lambda::_3</varname><indexterm><primary>lambda::_3</primary></indexterm><indexterm><primary>_3, lambda</primary></indexterm> expects three parameters. Boost.Lambda only provides these three placeholders. The lambda function in <xref linkend="ex.lambda_01" xrefstyle="enp" /> uses <varname>boost::lambda::_1</varname> because <function>std::for_each</function> expects a unary function.</para>
  <para>Include <filename class="headerfile">boost/lambda/lambda.hpp</filename> to use placeholders.</para>
  <para>Please note that <code>\n</code>, instead of <code>std::endl</code>, is used in <xref linkend="ex.lambda_01" xrefstyle="enp"/> to output a new line. If you use <code>std::endl</code>, the example won’t compile because the type of the lambda function <code>std::cout &lt;&lt; boost::lambda::_1</code> differs from what the unary function template <function>std::endl</function> expects. Thus, you can’t use <code>std::endl</code>.</para>
  <example xml:id="ex.lambda_02">
    <title>A lambda function with <function>boost::lambda::if_then</function></title>
    <programlisting><xi:include href="../src/lambda_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para>The header file <filename class="headerfile">boost/lambda/if.hpp</filename> defines constructs you can use to create <code>if</code> control structures in a lambda function. The simplest construct is the function template <function>boost::lambda::if_then</function><indexterm><primary>lambda::if_then</primary></indexterm><indexterm><primary>if_then, lambda</primary></indexterm>, which expects two parameters: the first parameter is a condition. If the condition is true, the second parameter is executed. Both parameters can be lambda functions, as in <xref linkend="ex.lambda_02" xrefstyle="enp"/>.</para>
  <para>In addition to <function>boost::lambda::if_then</function>, Boost.Lambda provides the function templates <function>boost::lambda::if_then_else</function><indexterm><primary>lambda::if_then_else</primary></indexterm><indexterm><primary>if_then_else, lambda</primary></indexterm> and <function>boost::lambda::if_then_else_return</function><indexterm><primary>lambda::if_then_else_return</primary></indexterm><indexterm><primary>if_then_else_return, lambda</primary></indexterm>, both of which expect three parameters. Function templates are also provided <code>for</code> loops and cast operators and to throw exceptions in lambda functions. The many function templates defined by Boost.Lambda make it possible to define lambda functions that are in no way inferior to normal C++ functions.</para>
</chapter>
