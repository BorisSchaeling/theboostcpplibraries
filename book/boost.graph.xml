<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.graph">
  <title>Boost.Graph</title><indexterm><primary>Boost.Graph</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/graph">Boost.Graph</link> provides tools to work with graphs. Graphs are two-dimensional point clouds with any number of lines between points. A subway map is a good example of a graph. Subway stations are points, which are connected by subway lines.</para>
  <para>The graph theory is the field of mathematics that researches graphs. Graph theory tries to answer questions such as how to determine the shortest path between two points. Auto navigation systems have to solve that problem to guide drivers to their desired location using the shortest path. Graphs are very important in practice because many problems can be modelled with them.</para>
  <para>Boost.Graph provides containers to define graphs. However, even more important are the algorithms Boost.Graph offers to operate on graphs, for example, to find the shortest path. This chapter introduces you to the containers and algorithms in Boost.Graph.</para>
  <sect1 xml:id="boost.graph-vertices-and-edges">
    <title>Vertices and Edges</title>
    <para>Graphs consist of points and lines. To create a graph, you have to define a set of points and any lines between them. <xref linkend="ex.graph_01" xrefstyle="enp"/> contains a first simple graph consisting of four points and no lines.</para>
    <example xml:id="ex.graph_01">
      <title>A graph of type <classname>boost::adjacency_list</classname> with four vertices</title>
      <programlisting><xi:include href="../src/graph_01/main.cpp" parse="text"/></programlisting>
    </example>
    <para>Boost.Graph provides three containers to define graphs. The most important container is <classname>boost::adjacency_list</classname><indexterm><primary>adjacency_list, Boost.Graph</primary></indexterm> which is used in nearly all of the examples in this chapter. To use this class, include the header file <filename class="headerfile">boost/graph/adjacency_list.hpp</filename>. If you want to use another container, you must include another header file. There is no master header file to get access to all classes and functions from Boost.Graph.</para>
    <para><classname>boost::adjacency_list</classname> is a template that is instantiated with default parameters in <xref linkend="ex.graph_01" xrefstyle="enp"/>. Later, you will see what parameters you can pass. This class is defined in <package>boost</package>. All classes and functions from Boost.Graph are defined in this namespace.</para>
    <para>To add four points to the graph, the function <function>boost::add_vertex</function><indexterm><primary>add_vertex, Boost.Graph</primary></indexterm> has to be called four times.</para>
    <para><function>boost::add_vertex</function> is a free-standing function and not a member function of <classname>boost::adjacency_list</classname>. You will find there are many free-standing functions in Boost.Graph that could have been implemented as member functions. Boost.Graph is designed to be more of a generic library than an object-oriented library.</para>
    <para><function>boost::add_vertex</function> adds a point to a graph. In graph theory, a point is called vertex, which explains the function name.</para>
    <para><function>boost::add_vertex</function> returns an object of type <classname>boost::adjacency_list::vertex_descriptor</classname><indexterm><primary>adjacency_list::vertex_descriptor</primary></indexterm><indexterm><primary>vertex_descriptor, adjacency_list</primary></indexterm>. This object represents a newly added point in the graph. You can write the objects to standard output as shown in <xref linkend="ex.graph_01" xrefstyle="enp"/>. The example displays <computeroutput>0, 1, 2, 3</computeroutput>.</para>
    <para><xref linkend="ex.graph_01" xrefstyle="enp"/> identifies points through positive integers. These numbers are indexes to a vector that is used internally in <classname>boost::adjacency_list</classname>. It’s no surprise that <function>boost::add_vertex</function> returns 0, 1, 2, and 3 since every call adds another point to the vector.</para>
    <para><classname>std::vector</classname> is the container <classname>boost::adjacency_list</classname> uses by default to store points. In this case, <classname>boost::adjacency_list::vertex_descriptor</classname> is a type definition for <type>std::size_t</type>. Because other containers can be used to store points, <classname>boost::adjacency_list::vertex_descriptor</classname> isn’t necessarily always <type>std::size_t</type>.</para>
    <example xml:id="ex.graph_02">
      <title>Accessing vertices with <function>boost::vertices</function></title>
      <programlisting><xi:include href="../src/graph_02/main.cpp" parse="text"/></programlisting>
    </example>
    <para>To get all points from a graph, call <function>boost::vertices</function><indexterm><primary>vertices, Boost.Graph</primary></indexterm>. This function returns two iterators of type <classname>boost::adjacency_list::vertex_iterator</classname><indexterm><primary>adjacency_list::vertex_iterator</primary></indexterm><indexterm><primary>vertex_iterator, adjacency_list</primary></indexterm>, which refer to the beginning and ending points. The iterators are returned in a <classname>std::pair</classname>. <xref linkend="ex.graph_02" xrefstyle="enp"/> uses the iterators to write all points to standard output. This example displays the number 0, 1, 2, and 3, just like the previous example.</para>
    <para><xref linkend="ex.graph_03" xrefstyle="enp"/> explains how points are connected with lines.</para>
    <example xml:id="ex.graph_03">
      <title>Accessing edges with <function>boost::edges</function></title>
      <programlisting><xi:include href="../src/graph_03/main.cpp" parse="text"/></programlisting>
    </example>
    <para>You call <function>boost::add_edge</function><indexterm><primary>add_edge, Boost.Graph</primary></indexterm> to connect two points in a graph. You have to pass the points and the graph as parameters. In graph theory, lines between points are called edges &#x2013; that’s why the function is called <function>boost::add_edge</function>.</para>
    <para><function>boost::add_edge</function> returns a <classname>std::pair</classname>. <varname>first</varname> provides access to the line. <varname>second</varname> is a <type>bool</type> variable that indicates whether the line was successfully added. If you run <xref linkend="ex.graph_03" xrefstyle="enp"/>, you’ll see that <code>p.second</code> is set to <literal>true</literal> for each call to <function>boost::add_edge</function>, and a new line is added to the graph with each call.</para>
    <para><function>boost::edges</function><indexterm><primary>edges, Boost.Graph</primary></indexterm> provides access to all lines in a graph. Like <function>boost::vertices</function>, <function>boost::edges</function> returns two iterators that refer to the beginning and ending lines. <xref linkend="ex.graph_03" xrefstyle="enp"/> writes all lines to standard output. The example displays <computeroutput>(0,1)</computeroutput>, <computeroutput>(0,1)</computeroutput> and <computeroutput>(1,0)</computeroutput>.</para>
    <para>The output shows that the graph has three lines. All three connect the first two points &#x2013; those with the indexes 0 and 1. The output also shows where the lines start and end. Two lines start at the first point, one at the second. The direction of the lines depends on the order of the parameters passed to <function>boost::add_edge</function>.</para>
    <para>As you see, you can have multiple lines between the same two points. However, this feature can be deactivated.</para>
    <example xml:id="ex.graph_04">
      <title><classname>boost::adjacency_list</classname> with selectors</title>
      <programlisting><xi:include href="../src/graph_04/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.graph_04" xrefstyle="enp"/> doesn’t instantiate <classname>boost::adjacency_list</classname> with default template parameters. Three parameters, called <emphasis role="concept">selectors</emphasis><indexterm><primary>selector, Boost.Graph</primary></indexterm>, are passed in. By convention, the names of selectors end in S. These selectors determine what types will be used in <classname>boost::adjacency_list</classname> to store points and lines.</para>
    <para>By default, <classname>boost::adjacency_list</classname> uses <classname>std::vector</classname> for points and lines. By passing <classname>boost::setS</classname><indexterm><primary>setS, Boost.Graph</primary></indexterm> as the first template parameter in <xref linkend="ex.graph_04" xrefstyle="enp" />, <classname>std::set</classname> is selected as the container for lines. Because <classname>std::set</classname> doesn’t support duplicates, it is not possible to add the same line using <function>boost::add_edge</function> multiple times. Thus, the example only displays <computeroutput>(0,1)</computeroutput> once.</para>
    <para>The second template parameter tells <classname>boost::adjacency_list</classname> which class should be used for points. In <xref linkend="ex.graph_04" xrefstyle="enp"/>, <classname>boost::vecS</classname><indexterm><primary>vecS, Boost.Graph</primary></indexterm> is passed. This is the default value for the second template parameter. It is only set so that you can pass a third template parameter.</para>
    <para>The third template parameter determines whether lines are directed or undirected. The default is <classname>boost::directedS</classname><indexterm><primary>directedS, Boost.Graph</primary></indexterm>, which means all lines are directed and can be drawn as arrows. Lines can only be crossed in one direction.</para>
    <para><classname>boost::undirectedS</classname><indexterm><primary>undirectedS, Boost.Graph</primary></indexterm> is used in <xref linkend="ex.graph_04" xrefstyle="enp"/>. This selector makes all lines undirected, which means it is possible to cross a line in any direction. It doesn’t matter which point is the start and which is the end. This is another reason why the graph in <xref linkend="ex.graph_04" xrefstyle="enp"/> contains only one line. The third call to the function <function>boost::add_edge</function> swaps the start and end points, but because lines in this example are undirected, this line is the same as the previous lines and, therefore, isn’t added.</para>
    <para>Boost.Graph offers more selectors, including <classname>boost::listS</classname><indexterm><primary>listS, Boost.Graph</primary></indexterm>, <classname>boost::mapS</classname><indexterm><primary>mapS, Boost.Graph</primary></indexterm>, and <classname>boost::hash_setS</classname><indexterm><primary>hash_setS, Boost.Graph</primary></indexterm>. <classname>boost::bidirectionalS</classname><indexterm><primary>bidirectionalS, Boost.Graph</primary></indexterm> can be used to make lines bidirectional. This selector is similar to <classname>boost::undirectedS</classname>, but in this case, start and end points matter. If you use <classname>boost::bidirectionalS</classname> in <xref linkend="ex.graph_04" xrefstyle="enp"/>, the third call to <function>boost::add_edge</function> will add a line to the graph.</para>
    <para><xref linkend="ex.graph_05" xrefstyle="enp"/> shows a simpler method for adding points and lines to a graph.</para>
    <example xml:id="ex.graph_05">
      <title>Creating indexes automatically with <function>boost::add_edge</function></title>
      <programlisting><xi:include href="../src/graph_05/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.graph_05" xrefstyle="enp" /> defines a graph consisting of four points. You can visualize the graph as a map with four fields, each represented by a point. The points are given the names <literal>topLeft</literal>, <literal>topRight</literal>, <literal>bottomRight</literal>, and <literal>bottomLeft</literal>. Because the names are assigned in an enumeration, each will have a numeric value that is used as an index.</para>
    <para>It is possible to define a graph without calling <function>boost::add_vertex</function>. Boost.Graph adds missing points to a graph automatically if the points passed to <function>boost::add_edge</function> don’t exist. The multiple calls to <function>boost::add_edge</function> in <xref linkend="ex.graph_05" xrefstyle="enp" /> define not only lines but also add the four points required for the lines to the graph.</para>
    <para>Please note how <function>std::tie</function> is used to store the iterators returned in a <classname>std::pair</classname> from <function>boost::edges</function> in <varname>it</varname> and <varname>end</varname>. <function>std::tie</function> has been part of the standard library since C++11.</para>
    <para>The graph in <xref linkend="ex.graph_05" xrefstyle="enp"/> is a map with four fields. To get from the top left to the bottom right, one can either cross the field in the top right or the one in the bottom left. There is no line between opposite fields. Thus it’s not possible to go directly from the top left to the bottom right. All examples in this chapter use this graph.</para>
    <example xml:id="ex.graph_06">
      <title><function>boost::adjacent_vertices</function> and <function>boost::out_edges</function></title>
      <programlisting><xi:include href="../src/graph_06/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.graph_06" xrefstyle="enp"/> introduces functions to gain additional information on points. <function>boost::adjacent_vertices</function><indexterm><primary>adjacent_vertices, Boost.Graph</primary></indexterm> returns a pair of iterators that refer to points a point connects to. You call <function>boost::out_edges</function><indexterm><primary>out_edges, Boost.Graph</primary></indexterm> if you want to access all outgoing lines from a point. <function>boost::in_edges</function><indexterm><primary>in_edges, Boost.Graph</primary></indexterm> accesses all ingoing lines. With undirected lines, it doesn’t matter which of the two functions is called.</para>
    <para><function>boost::target</function><indexterm><primary>target, Boost.Graph</primary></indexterm> returns the end point of a line. The start point is returned with <function>boost::source</function><indexterm><primary>source, Boost.Graph</primary></indexterm>.</para>
    <para><xref linkend="ex.graph_06" xrefstyle="enp"/> writes 1 and 3, the indexes of the top right and bottom left fields, to standard output twice. <function>boost::adjacent_vertices</function>, is called with <varname>topLeft</varname> and returns and displays the indexes of the top right and bottom left fields. <varname>topLeft</varname> is also passed to <function>boost::out_edges</function> to retrieve the outgoing lines. Because <function>boost::target</function> is called on every outgoing line with <function>std::for_each</function>, the indexes of the top right and bottom left fields are displayed twice.</para>
    <para><xref linkend="ex.graph_07" xrefstyle="enp"/> illustrates how to define a graph with <classname>boost::adjacency_list</classname> without having to call <function>boost::add_edge</function> for every line.</para>
    <example xml:id="ex.graph_07">
      <title>Initializing <classname>boost::adjacency_list</classname> with lines</title>
      <programlisting><xi:include href="../src/graph_07/main.cpp" parse="text"/></programlisting>
    </example>
    <para>You can pass iterators to the constructor of <classname>boost::adjacency_list</classname> that refer to objects of type <type>std::pair&lt;int, int&gt;</type>, which define lines. If you pass iterators, you also have to supply a third parameter that determines the total number of points in the graph. The graph will contain at least the points required for the lines. The third parameter let’s you add points to the graph that aren’t connected to other points.</para>
    <para><xref linkend="ex.graph_07" xrefstyle="enp"/> uses the functions <function>boost::num_vertices</function><indexterm><primary>num_vertices, Boost.Graph</primary></indexterm> and <function>boost::num_edges</function><indexterm><primary>num_edges, Boost.Graph</primary></indexterm>, which return the number of points and lines, respectively. The example displays <computeroutput>4</computeroutput> twice.</para>
    <para><xref linkend="ex.graph_07" xrefstyle="enp"/> calls <methodname>boost::adjacency_list::clear</methodname><indexterm><primary>adjacency_list::clear</primary></indexterm><indexterm><primary>clear, adjacency_list</primary></indexterm>. This member function removes all points and lines. It is a member function of <classname>boost::adjacency_list</classname> and not a free-standing function.</para>
  </sect1>
  <sect1 xml:id="boost.graph-algorithms">
    <title>Algorithms</title>
    <para>Algorithms from Boost.Graph resemble those from the standard library &#x2013; they are generic and very flexible. However, it’s not always immediately clear how they should be used.</para>
    <example xml:id="ex.graph_08">
      <title>Visiting points from inside to outside with <function>breadth_first_search</function></title>
      <programlisting><xi:include href="../src/graph_08/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.graph_08" xrefstyle="enp"/> uses the algorithm <function>boost::breadth_first_search</function><indexterm><primary>breadth_first_search, Boost.Graph</primary></indexterm> to visit points from inside to outside. The algorithm starts at the point passed as the second parameter. It first visits all points that can be reached directly from that point, working like a wave.</para>
    <para><function>boost::breadth_first_search</function> doesn’t return a specific result. The algorithm just visits points. Whether data is collected and stored depends on the <emphasis role="concept">visitors</emphasis><indexterm><primary>visitor, Boost.Graph</primary></indexterm> passed to <function>boost::breadth_first_search</function>.</para>
    <para>Visitors are objects whose member functions are called when a point is visited. By passing visitors to an algorithm like <function>boost::breadth_first_search</function>, you decide what should happen when a point is visited. Visitors are like function objects that can be passed to algorithms of the standard library.</para>
    <para><xref linkend="ex.graph_08" xrefstyle="enp"/> uses a visitor that records distances. A distance is the number of lines that have to be crossed to get from one point to another, starting at the point passed to <function>boost::breadth_first_search</function> as the second parameter. Boost.Graph provides the helper function <function>boost::record_distances</function><indexterm><primary>record_distances, Boost.Graph</primary></indexterm> to create the visitor. A <emphasis role="concept">property map</emphasis><indexterm><primary>property map, Boost.Graph</primary></indexterm> and a <emphasis role="concept">tag</emphasis><indexterm><primary>tag, Boost.Graph</primary></indexterm> also have to be passed.</para>
    <para>Property maps store properties for points or lines. Boost.Graph describes the concept of property maps. Since a pointer or iterator is taken as the beginning of a property map, it isn’t important to understand property maps in detail. In <xref linkend="ex.graph_08" xrefstyle="enp"/> the beginning of the array <varname>distances</varname> is passed with <code>distances.begin()</code> to <function>boost::record_distances</function>. This is sufficient for the array <varname>distances</varname> to be used as a property map. However, it is important that the size of the array isn’t smaller than the number of points in the graph. After all, the distance to each and every point in the graph needs to be stored.</para>
    <para>Please note that <varname>distances</varname> is based on <classname>boost::array</classname> and not on <classname>std::array</classname>. Using <classname>std::array</classname> would lead to a compiler error.</para>
    <para>Depending on the algorithm, there are different events. The second parameter passed to <function>boost::record_distances</function> specifies which events the visitor should be notified about. Boost.Graph defines tags that are empty classes to give events names. The tag <classname>boost::on_tree_edge</classname><indexterm><primary>on_tree_edge, Boost.Graph</primary></indexterm> in <xref linkend="ex.graph_08" xrefstyle="enp"/> specifies that a distance should be recorded when a new point has been found.</para>
    <para>Events depend on the algorithm. You have to check the documentation on algorithms to find out which events are supported and which tags you can use.</para>
    <para>A visitor created by <function>boost::record_distances</function> is algorithm independent, so you can use <function>boost::record_distances</function> with other algorithms. An adapter is used to bind an algorithm and a visitor. <xref linkend="ex.graph_08" xrefstyle="enp"/> calls <function>boost::make_bfs_visitor</function><indexterm><primary>make_bfs_visitor, Boost.Graph</primary></indexterm> to create this adapter. This helper function returns a visitor as expected by the algorithm <function>boost::breadth_first_search</function>. This visitor defines member functions that fit the events the algorithm supports. For example, the visitor returned by <function>boost::make_bfs_visitor</function> defines the member function <methodname>tree_edge</methodname>. If a visitor that is defined with the tag <classname>boost::on_tree_edge</classname> is passed to <function>boost::make_bfs_visitor</function> (as in <xref linkend="ex.graph_08" xrefstyle="enp"/>), the visitor is notified when <methodname>tree_edge</methodname> is called. This lets you use visitors with different algorithms without those visitors having to define all of the member functions expected by all algorithms.</para>
    <para>The adapter returned by <function>boost::make_bfs_visitor</function> can’t be passed directly to the algorithm <function>boost::breadth_first_search</function>. It has to be wrapped with <function>boost::visitor</function><indexterm><primary>visitor, Boost.Graph</primary></indexterm> and then passed as a third parameter.</para>
    <para>There are two variants of algorithms like <function>boost::breadth_first_search</function>. One variant expects that every parameter the algorithm supports will be passed. Another variant supports something similar to named parameters. It’s typically easier to use this second variant because only the parameters you’re interested in have to be passed. Many parameters don’t have to be passed because algorithms use default values.</para>
    <para><xref linkend="ex.graph_08" xrefstyle="enp"/> uses the variant of <function>boost::breadth_first_search</function> that expects named parameters. The first two parameters are the graph and the start point, which are required. However, the third parameter can be nearly everything. In <xref linkend="ex.graph_08" xrefstyle="enp" /> a visitor needs to be passed. For that to work, the adapter returned by <function>boost::make_bfs_visitor</function> is named using <function>boost::visitor</function>. Now, it’s clear that the third parameter is a visitor. You’ll see in the following examples how other parameters are passed by name to <function>boost::breadth_first_search</function>.</para>
    <para><xref linkend="ex.graph_08" xrefstyle="enp"/> displays the numbers 0, 1, 2, and 1. These are the distances to all points from the top left. The top right field &#x2013; the one with the index 1 &#x2013; is only one step away. The bottom right field &#x2013; the one with the index 2 &#x2013; is two steps away. The bottom left field &#x2013; the one with the index 3 &#x2013; is again only one step away. The number 0 which is printed first refers to the top left field. Since it’s the start point that was passed to <function>boost::breadth_first_search</function>, zero steps are required to reach it.</para>
    <para><function>boost::breadth_first_search</function> doesn’t set the elements in the array, it just increases the stored values. Therefore, you must initialize all elements in the array <varname>distances</varname> before you start.</para>
    <para><xref linkend="ex.graph_09" xrefstyle="enp"/> illustrates how to find the shortest path.</para>
    <example xml:id="ex.graph_09">
      <title>Finding paths with <function>breadth_first_search</function></title>
      <programlisting><xi:include href="../src/graph_09/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.graph_09" xrefstyle="enp"/> displays 0, 1, and 2. This is the shortest path from top left to bottom right. It leads over the top right field although the path over the bottom left field would be equally short.</para>
    <para><function>boost::breadth_first_search</function> is used again &#x2013; this time to find the shortest path. As you already know, this algorithm just visits points. To get a description of the shortest path, an appropriate visitor must be used. <xref linkend="ex.graph_09" xrefstyle="enp"/> calls <function>boost::record_predecessors</function><indexterm><primary>record_predecessors, Boost.Graph</primary></indexterm> to get one.</para>
    <para><function>boost::record_predecessors</function> returns a visitor to store the predecessor of every point. Whenever <function>boost::breadth_first_search</function> visits a new point, the previous point is stored in the property map passed to <function>boost::record_predecessors</function>. As <function>boost::breadth_first_search</function> visits points from the inside to the outside, the shortest path is found &#x2013; starting at the point passed as a second parameter to <function>boost::breadth_first_search</function>. <xref linkend="ex.graph_09" xrefstyle="enp"/> finds the shortest paths from all points in the graph to the bottom right.</para>
    <para>After <function>boost::breadth_first_search</function> returns, the property map <varname>predecessors</varname> contains the predecessor of every point. To find the first field when travelling from the top left to the bottom right, the element with the index 0 &#x2013; the index of the top left field &#x2013; is accessed in <varname>predecessors</varname>. The value found in <varname>predecessors</varname> is 1, which means the next field is at the top right. Accessing <varname>predecessors</varname> with the index 1 returns the next field. In <xref linkend="ex.graph_09" xrefstyle="enp"/> that’s the bottom right field &#x2013; the one with the index 2. That way it’s possible to find the points iteratively in huge graphs to get from a start to an end point.</para>
    <example xml:id="ex.graph_10">
      <title>Finding distances and paths with <function>breadth_first_search</function></title>
      <programlisting><xi:include href="../src/graph_10/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.graph_10" xrefstyle="enp"/> shows how <function>boost::breadth_first_search</function> is used with two visitors. To use two visitors, you need to put them in a pair with <function>std::make_pair</function>. If more than two visitors are needed, the pairs have to be nested. <xref linkend="ex.graph_10" xrefstyle="enp"/> does the same thing as <xref linkend="ex.graph_08" xrefstyle="ewp"/> and <xref linkend="ex.graph_09" xrefstyle="ewp"/> together.</para>
    <para><function>boost::breadth_first_search</function> can only be used if every line has the same weight. This means the time taken to cross any line between points is always the same. If lines are weighted, meaning that each line may require a different amount of time to traverse, then you need to use a different algorithm to find the shortest path.</para>
    <example xml:id="ex.graph_11">
      <title>Finding paths with <function>dijkstra_shortest_paths</function></title>
      <programlisting><xi:include href="../src/graph_11/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.graph_11" xrefstyle="enp"/> uses <function>boost::dijkstra_shortest_paths</function><indexterm><primary>dijkstra_shortest_paths, Boost.Graph</primary></indexterm> to find the shortest paths to the bottom right. This algorithm is used if lines are weighted. <xref linkend="ex.graph_11" xrefstyle="enp"/> assumes that it takes twice as long to cross the line from the top left to the top right as it takes to cross any other line.</para>
    <para>Before <function>boost::dijkstra_shortest_paths</function> can be used, weights have to be assigned to lines. This is done with the array <varname>weights</varname>. The elements in the array correspond to the lines in the graph. Because the line from the top left to the top right is first, the first element in <varname>weights</varname> is set to a value twice as big as all others.</para>
    <para>To assign weights to lines, the iterator to the beginning of the array <varname>weights</varname> is passed as the third parameter to the constructor of the graph. This third parameter can be used to initialize properties of lines. This only works if properties have been defined for lines.</para>
    <para><xref linkend="ex.graph_11" xrefstyle="enp"/> passes additional template parameters to <classname>boost::adjacency_list</classname>. The fourth and fifth template parameter specify if points and lines have properties and what those properties are. You can assign properties to both lines and points.</para>
    <para>By default, <classname>boost::adjacency_list</classname> uses <classname>boost::no_property</classname><indexterm><primary>no_property, Boost.Graph</primary></indexterm>, which means that neither points nor lines have properties. In <xref linkend="ex.graph_11" xrefstyle="enp"/>, <classname>boost::no_property</classname> is passed as a fourth parameter to specify no properties for points. The fifth parameter uses <classname>boost::property</classname><indexterm><primary>property, Boost.Graph</primary></indexterm> to define a <emphasis role="concept">bundled property</emphasis><indexterm><primary>bundled property, Boost.Graph</primary></indexterm>.</para>
    <para>Bundled properties are properties that are stored internally in a graph. Because it’s possible to define multiple bundled properties, <classname>boost::property</classname> expects a tag to define each property. Boost.Graph provides some tags, such as <classname>boost::edge_weight_t</classname><indexterm><primary>edge_weight_t, Boost.Graph</primary></indexterm>, to define frequently used properties that are automatically recognized and used by algorithms. The second template parameter passed to <classname>boost::property</classname> is the type of the property. In <xref linkend="ex.graph_11" xrefstyle="enp"/> weights are <type>int</type> values.</para>
    <para><xref linkend="ex.graph_11" xrefstyle="enp"/> works because <function>boost::dijkstra_shortest_paths</function> automatically uses the bundled property of type <classname>boost::edge_weight_t</classname>.</para>
    <para>Note that no visitor is passed to <function>boost::dijkstra_shortest_paths</function>. This algorithm doesn’t just visit points. It looks for shortest paths &#x2013; that’s why it’s called <function>boost::dijkstra_shortest_paths</function>. You don’t need to think about events or visitors. You only need to pass a container to store the predecessor of every point. If you use the variant of <function>boost::dijkstra_shortest_paths</function> that expects named parameters, as in <xref linkend="ex.graph_11" xrefstyle="enp"/>, pass the container with <function>boost::predecessor_map</function><indexterm><primary>predecessor_map, Boost.Graph</primary></indexterm>. This is a helper function which expects a pointer or an iterator to the beginning of an array.</para>
    <para><xref linkend="ex.graph_11" xrefstyle="enp"/> displays 0, 3, and 2: The shortest path from top left to bottom right leads over the bottom left field. The path over the top right field has a greater weight than the other possibilities.</para>
    <example xml:id="ex.graph_12">
      <title>User-defined properties with <function>dijkstra_shortest_paths</function></title>
      <programlisting><xi:include href="../src/graph_12/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.graph_12" xrefstyle="enp"/> works like the previous one and displays the same numbers, but it uses a user-defined class, <classname>edge_properties</classname>, rather than a predefined property.</para>
    <para><classname>edge_properties</classname> defines the member variable <varname>weight</varname> to store the weight of a line. It is possible to add more member variables if other properties are required.</para>
    <para>You can access user-defined properties if you use the descriptor of lines as an index for the graph. Thus, the graph behaves like an array. You get the descriptors from the line iterators that are returned from <function>boost::edges</function>. That way a weight can be assigned to every line.</para>
    <para>To make <function>boost::dijkstra_shortest_paths</function> understand that weights are stored in <varname>weight</varname> in <classname>edge_properties</classname>, another named parameter has to be passed. This is done with <methodname>weight_map</methodname>. Note that <methodname>weight_map</methodname> is a member function of the object returned from <function>boost::predecessor_map</function>. There is also a free-standing function called <function>boost::weight_map</function><indexterm><primary>weight_map, Boost.Graph</primary></indexterm>. If you need to pass multiple named parameters, you have to call a member function on the first named parameter (the one that was returned by the free-standing function). That way all parameters are packed into one object that is then passed to the algorithm.</para>
    <para>To tell <function>boost::dijkstra_shortest_paths</function> that <varname>weight</varname> in <classname>edge_properties</classname> contains the weights, a pointer to that property is passed. It isn’t passed to <methodname>weight_map</methodname> directly. Instead it is passed in an object created with <function>boost::get</function><indexterm><primary>get, Boost.Graph</primary></indexterm>. Now the call is complete, and <function>boost::dijkstra_shortest_paths</function> knows which property to access to get the weights.</para>
    <example xml:id="ex.graph_13">
      <title>Initializing user-defined properties at graph definition</title>
      <programlisting><xi:include href="../src/graph_13/main.cpp" parse="text"/></programlisting>
    </example>
    <para>It’s possible to initialize user-defined properties when a graph is defined. You only have to pass an iterator as the third parameter to the constructor of <classname>boost::adjacency_list</classname>, which refers to objects of the type of the user-defined property. Thus, you don’t need to access properties of lines through descriptors. <xref linkend="ex.graph_13" xrefstyle="enp"/> works like the previous one and displays the same result.</para>
    <example xml:id="ex.graph_14">
      <title>Random paths with <function>random_spanning_tree</function></title>
      <programlisting><xi:include href="../src/graph_14/main.cpp" parse="text"/></programlisting>
    </example>
    <para>The algorithm introduced in <xref linkend="ex.graph_14" xrefstyle="enp"/> finds random paths. <function>boost::random_spanning_tree</function><indexterm><primary>random_spanning_tree, Boost.Graph</primary></indexterm> is similar to <function>boost::dijkstra_shortest_paths</function>. It returns the predecessors of points in a container that is passed with <classname>boost::predecessor_map</classname>. In contrast to <function>boost::dijkstra_shortest_paths</function>, the starting point isn’t passed directly as a parameter to <function>boost::random_spanning_tree</function>. It must be passed as a named parameter. That’s why <methodname>root_vertex</methodname> is called on the object of type <classname>boost::predecessor_map</classname>. <xref linkend="ex.graph_14" xrefstyle="enp"/> finds random paths to the bottom left field.</para>
    <para>Because <function>boost::random_spanning_tree</function> is looking for a random path, a random number generator has to be passed as the second parameter. <xref linkend="ex.graph_14" xrefstyle="enp"/> uses <classname>std::mt19937</classname>, which has been part of the standard library since C++11. You could also use a random number generator from Boost.Random.</para>
    <para><xref linkend="ex.graph_14" xrefstyle="enp"/> displays either 1, 0, and 3 or 1, 2, and 3. 1 is the top right field, 3 the bottom left field. There are only two possible paths from the top right field to the bottom left field: through the top left field or through the bottom right field. <function>boost::random_spanning_tree</function> must return one of these two paths.</para>
    <simplesect role="exercises" xml:id="boost.graph-algorithms-exercises">
      <title>Exercises</title>
      <orderedlist>
        <listitem><para>Create a graph with vertices for the following countries: Netherlands, Belgium, France, Germany, Switzerland, Austria and Italy. Connect the vertices of those countries with common borders. Find the shortest path &#x2013; the path with fewest border crossings &#x2013; to get from Italy to the Netherlands. Write the names of all countries to standard output which you cross on your way from Italy to the Netherlands.</para></listitem>
        <listitem><para>Extend your program: Entering France now costs 10 Euro, entering Belgium 15 Euro and entering Germany 20 Euro. Crossing all other borders remains free. Find the shortest path &#x2013; the path with fewest border crossings &#x2013; which is also the cheapest path to get from Italy to the Netherlands. Write the names of all countries to standard output which you cross on your way from Italy to the Netherlands.</para></listitem>
      </orderedlist>
    </simplesect>
  </sect1>
  <sect1 xml:id="boost.graph-containers">
    <title>Containers</title>
    <para>All examples in this chapter so far have used <classname>boost::adjacency_list</classname> to define graphs. This section introduces the two other graph containers provided by Boost.Graph: <classname>boost::adjacency_matrix</classname> and <classname>boost::compressed_sparse_row_graph</classname>.</para>
    <note>
      <para>There is a missing include in <filename class="headerfile">boost/graph/adjacency_matrix.hpp</filename> in Boost 1.56.0. To compile <xref linkend="ex.graph_15" xrefstyle="enp"/> with Boost 1.56.0, include <filename class="headerfile">boost/functional/hash.hpp</filename> before <filename class="headerfile">boost/graph/adjacency_matrix.hpp</filename>.</para>
    </note>
    <example xml:id="ex.graph_15">
      <title>Graphs with <classname>boost::adjacency_matrix</classname></title>
      <programlisting><xi:include href="../src/graph_15/main.cpp" parse="text"/></programlisting>
    </example>
    <para><classname>boost::adjacency_matrix</classname><indexterm><primary>adjacency_matrix, Boost.Graph</primary></indexterm> is used like <classname>boost::adjacency_list</classname> (see <xref linkend="ex.graph_15" xrefstyle="enp"/>). However, the two template parameters that pass selectors don’t exist with <classname>boost::adjacency_matrix</classname>. With <classname>boost::adjacency_matrix</classname>, no selectors, such as <classname>boost::vecS</classname> and <classname>boost::setS</classname>, are used. <classname>boost::adjacency_matrix</classname> stores the graph in a matrix, and the internal structure is hardcoded. You can think of the matrix as a two-dimensional table: the table is a square with as many rows and columns as the graph has points. A line is created by marking the cell where the row and column that correspond with the two end points of the line intersect.</para>
    <para>The internal structure of <classname>boost::adjacency_matrix</classname> makes it possible to add and remove lines quickly. However, memory consumption is higher. The rule of thumb is to use <classname>boost::adjacency_list</classname> when there are relatively few lines compared to points. The more lines there are, the more it makes sense to use <classname>boost::adjacency_matrix</classname>.</para>
    <example xml:id="ex.graph_16">
      <title>Graphs with <classname>boost::compressed_sparse_row_graph</classname></title>
      <programlisting><xi:include href="../src/graph_16/main.cpp" parse="text"/></programlisting>
    </example>
    <para><classname>boost::compressed_sparse_row_graph</classname><indexterm><primary>compressed_sparse_row_graph, Boost.Graph</primary></indexterm> is used in the same way as <classname>boost::adjacency_list</classname> and <classname>boost::adjacency_matrix</classname> (see <xref linkend="ex.graph_16" xrefstyle="enp"/>). The most important difference is that graphs can’t be changed with <classname>boost::compressed_sparse_row_graph</classname>. Once the graph has been created, points and lines can’t be added or removed. Thus, <classname>boost::compressed_sparse_row_graph</classname> makes only sense when using an immutable graph.</para>
    <para><classname>boost::compressed_sparse_row_graph</classname> only supports directed lines. You can’t instantiate <classname>boost::compressed_sparse_row_graph</classname> with the template parameter <classname>boost::undirectedS</classname>.</para>
    <para>The main advantage of <classname>boost::compressed_sparse_row_graph</classname> is low memory consumption. <classname>boost::compressed_sparse_row_graph</classname> is especially useful if you have a huge graph and you need to keep memory consumption low.</para>
  </sect1>
</chapter>
