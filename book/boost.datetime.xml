<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.datetime">
  <title>Boost.DateTime</title><indexterm><primary>Boost.DateTime</primary></indexterm>
  <para>The library <link xlink:href="http://www.boost.org/libs/date_time">Boost.DateTime</link> can be used to process time data such as calendar dates and times. In addition, Boost.DateTime provides extensions to account for time zones and supports formatted input and output of calendar dates and times. If you are looking for functions to get the current time or measure time, see Boost.Chrono in <xref linkend="boost.chrono"/>.</para>
  <sect1 xml:id="boost.datetime-calendar">
    <title>Calendar Dates</title>
    <para>Boost.DateTime only supports calendar dates based on the <emphasis role="concept">Gregorian calendar</emphasis><indexterm><primary>Gregorian calendar</primary></indexterm>, which in general is not a problem since this is the most widely used calendar. If you arrange a meeting with someone for May 12, 2014, you donâ€™t need to say that the date is based on the Gregorian calendar.</para>
    <para>The Gregorian calendar was introduced by Pope Gregory XIII in 1582. Boost.DateTime supports calendar dates for the years 1400 to 9999, which means that support goes back before the year 1582. Thus, you can use Boost.DateTime for any calendar date after the year 1400 as long as that date is converted to the Gregorian calendar. To process earlier dates, Boost.DateTime has to be extended by a new calendar.</para>
    <para>The header file <filename class="headerfile">boost/date_time/gregorian/gregorian.hpp</filename> contains definitions for all classes and functions that process calendar dates. These functions and classes can be found in the namespace <package>boost::gregorian</package>. To create a date, use the class <classname>boost::gregorian::date</classname><indexterm><primary>gregorian::date</primary></indexterm><indexterm><primary>date, gregorian</primary></indexterm>.</para>
    <example xml:id="ex.datetime_01">
      <title>Creating a date with <classname>boost::gregorian::date</classname></title>
      <programlisting><xi:include href="../src/datetime_01/main.cpp" parse="text"/></programlisting>
    </example>
    <para><classname>boost::gregorian::date</classname> provides several constructors to create dates. The most basic constructor takes a year, a month, and a day as parameters. If an invalid value is given, an exception will be thrown of type <exceptionname>boost::gregorian::bad_day_of_month</exceptionname><indexterm><primary>gregorian::bad_day_of_month</primary></indexterm><indexterm><primary>bad_day_of_month, gregorian</primary></indexterm>, <exceptionname>boost::gregorian::bad_year</exceptionname><indexterm><primary>gregorian::bad_year</primary></indexterm><indexterm><primary>bad_year, gregorian</primary></indexterm>, or <exceptionname>boost::gregorian::bad_month</exceptionname><indexterm><primary>gregorian::bad_month</primary></indexterm><indexterm><primary>bad_month, gregorian</primary></indexterm>. All of these classes are derived from <exceptionname>std::out_of_range</exceptionname>.</para>
    <para>As shown in <xref linkend="ex.datetime_01" xrefstyle="enp"/>, there are many member functions available. Some member functions, such as <methodname>year</methodname><indexterm><primary>gregorian::date::year</primary></indexterm><indexterm><primary>year, gregorian::date</primary></indexterm>, <methodname>month</methodname><indexterm><primary>gregorian::date::month</primary></indexterm><indexterm><primary>month, gregorian::date</primary></indexterm>, and <methodname>day</methodname><indexterm><primary>gregorian::date::day</primary></indexterm><indexterm><primary>day, gregorian::date</primary></indexterm>, return the respective parts of a date, and others, such as <methodname>day_of_week</methodname><indexterm><primary>gregorian::date::day_of_week</primary></indexterm><indexterm><primary>day_of_week, gregorian::date</primary></indexterm> and <methodname>end_of_month</methodname><indexterm><primary>gregorian::date::end_of_month</primary></indexterm><indexterm><primary>end_of_month, gregorian::date</primary></indexterm>, calculate values.</para>
    <para>The constructor of <classname>boost::gregorian::date</classname> expects numeric values for year, month, and day to set a date. However, the output of the sample program is <computeroutput>Jan</computeroutput> for the month and <computeroutput>Fri</computeroutput> for the day of the week. The return values of <methodname>month</methodname> and <methodname>day_of_week</methodname> are not regular numeric values, but values of type <type>boost::gregorian::date::month_type</type><indexterm><primary>gregorian::date::month_type</primary></indexterm><indexterm><primary>month_type, gregorian::date</primary></indexterm> and <type>boost::gregorian::date::day_of_week_type</type><indexterm><primary>gregorian::date::day_of_week_type</primary></indexterm><indexterm><primary>day_of_week_type, gregorian::date</primary></indexterm>. Boost.DateTime provides comprehensive support for formatted input and output, so it is possible to adjust the output from, for example, <computeroutput>Jan</computeroutput> to <computeroutput>1</computeroutput>.</para>
    <para>The default constructor of <classname>boost::gregorian::date</classname> creates an invalid date. An invalid date can also be created explicitly by passing <code>boost::date_time::not_a_date_time</code><indexterm><primary>date_time::not_a_date_time</primary></indexterm><indexterm><primary>not_a_date_time, date_time</primary></indexterm> as the sole parameter to the constructor.</para>
    <para>Besides calling a constructor directly, an object of type <classname>boost::gregorian::date</classname> can be created via free-standing functions and member functions of other classes.</para>
    <example xml:id="ex.datetime_02">
      <title>Getting a date from a clock or a string</title>
      <programlisting><xi:include href="../src/datetime_02/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.datetime_02" xrefstyle="enp"/> uses the class <classname>boost::gregorian::day_clock</classname><indexterm><primary>gregorian::day_clock</primary></indexterm><indexterm><primary>day_clock, gregorian</primary></indexterm>, which returns the current date. The member function <methodname>universal_day</methodname><indexterm><primary>gregorian::day_clock::universal_day</primary></indexterm><indexterm><primary>universal_day, gregorian::day_clock</primary></indexterm> returns a <acronym>UTC</acronym> date, which is independent of time zones and daylight savings. <acronym>UTC</acronym> is the international abbreviation for the universal time. <classname>boost::gregorian::day_clock</classname> also provides a member function called <methodname>local_day</methodname><indexterm><primary>gregorian::day_clock::local_day</primary></indexterm><indexterm><primary>local_day, gregorian::day_clock</primary></indexterm>, which takes local settings into account. To retrieve the current date within the local time zone, use <methodname>local_day</methodname>.</para>
    <para>The namespace <package>boost::gregorian</package> contains free-standing functions to convert a date stored as a string into an object of type <classname>boost::gregorian::date</classname>. <xref linkend="ex.datetime_02" xrefstyle="enp"/> converts a date in the ISO 8601 format using the function <function>boost::gregorian::date_from_iso_string</function><indexterm><primary>gregorian::date_from_iso_string</primary></indexterm><indexterm><primary>date_from_iso_string, gregorian</primary></indexterm>. Other functions include: <function>boost::gregorian::from_simple_string</function><indexterm><primary>gregorian::from_simple_string</primary></indexterm><indexterm><primary>from_simple_string, gregorian</primary></indexterm> and <function>boost::gregorian::from_us_string</function><indexterm><primary>gregorian::from_us_string</primary></indexterm><indexterm><primary>from_us_string, gregorian</primary></indexterm>.</para>
    <para>While <classname>boost::gregorian::date</classname> marks a specific time, <classname>boost::gregorian::date_duration</classname><indexterm><primary>gregorian::date_duration</primary></indexterm><indexterm><primary>date_duration, gregorian</primary></indexterm> denotes a duration.</para>
    <example xml:id="ex.datetime_03">
      <title>Using <classname>boost::gregorian::date_duration</classname></title>
      <programlisting><xi:include href="../src/datetime_03/main.cpp" parse="text"/></programlisting>
    </example>
    <para>Because <classname>boost::gregorian::date</classname> overloads <methodname role="operator">operator-</methodname>, two points in time can be subtracted (see <xref linkend="ex.datetime_03" xrefstyle="enp"/>). The return value is of type <classname>boost::gregorian::date_duration</classname> and marks the duration between the two dates.</para>
    <para>The most important member function offered by <classname>boost::gregorian::date_duration</classname> is <methodname>days</methodname><indexterm><primary>gregorian::date_duration::days</primary></indexterm><indexterm><primary>days, gregorian::date_duration</primary></indexterm>, which returns the number of days in the duration specified.</para>
    <example xml:id="ex.datetime_04">
      <title>Specialized durations</title>
      <programlisting><xi:include href="../src/datetime_04/main.cpp" parse="text"/></programlisting>
    </example>
    <para>Objects of type <classname>boost::gregorian::date_duration</classname> can also be created by passing the number of days as a single parameter to the constructor. To create a duration that involves weeks, months, or years, use <classname>boost::gregorian::weeks</classname><indexterm><primary>gregorian::weeks</primary></indexterm><indexterm><primary>weeks, gregorian</primary></indexterm>, <classname>boost::gregorian::months</classname><indexterm><primary>gregorian::months</primary></indexterm><indexterm><primary>months, gregorian</primary></indexterm>, or <classname>boost::gregorian::years</classname><indexterm><primary>gregorian::years</primary></indexterm><indexterm><primary>years, gregorian</primary></indexterm> (see <xref linkend="ex.datetime_04" xrefstyle="enp"/>).</para>
    <para>Neither <classname>boost::gregorian::months</classname> nor <classname>boost::gregorian::years</classname> will allow you to determine the number of days, because months and years vary in length. Nonetheless, using these classes can still make sense, as shown in <xref linkend="ex.datetime_05" xrefstyle="enp" />.</para>
    <example xml:id="ex.datetime_05">
      <title>Processing specialized durations</title>
      <programlisting><xi:include href="../src/datetime_05/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.datetime_05" xrefstyle="enp"/> adds one month to the given date of January 31, 2014, which results in <varname>d2</varname> being February 28, 2014. In the next step, one month is subtracted and <varname>d3</varname> becomes January 31, 2014, again. As shown, points in time as well as durations can be used in calculations. However, some specifics need to be taken into account. For example, starting at the last day of a month, <classname>boost::gregorian::months</classname> always arrives at the last day of another month, which can lead to surprises.</para>
    <example xml:id="ex.datetime_06">
      <title>Surprises when processing specialized durations</title>
      <programlisting><xi:include href="../src/datetime_06/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.datetime_06" xrefstyle="enp"/> is identical to the previous one, except <varname>d</varname> is initialized to be January 30, 2014. Even though this is not the last day in January, jumping forward by one month results in <varname>d2</varname> becoming February 28, 2014, because there is no February 30. However, jumping backwards by one month again results in <varname>d3</varname> becoming January 31, 2014. Since February 28, 2014, is the last day in February, jumping backwards returns to the last day in January.</para>
    <para>To change this behavior, undefine the macro <code>BOOST_DATE_TIME_OPTIONAL_GREGORIAN_TYPES</code><indexterm><primary>BOOST_DATE_TIME_OPTIONAL_GREGORIAN_TYPES, Boost.DateTime</primary></indexterm>. After this macro is undefined, the classes <classname>boost::gregorian::weeks</classname>, <classname>boost::gregorian::months</classname>, and <classname>boost::gregorian::years</classname> will no longer be available. The only class still available will be <classname>boost::gregorian::date_duration</classname>, which simply jumps forwards and backwards by a specified number of days and does not give special consideration to the first and last day of the month.</para>
    <example xml:id="ex.datetime_07">
      <title>Using <classname>boost::gregorian::date_period</classname></title>
      <programlisting><xi:include href="../src/datetime_07/main.cpp" parse="text"/></programlisting>
    </example>
    <para>While <classname>boost::gregorian::date_duration</classname> only works with durations, <classname>boost::gregorian::date_period</classname><indexterm><primary>gregorian::date_period</primary></indexterm><indexterm><primary>date_period, gregorian</primary></indexterm> supports ranges between two dates.</para>
    <para>The constructor of <classname>boost::gregorian::date_period</classname> can accept two kinds of input. You can pass two parameters of type <classname>boost::gregorian::date</classname>, one for the beginning date and one for the end date. Or you can specify the beginning date and a duration of type <classname>boost::gregorian::date_duration</classname>. Please note that the day before the end date is actually the last day of the period. This is important in order to understand the output of <xref linkend="ex.datetime_08" xrefstyle="enp"/>.</para>
    <example xml:id="ex.datetime_08">
      <title>Testing whether a period contains dates</title>
      <programlisting><xi:include href="../src/datetime_08/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.datetime_08" xrefstyle="enp"/> checks whether a specific date is within a period by calling <methodname>contains</methodname><indexterm><primary>gregorian::date_period::contains</primary></indexterm><indexterm><primary>contains, gregorian::date_period</primary></indexterm>. Notice that although <varname>d2</varname> defines the end of the period, it is not considered part of the period. Therefore, the member function <methodname>contains</methodname> will return <literal>true</literal> when called with <varname>d1</varname> and <literal>false</literal> when called with <varname>d2</varname>.</para>
    <para><classname>boost::gregorian::date_period</classname> provides additional member functions for operations such as shifting a period or calculating the intersection of two overlapping periods.</para>
    <para>Boost.DateTime also provides iterators and other useful free-standing functions as shown in <xref linkend="ex.datetime_09" xrefstyle="enp"/>.</para>
    <example xml:id="ex.datetime_09">
      <title>Iterating over dates</title>
      <programlisting><xi:include href="../src/datetime_09/main.cpp" parse="text"/></programlisting>
    </example>
    <para>Use the iterator <classname>boost::gregorian::day_iterator</classname><indexterm><primary>gregorian::day_iterator</primary></indexterm><indexterm><primary>day_iterator, gregorian</primary></indexterm> to jump forward or backward by a day from a specific date. Use <classname>boost::gregorian::week_iterator</classname><indexterm><primary>gregorian::week_iterator</primary></indexterm><indexterm><primary>week_iterator, gregorian</primary></indexterm>, <classname>boost::gregorian::month_iterator</classname><indexterm><primary>gregorian::month_iterator</primary></indexterm><indexterm><primary>month_iterator, gregorian</primary></indexterm>, and <classname>boost::gregorian::year_iterator</classname><indexterm><primary>gregorian::year_iterator</primary></indexterm><indexterm><primary>year_iterator, gregorian</primary></indexterm> to jump by weeks, months, or years, respectively.</para>
    <para><xref linkend="ex.datetime_09" xrefstyle="enp"/> also uses the function <function>boost::date_time::next_weekday</function><indexterm><primary>date_time::next_weekday</primary></indexterm><indexterm><primary>next_weekday, date_time</primary></indexterm>, which returns the date of the next weekday based on a given date. <xref linkend="ex.datetime_09" xrefstyle="enp"/> displays <computeroutput>2014-May-16</computeroutput>, which is the first Friday following May 13, 2014.</para>
    <simplesect role="exercises" xml:id="boost.datetime-calendar-exercises">
      <title>Exercises</title>
      <orderedlist>
        <listitem><para>Create a program that outputs the weekdays for next December 24 and the following two public holidays.</para></listitem>
        <listitem><para>Calculate your age in days. Your programm should automatically use todayâ€™s date.</para></listitem>
      </orderedlist>
    </simplesect>
  </sect1>
  <sect1 xml:id="boost.datetime-location-independent-times">
    <title>Location-independent Times</title>
    <para>The class <classname>boost::posix_time::ptime</classname><indexterm><primary>posix_time::ptime</primary></indexterm><indexterm><primary>ptime, posix_time</primary></indexterm> defines a location-independent time. It uses the type <classname>boost::gregorian::date</classname>, but also stores a time. To use <classname>boost::posix_time::ptime</classname>, include the header file <filename class="headerfile">boost/date_time/posix_time/posix_time.hpp</filename>.</para>
    <example xml:id="ex.datetime_10">
      <title>Using <classname>boost::posix_time::ptime</classname></title>
      <programlisting><xi:include href="../src/datetime_10/main.cpp" parse="text"/></programlisting>
    </example>
    <para>To initialize an object of type <classname>boost::posix_time::ptime</classname>, pass a date of type <classname>boost::gregorian::date</classname> and a duration of type <classname>boost::posix_time::time_duration</classname> as the first and second parameters to the constructor. The constructor of <classname>boost::posix_time::time_duration</classname> takes three parameters, which determine the time. <xref linkend="ex.datetime_10" xrefstyle="enp"/> specifies 12 PM on May 12, 2014, as the point in time. To query date and time, use the member functions <methodname>date</methodname><indexterm><primary>posix_time::ptime::date</primary></indexterm><indexterm><primary>date, posix_time::ptime</primary></indexterm> and <methodname>time_of_day</methodname><indexterm><primary>posix_time::ptime::time_of_day</primary></indexterm><indexterm><primary>time_of_day, posix_time::ptime</primary></indexterm>.</para>
    <para>Just as the default constructor of <classname>boost::gregorian::date</classname> creates an invalid date, the default constructor of <classname>boost::posix_time::ptime</classname> creates an invalid time. An invalid time can also be created explicitly by passing <code>boost::date_time::not_a_date_time</code><indexterm><primary>date_time::not_a_date_time</primary></indexterm><indexterm><primary>not_a_date_time, date_time</primary></indexterm> to the constructor. Boost.DateTime provides free-standing functions and member functions to create times that are analogous to those used to create calendar dates of type <classname>boost::gregorian::date</classname>.</para>
    <example xml:id="ex.datetime_11">
      <title>Creating a timepoint with a clock or a string</title>
      <programlisting><xi:include href="../src/datetime_11/main.cpp" parse="text"/></programlisting>
    </example>
    <para>The class <classname>boost::posix_time::second_clock</classname><indexterm><primary>posix_time::second_clock</primary></indexterm><indexterm><primary>second_clock, posix_time</primary></indexterm> returns the current time. The member function <methodname>universal_time</methodname><indexterm><primary>posix_time::second_clock::universal_time</primary></indexterm><indexterm><primary>universal_time, posix_time::second_clock</primary></indexterm> returns the <acronym>UTC</acronym> time (see <xref linkend="ex.datetime_11" xrefstyle="enp"/>). <methodname>local_time</methodname><indexterm><primary>posix_time::second_clock::local_time</primary></indexterm><indexterm><primary>local_time, posix_time::second_clock</primary></indexterm> returns the local time. If you need a higher resolution, <classname>boost::posix_time::microsec_clock</classname><indexterm><primary>posix_time::microsec_clock</primary></indexterm><indexterm><primary>microsec_clock, posix_time</primary></indexterm> returns the current time including microseconds.</para>
    <para>The free-standing function <function>boost::posix_time::from_iso_string</function><indexterm><primary>posix_time::from_iso_string</primary></indexterm><indexterm><primary>from_iso_string, posix_time</primary></indexterm> converts a time stored in a string formatted using the ISO 8601 standard into an object of type <classname>boost::posix_time::ptime</classname>.</para>
    <example xml:id="ex.datetime_12">
      <title>Using <classname>boost::posix_time::time_duration</classname></title>
      <programlisting><xi:include href="../src/datetime_12/main.cpp" parse="text"/></programlisting>
    </example>
    <para>Boost.DateTime also provides the class <classname>boost::posix_time::time_duration</classname><indexterm><primary>posix_time::time_duration</primary></indexterm><indexterm><primary>time_duration, posix_time</primary></indexterm>, which specifies a duration. This class has been mentioned before because the constructor of <classname>boost::posix_time::ptime</classname> expects an object of type <classname>boost::posix_time::time_duration</classname> as its second parameter. You can also use <classname>boost::posix_time::time_duration</classname> independently.</para>
    <para><methodname>hours</methodname><indexterm><primary>posix_time::time_duration::hours</primary></indexterm><indexterm><primary>hours, posix_time::time_duration</primary></indexterm>, <methodname>minutes</methodname><indexterm><primary>posix_time::time_duration::minutes</primary></indexterm><indexterm><primary>minutes, posix_time::time_duration</primary></indexterm>, and <methodname>seconds</methodname><indexterm><primary>posix_time::time_duration::seconds</primary></indexterm><indexterm><primary>seconds, posix_time::time_duration</primary></indexterm> return the respective parts of a time duration, while member functions such as <methodname>total_seconds</methodname><indexterm><primary>posix_time::time_duration::total_seconds</primary></indexterm><indexterm><primary>total_seconds, posix_time::time_duration</primary></indexterm>, which returns the total number of seconds, provide additional information (see <xref linkend="ex.datetime_12" xrefstyle="enp"/>). There is no upper limit, such as 24 hours, to the values you can legally pass to <classname>boost::posix_time::time_duration</classname>.</para>
    <example xml:id="ex.datetime_13">
      <title>Processing timepoints</title>
      <programlisting><xi:include href="../src/datetime_13/main.cpp" parse="text"/></programlisting>
    </example>
    <para>As with calendar dates, calculations can be performed with points in time and durations. If two times of type <classname>boost::posix_time::ptime</classname> are subtracted from each other, as in <xref linkend="ex.datetime_13" xrefstyle="enp"/>, the result is an object of type <classname>boost::posix_time::time_duration</classname> that specifies the duration between the two times.</para>
    <example xml:id="ex.datetime_14">
      <title>Processing time durations</title>
      <programlisting><xi:include href="../src/datetime_14/main.cpp" parse="text"/></programlisting>
    </example>
    <para>As shown in <xref linkend="ex.datetime_14" xrefstyle="enp"/>, a duration can be added to a time, resulting in a new point in time. This example writes <computeroutput>18:30:00</computeroutput> to the standard output stream.</para>
    <para>Boost.DateTime uses the same concepts for calendar dates and times. Just as there are classes for times and durations, there is also one for periods. For calendar dates, this is <classname>boost::gregorian::date_period</classname>; for times it is <classname>boost::posix_time::time_period</classname><indexterm><primary>posix_time::time_period</primary></indexterm><indexterm><primary>time_period, posix_time</primary></indexterm>. The constructors of both classes expect two parameters: <classname>boost::gregorian::date_period</classname> expects two calendar dates as parameters and <classname>boost::posix_time::time_period</classname> expects two points in time.</para>
    <example xml:id="ex.datetime_15">
      <title>Using <classname>boost::posix_time::time_period</classname></title>
      <programlisting><xi:include href="../src/datetime_15/main.cpp" parse="text"/></programlisting>
    </example>
    <para>In general, <classname>boost::posix_time::time_period</classname> works just like <classname>boost::gregorian::date_period</classname>. It provides a member function, <methodname>contains</methodname><indexterm><primary>posix_time::time_period::contains</primary></indexterm><indexterm><primary>contains, posix_time::time_period</primary></indexterm>, which returns <literal>true</literal> for every point in time within the period. Because the end time, which is passed to the constructor of <classname>boost::posix_time::time_period</classname>, is not part of the period, the second call to <methodname>contains</methodname> in <xref linkend="ex.datetime_15" xrefstyle="enp"/> returns <literal>false</literal>.</para>
    <para><classname>boost::posix_time::time_period</classname> provides additional member functions such as <methodname>intersection</methodname><indexterm><primary>posix_time::time_period::intersection</primary></indexterm><indexterm><primary>intersection, posix_time::time_period</primary></indexterm> and <methodname>merge</methodname><indexterm><primary>posix_time::time_period::merge</primary></indexterm><indexterm><primary>merge, posix_time::time_period</primary></indexterm>, which respectively, calculate the intersection of two overlapping periods and merge two intersecting periods.</para>
    <para>Finally, the iterator <classname>boost::posix_time::time_iterator</classname><indexterm><primary>posix_time::time_iterator</primary></indexterm><indexterm><primary>time_iterator, posix_time</primary></indexterm> iterates over points in time.</para>
    <example xml:id="ex.datetime_16">
      <title>Iterating over points in time</title>
      <programlisting><xi:include href="../src/datetime_16/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.datetime_16" xrefstyle="enp"/> uses the iterator <varname>it</varname> to jump forward 6.5 hours from the time <varname>pt</varname>. Because the iterator is incremented twice, the output is <computeroutput>2014-May-12 18:30:00</computeroutput> and <computeroutput>2014-May-13 01:00:00</computeroutput>.</para>
  </sect1>
  <sect1 xml:id="boost.datetime-location-dependent-times">
    <title>Location-dependent Times</title>
    <para>Unlike the location-independent times introduced in the previous section, location-dependent times account for time zones. Boost.DateTime provides the class <classname>boost::local_time::local_date_time</classname><indexterm><primary>local_time::local_date_time</primary></indexterm><indexterm><primary>local_date_time, local_time</primary></indexterm>, which is defined in <filename class="headerfile">boost/date_time/local_time/local_time.hpp</filename>. This class stores time-zone related data using <classname>boost::local_time::posix_time_zone</classname><indexterm><primary>local_time::posix_time_zone</primary></indexterm><indexterm><primary>posix_time_zone, local_time</primary></indexterm>.</para>
    <example xml:id="ex.datetime_17">
      <title>Using <classname>boost::local_time::local_date_time</classname></title>
      <programlisting><xi:include href="../src/datetime_17/main.cpp" parse="text"/></programlisting>
    </example>
    <para>The constructor of <classname>boost::local_time::local_date_time</classname> expects its first parameter to be an object of type <classname>boost::posix_time::ptime</classname> and its second parameter to be an object of type <type>boost::local_time::time_zone_ptr</type><indexterm><primary>local_time::time_zone_ptr</primary></indexterm><indexterm><primary>time_zone_ptr, local_time</primary></indexterm>. <type>boost::local_time::time_zone_ptr</type> is a type definition for <type>boost::shared_ptr&lt;boost::local_time::time_zone&gt;</type>. The type definition is based on <classname>boost::local_time::time_zone</classname>, not <classname>boost::local_time::posix_time_zone</classname>. Thatâ€™s fine because <classname>boost::local_time::posix_time_zone</classname> is derived from <classname>boost::local_time::time_zone</classname><indexterm><primary>local_time::time_zone</primary></indexterm><indexterm><primary>time_zone, local_time</primary></indexterm>. This makes it possible to extend Boost.DateTime with user-defined types for time zones.</para>
    <para>No object of type <classname>boost::local_time::posix_time_zone</classname> is passed. Instead, a smart pointer referring to the object is passed. This allows multiple objects of type <classname>boost::local_time::local_date_time</classname> to share time-zone data. When the last object is destroyed, the object representing the time zone will automatically be released.</para>
    <para>To create an object of type <classname>boost::local_time::posix_time_zone</classname>, a string describing the time zone is passed to the constructor as the only parameter. <xref linkend="ex.datetime_17" xrefstyle="enp"/> specifies Central Europe as the time zone (<acronym>CET</acronym> is the abbreviation for Central European Time). Since <acronym>CET</acronym> is one hour ahead of <acronym>UTC</acronym>, the deviation is represented as +1. Boost.DateTime is not able to interpret abbreviations for time zones and thus does not know the meaning of <acronym>CET</acronym>. Therefore, the deviation must always be provided in hours; use the value +0 if there is no deviation.</para>
    <para>The program writes the strings <computeroutput>2014-May-12 12:00:00</computeroutput>, <computeroutput>2014-May-12 13:00:00 CET</computeroutput>, <computeroutput>2014-May-12 13:00:00</computeroutput>, and <computeroutput>CET</computeroutput> to the standard output stream. Values used to initialize objects of type <classname>boost::posix_time::ptime</classname> and <classname>boost::local_time::local_date_time</classname> always relate to the <acronym>UTC</acronym> time zone by default. When an object of type <classname>boost::local_time::local_date_time</classname> is written to the standard output stream or a call to the member function <methodname>local_time</methodname><indexterm><primary>local_time::local_date_time::local_time</primary></indexterm><indexterm><primary>local_time, local_time::local_date_time</primary></indexterm> is made, the deviation in hours is used to calculate the local time.</para>
    <example xml:id="ex.datetime_18">
      <title>Location-dependent points in time and different time zones</title>
      <programlisting><xi:include href="../src/datetime_18/main.cpp" parse="text"/></programlisting>
    </example>
    <para>With <methodname>local_time</methodname>, the deviation for the time zone is respected. In order to calculate the <acronym>CET</acronym> time, one hour needs to be added to the <acronym>UTC</acronym> time of 12 PM stored in <varname>dt</varname>, since <acronym>CET</acronym> is one hour ahead of <acronym>UTC</acronym>. Thatâ€™s why <methodname>local_time</methodname> writes <computeroutput>2014-May-12 13:00:00</computeroutput> to standard output in <xref linkend="ex.datetime_18" xrefstyle="enp"/>.</para>
    <para>In contrast, the member function <methodname>local_time_in</methodname><indexterm><primary>local_time::local_date_time::local_time_in</primary></indexterm><indexterm><primary>local_time_in, local_time::local_date_time</primary></indexterm> interprets the time stored in <varname>dt</varname> as being in the time zone that is passed as a parameter. This means that 12 PM <acronym>UTC</acronym> equals 2 PM <acronym>EET</acronym> which stands for Eastern European Time and is two hours ahead of <acronym>UTC</acronym>.</para>
    <para>Finally, Boost.DateTime provides the class <classname>boost::local_time::local_time_period</classname><indexterm><primary>local_time::local_time_period</primary></indexterm><indexterm><primary>local_time_period, local_time</primary></indexterm> for location-dependent periods.</para>
    <example xml:id="ex.datetime_19">
      <title>Using <classname>boost::local_time::local_time_period</classname></title>
      <programlisting><xi:include href="../src/datetime_19/main.cpp" parse="text"/></programlisting>
    </example>
    <para>The constructor of <classname>boost::local_time::local_time_period</classname> in <xref linkend="ex.datetime_19" xrefstyle="enp"/> expects two parameters of type <classname>boost::local_time::local_date_time</classname><indexterm><primary>local_time::local_date_time</primary></indexterm><indexterm><primary>local_date_time, local_time</primary></indexterm>. As with other types provided for periods, the second parameter, which represents the end time, is not part of the period. With the help of member functions such as <methodname>contains</methodname><indexterm><primary>local_time::local_time_period::contains</primary></indexterm><indexterm><primary>contains, local_time::local_time_period</primary></indexterm>, <methodname>intersection</methodname><indexterm><primary>local_time::local_time_period::intersection</primary></indexterm><indexterm><primary>intersection, local_time::local_time_period</primary></indexterm>, <methodname>merge</methodname><indexterm><primary>local_time::local_time_period::merge</primary></indexterm><indexterm><primary>merge, local_time::local_time_period</primary></indexterm>, and others, you can process periods based on <classname>boost::local_time::local_time_period</classname>.</para>
  </sect1>
  <sect1 xml:id="boost.datetime-formatted-input-and-output">
    <title>Formatted Input and Output</title>
    <para>The sample programs described so far in this chapter write results in the format <computeroutput>2014-May-12</computeroutput>. Boost.DateTime lets you display results in different formats. Calendar dates and times can be formatted using <classname>boost::date_time::date_facet</classname><indexterm><primary>date_time::date_facet</primary></indexterm><indexterm><primary>date_facet, date_time</primary></indexterm> and <classname>boost::date_time::time_facet</classname><indexterm><primary>date_time::time_facet</primary></indexterm><indexterm><primary>time_facet, date_time</primary></indexterm>.</para>
    <para>Boost.DateTime uses the concept of locales from the standard. To format a calendar date, an object of type <classname>boost::date_time::date_facet</classname> must be created and installed within a locale. A string describing the new format is passed to the constructor of <classname>boost::date_time::date_facet</classname>. <xref linkend="ex.datetime_20" xrefstyle="enp" /> passes <quote>%A, %d %B %Y</quote>, which specifies that the day of the week is followed by the date with the month written in full: <computeroutput>Monday, 12 May 2014</computeroutput>.</para>
    <example xml:id="ex.datetime_20">
      <title>A user-defined format for a date</title>
      <programlisting><xi:include href="../src/datetime_20/main.cpp" parse="text"/></programlisting>
    </example>
    <para>Boost.DateTime provides numerous format flags, each of which consists of the percent sign followed by a character. The documentation for Boost.DateTime contains a complete <link xlink:href="http://www.boost.org/doc/html/date_time/date_time_io.html#date_time.format_flags">overview of all supported flags</link>.</para>
    <para>If a program is used by people located in Germany or German-speaking countries, it is preferable to display both the weekday and the month in German rather than in English.</para>
    <example xml:id="ex.datetime_21">
      <title>Changing names of weekdays and months</title>
      <programlisting><xi:include href="../src/datetime_21/main.cpp" parse="text"/></programlisting>
    </example>
    <para>The names for weekdays and months can be changed by passing vectors containing the desired names to the member functions <methodname>long_month_names</methodname><indexterm><primary>gregorian::date_facet::long_month_names</primary></indexterm><indexterm><primary>long_month_names, gregorian::date_facet</primary></indexterm> and <methodname>long_weekday_names</methodname><indexterm><primary>gregorian::date_facet::long_weekday_names</primary></indexterm><indexterm><primary>long_weekday_names, gregorian::date_facet</primary></indexterm> of the class <classname>boost::date_time::date_facet</classname>. <xref linkend="ex.datetime_21" xrefstyle="enp"/> now writes <computeroutput>Montag, 12. Mai 2014</computeroutput> to the standard output stream.</para>
    <note>
      <para>To run the example on a POSIX operating system, replace <quote>German</quote> with <quote>de_DE</quote> and make sure the locale for German is installed.</para>
    </note>
    <para>Boost.DateTime is flexible with regard to formatted input and output. Besides the output classes <classname>boost::date_time::date_facet</classname> and <classname>boost::date_time::time_facet</classname>, the classes <classname>boost::date_time::date_input_facet</classname><indexterm><primary>date_time::date_input_facet</primary></indexterm><indexterm><primary>date_input_facet, date_time</primary></indexterm> and <classname>boost::date_time::time_input_facet</classname><indexterm><primary>date_time::time_input_facet</primary></indexterm><indexterm><primary>time_input_facet, date_time</primary></indexterm> are available for formatted input. All four classes provide member functions to configure the input and output of different objects provided by Boost.DateTime. For example, it is possible to specify how periods of type <classname>boost::gregorian::date_period</classname> are input and output. To see all of the possibilities for formatted input and output, review the documentation for Boost.DateTime.</para>
  </sect1>
</chapter>
