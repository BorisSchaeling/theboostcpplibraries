<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.filesystem">
  <title>Boost.Filesystem</title><indexterm><primary>Boost.Filesystem</primary></indexterm>
  <para>The library <link xlink:href="http://www.boost.org/libs/filesystem">Boost.Filesystem</link> makes it easy to work with files and directories. It provides a class called <classname>boost::filesystem::path</classname> that processes paths. In addition, many free-standing functions are available to handle tasks like creating directories or checking whether a file exists.</para>
  <para>Boost.Filesystem has been revised several times. This chapter introduces Boost.Filesystem 3, the current version. This version has been the default since the Boost C++ Libraries 1.46.0. Boost.Filesystem 2 was last shipped with version 1.49.0.</para>
  <sect1 xml:id="boost.filesystem-paths">
    <title>Paths</title>
    <para><classname>boost::filesystem::path</classname><indexterm><primary>filesystem::path</primary></indexterm><indexterm><primary>path, filesystem</primary></indexterm> is the central class in Boost.Filesystem for representing and processing paths. Definitions can be found in the namespace <package>boost::filesystem</package> and in the header file <filename class="headerfile">boost/filesystem.hpp</filename>. Paths can be built by passing a string to the constructor of <classname>boost::filesystem::path</classname> (see <xref linkend="ex.filesystem_01" xrefstyle="enp"/>).</para>
    <example xml:id="ex.filesystem_01">
      <title>Using <classname>boost::filesystem::path</classname></title>
      <programlisting><xi:include href="../src/filesystem_01/main.cpp" parse="text"/></programlisting>
    </example>
    <para><classname>boost::filesystem::path</classname> can be initialized with wide strings. Wide strings are interpreted as Unicode and make it easy to create paths using characters from nearly any language. This is a crucial difference from Boost.Filesystem 2, which provided separate classes, such as <classname>boost::filesystem::path</classname> and <classname>boost::filesystem::wpath</classname>, for different string types.</para>
    <para>Please note that Boost.Filesystem doesn’t support <classname>std::u16string</classname> or <classname>std::u32string</classname>. Your compiler aborts with an error if you try to initialize <classname>boost::filesystem::path</classname> with one of these string types.</para>
    <para>None of the constructors of <classname>boost::filesystem::path</classname> validate paths or check whether the given file or directory exists. Thus, <classname>boost::filesystem::path</classname> can be instantiated even with meaningless paths.</para>
    <example xml:id="ex.filesystem_02">
      <title>Meaningless paths with <classname>boost::filesystem::path</classname></title>
      <programlisting><xi:include href="../src/filesystem_02/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.filesystem_02" xrefstyle="enp"/> runs without any problems because paths are just strings. <classname>boost::filesystem::path</classname> only processes strings; the file system is not accessed.</para>
    <para>Because <classname>boost::filesystem::path</classname> processes strings, the class provides several member functions to retrieve a path as a string.</para>
    <para>In general, Boost.Filesystem differentiates between <emphasis role="concept">native paths</emphasis><indexterm><primary>native path, Boost.Filesystem</primary></indexterm> and <emphasis role="concept">generic paths</emphasis><indexterm><primary>generic path, Boost.Filesystem</primary></indexterm>. Native paths are operating system specific and must be used when calling operating system functions. Generic paths are portable and independent of the operating system.</para>
    <example xml:id="ex.filesystem_03">
      <title>Retrieving paths from <classname>boost::filesystem::path</classname> as strings</title>
      <programlisting><xi:include href="../src/filesystem_03/main.cpp" parse="text"/></programlisting>
    </example>
    <para>The member functions <methodname>native</methodname><indexterm><primary>filesystem::path::native</primary></indexterm><indexterm><primary>native, filesystem::path</primary></indexterm>, <methodname>string</methodname><indexterm><primary>filesystem::path::string</primary></indexterm><indexterm><primary>string, filesystem::path</primary></indexterm> and <methodname>wstring</methodname><indexterm><primary>filesystem::path::wstring</primary></indexterm><indexterm><primary>wstring, filesystem::path</primary></indexterm> all return paths in the native format. When run on Windows, <xref linkend="ex.filesystem_03" xrefstyle="enp"/> writes <computeroutput>C:\Windows\System</computeroutput> to the standard output stream three times.</para>
    <para>The member functions <methodname>generic_string</methodname><indexterm><primary>filesystem::path::generic_string</primary></indexterm><indexterm><primary>generic_string, filesystem::path</primary></indexterm> and <methodname>generic_wstring</methodname><indexterm><primary>filesystem::path::generic_wstring</primary></indexterm><indexterm><primary>generic_wstring, filesystem::path</primary></indexterm> both return paths in a generic format. These are portable paths; the string is normalized based on rules of the POSIX standard. Generic paths are therefore identical to paths used on Linux. For example, the slash is used as the separator for directories. If <xref linkend="ex.filesystem_03" xrefstyle="enp"/> is run on Windows, both <methodname>generic_string</methodname> and <methodname>generic_wstring</methodname> write <computeroutput>C:/Windows/System</computeroutput> to the standard output stream.</para>
    <para>The return value of member functions returning native paths depends on the operating system the program is executed on. The return value of member functions returning generic paths is independent of the operating system. Generic paths uniquely identify files and directories independently from the operating system and therefore make it easy to write platform-independent code.</para>
    <para>Because <classname>boost::filesystem::path</classname> can be initialized with different string types, several member functions are provided to retrieve paths in different string types. While <methodname>string</methodname> and <methodname>generic_string</methodname> return a string of type <classname>std::string</classname>, <methodname>wstring</methodname> and <methodname>generic_wstring</methodname> return a string of type <classname>std::wstring</classname>.</para>
    <para>The return type of <methodname>native</methodname> depends on the operating system the program was compiled for. On Windows a string of type <classname>std::wstring</classname> is returned. On Linux it is a string of type <classname>std::string</classname>.</para>
    <para>The constructor of <classname>boost::filesystem::path</classname> supports both generic and platform-dependent paths. In <xref linkend="ex.filesystem_03" xrefstyle="enp" />, the path <quote>C:\\Windows\\System</quote> is Windows specific and not portable. Notice also that because the backslash is an escape character in C++, it must be escaped itself. This path will only be recognized correctly by Boost.Filesystem if the program is run on Windows. When executed on a POSIX compliant operating system such as Linux, this example will return <computeroutput>C:\Windows\System</computeroutput> for all member functions called. Since the backslash is not used as a separator on Linux in either the portable or the native format, Boost.Filesystem does not recognize this character as a separator for files and directories.</para>
    <para>The macro <code>BOOST_WINDOWS_API</code><indexterm><primary>BOOST_WINDOWS_API, Boost.Filesystem</primary></indexterm> comes from Boost.System and is defined if the example is compiled on Windows. The respective macro for POSIX operating systems is called <code>BOOST_POSIX_API</code><indexterm><primary>BOOST_POSIX_API, Boost.Filesystem</primary></indexterm>.</para>
    <para><xref linkend="ex.filesystem_04" xrefstyle="enp"/> uses a portable path to initialize <classname>boost::filesystem::path</classname>.</para>
    <example xml:id="ex.filesystem_04">
      <title>Initializing <classname>boost::filesystem::path</classname> with a portable path</title>
      <programlisting><xi:include href="../src/filesystem_04/main.cpp" parse="text"/></programlisting>
    </example>
    <para>Because <methodname>generic_string</methodname> returns a portable path, its value will be a slash (<quote>/</quote>), the same as was used to initialize <classname>boost::filesystem::path</classname>. However, the member function <methodname>string</methodname> returns different values depending on the platform. On Windows and Linux it returns <quote>/</quote>. The output is the same because Windows accepts the slash as a directory separator even though it prefers the backslash.</para>
    <para><classname>boost::filesystem::path</classname> provides several member functions to access certain components of a path.</para>
    <example xml:id="ex.filesystem_05">
      <title>Accessing components of a path</title>
      <programlisting><xi:include href="../src/filesystem_05/main.cpp" parse="text"/></programlisting>
    </example>
    <para>If <xref linkend="ex.filesystem_05" xrefstyle="enp"/> is executed on Windows, the string <quote>C:\\Windows\\System</quote> is interpreted as a platform-dependent path. Consequently, <methodname>root_name</methodname><indexterm><primary>filesystem::path::root_name</primary></indexterm><indexterm><primary>root_name, filesystem::path</primary></indexterm> returns <computeroutput>"C:"</computeroutput>, <methodname>root_directory</methodname><indexterm><primary>filesystem::path::root_directory</primary></indexterm><indexterm><primary>root_directory, filesystem::path</primary></indexterm> returns <computeroutput>"\"</computeroutput>, <methodname>root_path</methodname><indexterm><primary>filesystem::path::root_path</primary></indexterm><indexterm><primary>root_path, filesystem::path</primary></indexterm> returns <computeroutput>"C:\"</computeroutput>, <methodname>relative_path</methodname><indexterm><primary>filesystem::path::relative_path</primary></indexterm><indexterm><primary>relative_path, filesystem::path</primary></indexterm> returns <computeroutput>"Windows\System"</computeroutput>, <methodname>parent_path</methodname><indexterm><primary>filesystem::path::parent_path</primary></indexterm><indexterm><primary>parent_path, filesystem::path</primary></indexterm> returns <computeroutput>"C:\Windows"</computeroutput>, and <methodname>filename</methodname><indexterm><primary>filesystem::path::filename</primary></indexterm><indexterm><primary>filename, filesystem::path</primary></indexterm> returns <computeroutput>"System"</computeroutput>.</para>
    <para>All member functions return platform-dependent paths because <classname>boost::filesystem::path</classname> stores paths in a platform-dependent format internally. To retrieve paths in a portable format, member functions such as <methodname>generic_string</methodname> need to be called explicitly.</para>
    <para>If <xref linkend="ex.filesystem_05" xrefstyle="enp"/> is executed on Linux, the returned values are different. Most of the member functions return an empty string, except <methodname>relative_path</methodname> and <methodname>filename</methodname>, which return <computeroutput>"C:\Windows\System"</computeroutput>. This means that the string <quote>C:\\Windows\\System</quote> is interpreted as a file name on Linux, which is understandable given that it is neither a portable encoding of a path nor a platform-dependent encoding on Linux. Therefore, Boost.Filesystem has no choice but to interpret it as a file name.</para>
    <para>Boost.Filesystem provides additional member functions to verify whether a path contains a specific substring. These member functions are: <methodname>has_root_name</methodname><indexterm><primary>filesystem::path::has_root_name</primary></indexterm><indexterm><primary>has_root_name, filesystem::path</primary></indexterm>, <methodname>has_root_directory</methodname><indexterm><primary>filesystem::path::has_root_directory</primary></indexterm><indexterm><primary>has_root_directory, filesystem::path</primary></indexterm>, <methodname>has_root_path</methodname><indexterm><primary>filesystem::path::has_root_path</primary></indexterm><indexterm><primary>has_root_path, filesystem::path</primary></indexterm>, <methodname>has_relative_path</methodname><indexterm><primary>filesystem::path::has_relative_path</primary></indexterm><indexterm><primary>has_relative_path, filesystem::path</primary></indexterm>, <methodname>has_parent_path</methodname><indexterm><primary>filesystem::path::has_parent_path</primary></indexterm><indexterm><primary>has_parent_path, filesystem::path</primary></indexterm>, and <methodname>has_filename</methodname><indexterm><primary>filesystem::path::has_filename</primary></indexterm><indexterm><primary>has_filename, filesystem::path</primary></indexterm>. Each member function returns a value of type <type>bool</type>.</para>
    <para>There are two more member functions that can split a file name into its components. They should only be called if <methodname>has_filename</methodname> returns <literal>true</literal>. Otherwise, they will return empty strings because there is nothing to split if there is no file name.</para>
    <example xml:id="ex.filesystem_06">
      <title>Receiving file name and file extension</title>
      <programlisting><xi:include href="../src/filesystem_06/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.filesystem_06" xrefstyle="enp"/> returns <computeroutput>"photo"</computeroutput> for <methodname>stem</methodname><indexterm><primary>filesystem::path::stem</primary></indexterm><indexterm><primary>stem, filesystem::path</primary></indexterm> and <computeroutput>".jpg"</computeroutput> for <methodname>extension</methodname><indexterm><primary>filesystem::path::extension</primary></indexterm><indexterm><primary>extension, filesystem::path</primary></indexterm>.</para>
    <para>Instead of accessing the components of a path via member function calls, you can also iterate over the components.</para>
    <example xml:id="ex.filesystem_07">
      <title>Iterating over components of a path</title>
      <programlisting><xi:include href="../src/filesystem_07/main.cpp" parse="text"/></programlisting>
    </example>
    <para>If executed on Windows, <xref linkend="ex.filesystem_07" xrefstyle="enp"/> will successively output <computeroutput>"C:"</computeroutput>, <computeroutput>"/"</computeroutput>, <computeroutput>"Windows"</computeroutput> and <computeroutput>"System"</computeroutput>. On Linux, the output will be <computeroutput>"C:\Windows\System"</computeroutput>.</para>
    <para>While the previous examples introduced various member functions to access different components of a path, <xref linkend="ex.filesystem_08" xrefstyle="enp"/> uses a member function to modify a path.</para>
    <example xml:id="ex.filesystem_08">
      <title>Concatenating paths with <methodname role="operator">operator/=</methodname></title>
      <programlisting><xi:include href="../src/filesystem_08/main.cpp" parse="text"/></programlisting>
    </example>
    <para>Using <methodname role="operator">operator/=</methodname><indexterm><primary>filesystem::path::operator/=</primary></indexterm><indexterm><primary>operator/=, filesystem::path</primary></indexterm>, <xref linkend="ex.filesystem_08" xrefstyle="enp"/> appends one path to another. On Windows, the program outputs <computeroutput>C:\Windows\System</computeroutput>. On Linux, the output is <computeroutput>C:\/Windows\System</computeroutput>, since the slash is used as a separator for files and directories. The slash is also the reason why <methodname role="operator">operator/=</methodname> has been overloaded; after all, the slash is part of the operator.</para>
    <para>Besides <methodname role="operator">operator/=</methodname>, Boost.Filesystem provides the member functions <methodname>remove_filename</methodname><indexterm><primary>filesystem::path::remove_filename</primary></indexterm><indexterm><primary>remove_filename, filesystem::path</primary></indexterm>, <methodname>replace_extension</methodname><indexterm><primary>filesystem::path::replace_extension</primary></indexterm><indexterm><primary>replace_extension, filesystem::path</primary></indexterm>, <methodname>make_absolute</methodname><indexterm><primary>filesystem::path::make_absolute</primary></indexterm><indexterm><primary>make_absolute, filesystem::path</primary></indexterm>, and <methodname>make_preferred</methodname><indexterm><primary>filesystem::path::make_preferred</primary></indexterm><indexterm><primary>make_preferred, filesystem::path</primary></indexterm> to modify paths. The last member function mentioned is particularly designed for use on Windows.</para>
    <example xml:id="ex.filesystem_09">
      <title>Preferred notation with <methodname>make_preferred</methodname></title>
      <programlisting><xi:include href="../src/filesystem_09/main.cpp" parse="text"/></programlisting>
    </example>
    <para>Even though the backslash is used as the separator for files and directories by default, Windows still accepts the slash. <quote>C:/Windows/System</quote> is therefore a valid native path. With <methodname>make_preferred</methodname> such a path can be converted to the preferred notation on Windows. <xref linkend="ex.filesystem_09" xrefstyle="enp"/> displays <computeroutput>"C:\Windows\System"</computeroutput>.</para>
    <para>The member function <methodname>make_preferred</methodname> has no effect on POSIX compliant operating systems such as Linux.</para>
    <para>Please note that <methodname>make_preferred</methodname> not only returns the converted path, but also modifies the object it has been called on. <varname>p</varname> contains <quote>C:\Windows\System</quote> after the call.</para>
  </sect1>
  <sect1 xml:id="boost.filesystem-files-and-directories">
    <title>Files and Directories</title>
    <para>The member functions presented with <classname>boost::filesystem::path</classname> simply process strings. They access individual components of a path, append paths to one another, and so on.</para>
    <para>In order to work with physical files and directories on the hard drive, several free-standing functions are provided. They expect one or more parameters of type <classname>boost::filesystem::path</classname> and call operating system functions internally.</para>
    <para>Prior to introducing the various functions, it is important to understand what happens in case of an error. All of the functions call operating system functions that may fail. Therefore, Boost.Filesystem provides two variants of the functions that behave differently in case of an error:</para>
    <itemizedlist>
      <listitem>
        <para>The first variant throws an exception of type <exceptionname>boost::filesystem::filesystem_error</exceptionname><indexterm><primary>filesystem::filesystem_error</primary></indexterm><indexterm><primary>filesystem_error, filesystem</primary></indexterm>. This class is derived from <exceptionname>boost::system::system_error</exceptionname> and thus fits into the Boost.System framework.</para>
      </listitem>
      <listitem>
        <para>The second variant expects an object of type <classname>boost::system::error_code</classname> as an additional parameter. This object is passed by reference and can be examined after the function call. In case of a failure, the object stores the corresponding error code.</para>
      </listitem>
    </itemizedlist>
    <para><exceptionname>boost::system::system_error</exceptionname> and <classname>boost::system::error_code</classname> are presented in <xref linkend="boost.system" xrefstyle="wtp"/>. In addition to the inherited interface from <exceptionname>boost::system::system_error</exceptionname>, <exceptionname>boost::filesystem::filesystem_error</exceptionname> provides two member functions called <methodname>path1</methodname><indexterm><primary>filesystem::filesystem_error::path1</primary></indexterm><indexterm><primary>path1, filesystem::filesystem_error</primary></indexterm> and <methodname>path2</methodname><indexterm><primary>filesystem::filesystem_error::path2</primary></indexterm><indexterm><primary>path2, filesystem::filesystem_error</primary></indexterm>, both of which return an object of type <classname>boost::filesystem::path</classname>. Since there are functions that expect two parameters of type <classname>boost::filesystem::path</classname>, these two member functions provide an easy way to retrieve the corresponding paths in case of a failure.</para>
    <example xml:id="ex.filesystem_10">
      <title>Using <function>boost::filesystem::status</function></title>
      <programlisting><xi:include href="../src/filesystem_10/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.filesystem_10" xrefstyle="enp"/> introduces <function>boost::filesystem::status</function><indexterm><primary>filesystem::status</primary></indexterm><indexterm><primary>status, filesystem</primary></indexterm>, which queries the status of a file or directory. This function returns an object of type <classname>boost::filesystem::file_status</classname><indexterm><primary>filesystem::file_status</primary></indexterm><indexterm><primary>file_status, filesystem</primary></indexterm>, which can be passed to additional helper functions for evaluation. For example, <function>boost::filesystem::is_directory</function><indexterm><primary>filesystem::is_directory</primary></indexterm><indexterm><primary>is_directory, filesystem</primary></indexterm> returns <literal>true</literal> if the status for a directory was queried. Besides <function>boost::filesystem::is_directory</function>, other functions are available, including <function>boost::filesystem::is_regular_file</function><indexterm><primary>filesystem::is_regular_file</primary></indexterm><indexterm><primary>is_regular_file, filesystem</primary></indexterm>, <function>boost::filesystem::is_symlink</function><indexterm><primary>filesystem::is_symlink</primary></indexterm><indexterm><primary>is_symlink, filesystem</primary></indexterm>, and <function>boost::filesystem::exists</function><indexterm><primary>filesystem::exists</primary></indexterm><indexterm><primary>exists, filesystem</primary></indexterm>, all of which return a value of type <type>bool</type>.</para>
    <para>The function <function>boost::filesystem::symlink_status</function><indexterm><primary>filesystem::symlink_status</primary></indexterm><indexterm><primary>symlink_status, filesystem</primary></indexterm> queries the status of a symbolic link. With <function>boost::filesystem::status</function> the status of the file referred to by the symbolic link is queried. On Windows, symbolic links are identified by the file extension <filename class="extension">lnk</filename>.</para>
    <example xml:id="ex.filesystem_11">
      <title>Using <function>boost::filesystem::file_size</function></title>
      <programlisting><xi:include href="../src/filesystem_11/main.cpp" parse="text"/></programlisting>
    </example>
    <para>A different category of functions makes it possible to query attributes. The function <function>boost::filesystem::file_size</function><indexterm><primary>filesystem::file_size</primary></indexterm><indexterm><primary>file_size, filesystem</primary></indexterm> returns the size of a file in bytes. The return value is of type <type>boost::uintmax_t</type>, which is a type definition for <type>unsigned long long</type>. The type is provided by Boost.Integer.</para>
    <para><xref linkend="ex.filesystem_11" xrefstyle="enp"/> uses an object of type <classname>boost::system::error_code</classname>, which needs to be evaluated explicitly to determine whether the call to <function>boost::filesystem::file_size</function> was successful.</para>
    <example xml:id="ex.filesystem_12">
      <title>Using <function>boost::filesystem::last_write_time</function></title>
      <programlisting><xi:include href="../src/filesystem_12/main.cpp" parse="text"/></programlisting>
    </example>
    <para>To determine the time a file was modified last, <function>boost::filesystem::last_write_time</function><indexterm><primary>filesystem::last_write_time</primary></indexterm><indexterm><primary>last_write_time, filesystem</primary></indexterm> can be used (see <xref linkend="ex.filesystem_12" xrefstyle="enp"/>).</para>
    <example xml:id="ex.filesystem_13">
      <title>Using <function>boost::filesystem::space</function></title>
      <programlisting><xi:include href="../src/filesystem_13/main.cpp" parse="text"/></programlisting>
    </example>
    <para><function>boost::filesystem::space</function><indexterm><primary>filesystem::space</primary></indexterm><indexterm><primary>space, filesystem</primary></indexterm> retrieves the total and remaining disk space (see <xref linkend="ex.filesystem_13" xrefstyle="enp"/>). It returns an object of type <classname>boost::filesystem::space_info</classname><indexterm><primary>filesystem::space_info</primary></indexterm><indexterm><primary>space_info, filesystem</primary></indexterm>, which provides three public member variables: <varname>capacity</varname><indexterm><primary>filesystem::space_info::capacity</primary></indexterm><indexterm><primary>capacity, filesystem::space_info</primary></indexterm>, <varname>free</varname><indexterm><primary>filesystem::space_info::free</primary></indexterm><indexterm><primary>free, filesystem::space_info</primary></indexterm>, and <varname>available</varname><indexterm><primary>filesystem::space_info::available</primary></indexterm><indexterm><primary>available, filesystem::space_info</primary></indexterm>, all of type <type>boost::uintmax_t</type>. The disk space is in bytes.</para>
    <para>While the functions presented so far leave files and directories untouched, there are several functions that can be used to create, rename, or delete files and directories.</para>
    <example xml:id="ex.filesystem_14">
      <title>Creating, renaming, and deleting directories</title>
      <programlisting><xi:include href="../src/filesystem_14/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.filesystem_14" xrefstyle="enp"/> should be self-explanatory. Looking closely, one can see that it’s not always an object of type <classname>boost::filesystem::path</classname> that is passed to functions, but rather a simple string. This is possible because <classname>boost::filesystem::path</classname> provides a non-explicit constructor that will convert strings to objects of type <classname>boost::filesystem::path</classname>. This makes it easy to use Boost.Filesystem since it’s not required to create paths explicitly.</para>
    <note>
      <para>In <xref linkend="ex.filesystem_14" xrefstyle="enp" />, <function>boost::filesystem::remove</function> is explicitly called using its namespace. Otherwise, Visual C++ 2013 would confuse the function with <function>remove</function> from the header file <filename class="headerfile">stdio.h</filename>.</para>
    </note>
    <para>Additional functions such as <function>create_symlink</function><indexterm><primary>filesystem::create_symlink</primary></indexterm><indexterm><primary>create_symlink, filesystem</primary></indexterm> to create symbolic links or <function>copy_file</function><indexterm><primary>filesystem::copy_file</primary></indexterm><indexterm><primary>copy_file, filesystem</primary></indexterm> and <function>copy_directory</function><indexterm><primary>filesystem::copy_directory</primary></indexterm><indexterm><primary>copy_directory, filesystem</primary></indexterm> to copy files and directories are available as well.</para>
    <example xml:id="ex.filesystem_15">
      <title>Using <function>boost::filesystem::absolute</function></title>
      <programlisting><xi:include href="../src/filesystem_15/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.filesystem_15" xrefstyle="enp"/> presents a function that creates an absolute path based on a file name or section of a path. The path displayed depends on which directory the program is started in. For example, if the program was started in <filename>C:\</filename>, the output would be <computeroutput>"C:\photo.jpg"</computeroutput>.</para>
    <para>To retrieve an absolute path relative to a different directory, a second parameter can be passed to <function>boost::filesystem::absolute</function><indexterm><primary>filesystem::absolute</primary></indexterm><indexterm><primary>absolute, filesystem</primary></indexterm>.</para>
    <example xml:id="ex.filesystem_16">
      <title>Creating an absolute path relative to another directory</title>
      <programlisting><xi:include href="../src/filesystem_16/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.filesystem_16" xrefstyle="enp"/> displays <computeroutput>"D:\photo.jpg"</computeroutput>.</para>
    <para>The last example in this section, <xref linkend="ex.filesystem_17" xrefstyle="enp"/>, introduces a useful helper function to retrieve the current working directory.</para>
    <example xml:id="ex.filesystem_17">
      <title>Using <function>boost::filesystem::current_path</function></title>
      <programlisting><xi:include href="../src/filesystem_17/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.filesystem_17" xrefstyle="enp"/> calls <function>boost::filesystem::current_path</function><indexterm><primary>filesystem::current_path</primary></indexterm><indexterm><primary>current_path, filesystem</primary></indexterm> multiple times. If the function is called without parameters, the current working directory is returned. If an object of type <classname>boost::filesystem::path</classname> is passed, the current working directory is set.</para>
  </sect1>
  <sect1 xml:id="boost.filesystem-iterators">
    <title>Directory Iterators</title>
    <para>Boost.Filesystem provides the iterator <classname>boost::filesystem::directory_iterator</classname><indexterm><primary>filesystem::directory_iterator</primary></indexterm><indexterm><primary>directory_iterator, filesystem</primary></indexterm> to iterate over files in a directory (see <xref linkend="ex.filesystem_18" xrefstyle="enp"/>).</para>
    <example xml:id="ex.filesystem_18">
      <title>Iterating over files in a directory</title>
      <programlisting><xi:include href="../src/filesystem_18/main.cpp" parse="text"/></programlisting>
    </example>
    <para><classname>boost::filesystem::directory_iterator</classname> is initialized with a path to retrieve an iterator pointing to the beginning of a directory. To retrieve the end of a directory, the class must be instantiated with the default constructor.</para>
    <para>Entries can be created or deleted while iterating without invalidating the iterator. However, whether changes become visible during the iteration is undefined. For example, the iterator might not point to newly created files. To ensure that all current entries are accessible, restart the iteration.</para>
    <para>To recursively iterate over a directory and subdirectories, Boost.Filesystem provides the iterator <classname>boost::filesystem::recursive_directory_iterator</classname><indexterm><primary>filesystem::recursive_directory_iterator</primary></indexterm><indexterm><primary>recursive_directory_iterator, filesystem</primary></indexterm>.</para>
    <simplesect role="exercises" xml:id="boost.filesystem-iterators-exercises">
      <title>Exercise</title>
      <para>Create a command line program that writes the names of all regular files with the file extension <filename class="extension">cpp</filename> in the current working directory to standard output. Directories aren’t regular files. Directory names that end with <filename class="extension">cpp</filename> should not be written to standard output.</para>
    </simplesect>
  </sect1>
  <sect1 xml:id="boost.filesystem-file-streams">
    <title>File Streams</title>
    <para>The standard defines various file streams in the header file <filename class="headerfile">fstream</filename>. These streams do not accept parameters of type <classname>boost::filesystem::path</classname>. If you want to open file streams with objects of type <classname>boost::filesystem::path</classname>, include the header file <filename class="headerfile">boost/filesystem/fstream.hpp</filename>.</para>
    <example xml:id="ex.filesystem_19">
      <title>Using <classname>boost::filesystem::ofstream</classname></title>
      <programlisting><xi:include href="../src/filesystem_19/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.filesystem_19" xrefstyle="enp" /> opens a file with the help of the class <classname>boost::filesystem::ofstream</classname><indexterm><primary>filesystem::ofstream</primary></indexterm><indexterm><primary>ofstream, filesystem</primary></indexterm>. An object of type <classname>boost::filesystem::path</classname> can be passed to the constructor of <classname>boost::filesystem::ofstream</classname>. The member function <methodname>open</methodname><indexterm><primary>filesystem::ofstream::open</primary></indexterm><indexterm><primary>open, filesystem::ofstream</primary></indexterm> also accepts a parameter of type <classname>boost::filesystem::path</classname>.</para>
  </sect1>
</chapter>
