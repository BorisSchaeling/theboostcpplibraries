<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.spirit">
  <title>Boost.Spirit</title><indexterm><primary>Boost.Spirit</primary></indexterm>
  <para>This chapter introduces the library <link xlink:href="http://www.boost.org/libs/spirit">Boost.Spirit</link>. Boost.Spirit is used to develop parsers for text formats. For example, you can use Boost.Spirit to develop a parser to load configuration files. Boost.Spirit can also be used for binary formats, although its usefulness in this respect is limited.</para>
  <para>Boost.Spirit simplifies the development of parsers because formats are described with rules. Rules define what a format looks like &#x2013; Boost.Spirit does the rest. You can compare Boost.Spirit to regular expressions, in the sense that it lets you handle complex processes &#x2013; pattern searching in the case of regular expressions and parsing for Boost.Spirit &#x2013; without having to write code to implement that process.</para>
  <para>Boost.Spirit expects rules to be described using Parsing Expression Grammar (<acronym>PEG</acronym>). <acronym>PEG</acronym> is related to Extended Backus-Naur-Form (<acronym>EBNF</acronym>). Even if you are not familiar with these languages, the examples in this chapter should be sufficient to get you started.</para>
  <para>There are two versions of Boost.Spirit. The first version is known as Spirit.Classic. This version should not be used anymore. The current version is 2.5.2. This is the version introduced in this chapter.</para>
  <para>Since version 2.x, Boost.Spirit can be used to generate generators as well as parsers. While parsers read text formats, generators write them. The component of Boost.Spirit that is used to develop parsers is called Spirit.Qi. Spirit.Karma is the component used to develop generators. Namespaces are partitioned accordingly: classes and functions to develop parsers can be found in <package>boost::spirit::qi</package> and classes and functions to develop generators can be found in <package>boost::spirit::karma</package>.</para>
  <para>Besides Spirit.Qi and Spirit.Karma, the library contains a component called Spirit.Lex, which can be used to develop lexers.</para>
  <para>This chapter focuses on developing parsers. The examples mainly use classes and functions from <package>boost::spirit</package> and <package>boost::spirit::qi</package>. For these classes and functions, it is sufficient to include the header file <filename class="headerfile">boost/spirit/include/qi.hpp</filename>.</para>
  <para>If you don’t want to include a master header file like <filename class="headerfile">boost/spirit/include/qi.hpp</filename>, you can include header files from <filename class="directory">boost/spirit/include/</filename> individually. It is important to include header files from this directory only. <filename class="directory">boost/spirit/include/</filename> is the interface to the user. Header files in other directories can change in new library versions.</para>
  <sect1 xml:id="boost.spirit-api">
    <title>API</title>
    <para>Boost.Spirit provides <function>boost::spirit::qi::parse</function> and <function>boost::spirit::qi::phrase_parse</function> to parse a format.</para>
    <example xml:id="ex.spirit_01">
      <title>Using <function>boost::spirit::qi::parse</function></title>
      <programlisting><xi:include href="../src/spirit_01/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.spirit_01" xrefstyle="enp"/> introduces <function>boost::spirit::qi::parse</function><indexterm><primary>spirit::qi::parse</primary></indexterm><indexterm><primary>parse, spirit::qi</primary></indexterm>. This function expects two iterators of the string being parsed and a parser. The example uses the parser <varname>boost::spirit::ascii::digit</varname><indexterm><primary>spirit::ascii::digit</primary></indexterm><indexterm><primary>digit, spirit::ascii</primary></indexterm>, which is provided by Boost.Spirit. This is one of several character classification parsers. These parsers test whether characters belong to a certain class. <varname>boost::spirit::ascii::digit</varname> tests whether a character is a digit between 0 and 9.</para>
    <para>The example passes iterators of a string which is read from <varname>std::cin</varname>. Note that the begin iterator isn’t passed directly to <function>boost::spirit::qi::parse</function>. It is stored in the variable <varname>it</varname>, which is then passed to <function>boost::spirit::qi::parse</function>. This is done because <function>boost::spirit::qi::parse</function> may modify the iterator.</para>
    <para>If you type a digit and then <keycap function="enter">Enter</keycap>, the example displays <computeroutput>true</computeroutput>. If you type two digits and then <keycap function="enter">Enter</keycap>, the output will be <computeroutput>true</computeroutput> followed by the second digit. If you enter a letter and then <keycap function="enter">Enter</keycap>, the output will be <computeroutput>false</computeroutput> followed by the letter.</para>
    <para>The parser <varname>boost::spirit::ascii::digit</varname>, as used in <xref linkend="ex.spirit_01" xrefstyle="enp"/>, tests exactly one character to see whether it’s a digit. If the first character is a digit, <function>boost::spirit::qi::parse</function> returns <literal>true</literal> &#x2013; otherwise, it returns <literal>false</literal>. The return value of <function>boost::spirit::qi::parse</function> indicates whether the parser succeeded.</para>
    <para><function>boost::spirit::qi::parse</function> also returns <literal>true</literal> if you enter multiple digits. Because the parser <varname>boost::spirit::ascii::digit</varname> only tests the first character, it will succeed on such a string. All digits after the first will be ignored.</para>
    <para>To let you determine how much of the string could be parsed successfully, <function>boost::spirit::qi::parse</function> changes the iterator <varname>it</varname>. After a call to <function>boost::spirit::qi::parse</function>, <varname>it</varname> refers to the character after the last one parsed successfully. If you enter multiple digits, <varname>it</varname> refers to the second digit. If you enter exactly one digit, <varname>it</varname> equals the end iterator of <varname>s</varname>. If you enter a letter, <varname>it</varname> refers to that letter.</para>
    <para><function>boost::spirit::qi::parse</function> does not ignore spaces. If you run <xref linkend="ex.spirit_01" xrefstyle="enp"/> and enter a space, <computeroutput>false</computeroutput> is displayed. <function>boost::spirit::qi::parse</function> tests the first entered character, even if that character is a space. If you want to ignore spaces, use <function>boost::spirit::qi::phrase_parse</function> instead of <function>boost::spirit::qi::parse</function>.</para>
    <example xml:id="ex.spirit_02">
      <title>Using <function>boost::spirit::qi::phrase_parse</function></title>
      <programlisting><xi:include href="../src/spirit_02/main.cpp" parse="text"/></programlisting>
    </example>
    <para><function>boost::spirit::qi::phrase_parse</function><indexterm><primary>spirit::qi::phrase_parse</primary></indexterm><indexterm><primary>phrase_parse, spirit::qi</primary></indexterm> works like <function>boost::spirit::qi::parse</function> but expects another parameter called skipper. The skipper is a parser for characters that should be ignored. <xref linkend="ex.spirit_02" xrefstyle="enp"/> uses <varname>boost::spirit::ascii::space</varname><indexterm><primary>spirit::ascii::space</primary></indexterm><indexterm><primary>space, spirit::ascii</primary></indexterm>, a character classification parser to detect spaces, as the skipper.</para>
    <para>The skipper <varname>boost::spirit::ascii::space</varname> discards spaces as delimiters. If you start the example and enter a space followed by a digit, it displays <computeroutput>true</computeroutput>. Unlike the previous example, the parser <varname>boost::spirit::ascii::digit</varname> is not applied to the space, but to the first character that isn’t a space.</para>
    <para>Note that this example ignores any number of spaces. Thus, <function>boost::spirit::qi::phrase_parse</function> returns <literal>true</literal> if you enter multiple spaces followed by a digit.</para>
    <para>Like <function>boost::spirit::qi::parse</function>, <function>boost::spirit::qi::phrase_parse</function> modifies the iterator passed as the first parameter. That way, you know how far into the string the parser was able to work successfully. <xref linkend="ex.spirit_02" xrefstyle="enp"/> skips spaces that occur after successfully parsed characters. If you enter a digit followed by a space followed by a letter, the iterator will refer to the letter, not the space in front of it. If you want the iterator to refer to the space, pass <code>boost::spirit::qi::skip_flag::dont_postskip</code> as another parameter to <function>boost::spirit::qi::phrase_parse</function>.</para>
    <example xml:id="ex.spirit_03">
      <title><function>phrase_parse</function> with <code>boost::spirit::qi::skip_flag::dont_postskip</code></title>
      <programlisting><xi:include href="../src/spirit_03/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.spirit_03" xrefstyle="enp"/> passes <code>boost::spirit::qi::skip_flag::dont_postskip</code><indexterm><primary>spirit::qi::skip_flag::dont_postskip</primary></indexterm><indexterm><primary>dont_postskip, spirit::qi::skip_flag</primary></indexterm> to <function>boost::spirit::qi::phrase_parse</function> to tell the parser not to skip spaces that occur after a successfully parsed digit, but before the first unsuccessfully parsed character. If you enter a digit followed by a space followed by a letter, <varname>it</varname> refers to the space after the call to <function>boost::spirit::qi::phrase_parse</function>.</para>
    <para>The flag <code>boost::spirit::qi::skip_flag::postskip</code><indexterm><primary>spirit::qi::skip_flag::postskip</primary></indexterm><indexterm><primary>postskip, spirit::qi::skip_flag</primary></indexterm> is the default value, which is used if neither <code>boost::spirit::qi::skip_flag::dont_postskip</code> nor <code>boost::spirit::qi::skip_flag::postskip</code> is specified.</para>
    <example xml:id="ex.spirit_04">
      <title><function>boost::spirit::qi::phrase_parse</function> with wide strings</title>
      <programlisting><xi:include href="../src/spirit_04/main.cpp" parse="text"/></programlisting>
    </example>
    <para><function>boost::spirit::qi::parse</function> and <function>boost::spirit::qi::phrase_parse</function> accept iterators to a wide string. <xref linkend="ex.spirit_04" xrefstyle="enp"/> works like the previous example, except that wide strings are used.</para>
    <para>Boost.Spirit also supports the string types <classname>std::u16string</classname> and <classname>std::u32string</classname> from the C++11 standard library.</para>
  </sect1>
  <sect1 xml:id="boost.spirit-parsers">
    <title>Parsers</title>
    <para>This section explains how you define parsers. You usually access existing parsers from Boost.Spirit &#x2013; for example, <varname>boost::spirit::ascii::digit</varname> or <varname>boost::spirit::ascii::space</varname>. By combining parsers, you can parse more complex formats. The process is similar to defining regular expressions, which are also built from basic building blocks.</para>
    <example xml:id="ex.spirit_05">
      <title>A parser for two consecutive digits</title>
      <programlisting><xi:include href="../src/spirit_05/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.spirit_05" xrefstyle="enp"/> tests whether two digits are entered. <function>boost::spirit::qi::phrase_parse</function> only returns <literal>true</literal> if the two digits are consecutive. Spaces are ignored.</para>
    <para>As with the previous examples, <varname>boost::spirit::ascii::digit</varname> is used to recognize digits. Because <varname>boost::spirit::ascii::digit</varname> tests exactly one character, the parser is used twice to test the input for two digits. To use <varname>boost::spirit::ascii::digit</varname> twice in a row, an operator has to be used. Boost.Spirit overloads <methodname role="operator">operator&gt;&gt;</methodname> for parsers. With <code>ascii::digit &gt;&gt; ascii::digit</code> a parser is created that tests whether a string contains two digits.</para>
    <para>If you run the example and enter two digits, <computeroutput>true</computeroutput> is displayed. If you enter only one digit, the example displays <computeroutput>false</computeroutput>.</para>
    <para>Please note that the example also displays <computeroutput>true</computeroutput> if you enter a space between two digits. Wherever the operator <methodname role="operator">operator&gt;&gt;</methodname> is used in a parser, characters are allowed which are ignored by a skipper. Because <xref linkend="ex.spirit_05" xrefstyle="enp"/> uses <varname>boost::spirit::ascii::space</varname> as the skipper, you may enter as many spaces as you like between the two digits.</para>
    <para>If you want the parser to accept two digits only if they follow each other with no space in between, use <function>boost::spirit::qi::parse</function> or the directive <varname>boost::spirit::qi::lexeme</varname><indexterm><primary>spirit::qi::lexeme</primary></indexterm><indexterm><primary>lexeme, spirit::qi</primary></indexterm>.</para>
    <example xml:id="ex.spirit_06">
      <title>Parsing character by character with <varname>boost::spirit::qi::lexeme</varname></title>
      <programlisting><xi:include href="../src/spirit_06/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.spirit_06" xrefstyle="enp"/> uses the parser <code>qi::lexeme[ascii::digit &gt;&gt; ascii::digit]</code>. Now, <function>boost::spirit::qi::phrase_parse</function> only returns <literal>true</literal> if the digits have no spaces between them.</para>
    <para><varname>boost::spirit::qi::lexeme</varname> is one of several directives that can change the behavior of parsers. You use <varname>boost::spirit::qi::lexeme</varname> if you want to disallow characters that would be ignored by a skipper when <methodname role="operator">operator&gt;&gt;</methodname> is used.</para>
    <example xml:id="ex.spirit_07">
      <title>Boost.Spirit rules similar to regular expressions</title>
      <programlisting><xi:include href="../src/spirit_07/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.spirit_07" xrefstyle="enp"/> defines a parser with <code>+ascii::digit</code>, which expects at least one digit. This syntax, in particular the plus sign (+), is similar to that used in regular expressions. The plus sign identifies a character or character group which is expected to occur in a string at least once. If you start the example and enter at least one digit, <computeroutput>true</computeroutput> is displayed. It doesn’t matter whether digits are delimited by spaces. If the parser should accept only digits without spaces, use <varname>boost::spirit::qi::lexeme</varname> again.</para>
    <example xml:id="ex.spirit_08">
      <title>Numeric parsers</title>
      <programlisting><xi:include href="../src/spirit_08/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.spirit_08" xrefstyle="enp"/> expects an integer. <varname>boost::spirit::qi::int_</varname><indexterm><primary>spirit::qi::int_</primary></indexterm><indexterm><primary>int_, spirit::qi</primary></indexterm> is a numeric parser that can recognize positive and negative integers. Unlike <varname>boost::spirit::ascii::digit</varname>, <varname>boost::spirit::qi::int_</varname> can recognize several characters, such as +1 or -23, as integers.</para>
    <para>Boost.Spirit provides additional logical parsers. <varname>boost::spirit::qi::float_</varname><indexterm><primary>spirit::qi::float_</primary></indexterm><indexterm><primary>float_, spirit::qi</primary></indexterm>, <varname>boost::spirit::qi::double_</varname><indexterm><primary>spirit::qi::double_</primary></indexterm><indexterm><primary>double_, spirit::qi</primary></indexterm>, and <varname>boost::spirit::qi::bool_</varname><indexterm><primary>spirit::qi::bool_</primary></indexterm><indexterm><primary>bool_, spirit::qi</primary></indexterm> are numeric parsers that can read floating point numbers and boolean values. With <varname>boost::spirit::qi::eol</varname><indexterm><primary>spirit::qi::eol</primary></indexterm><indexterm><primary>eol, spirit::qi</primary></indexterm>, you can test for an end-of-line character. <varname>boost::spirit::qi::byte_</varname><indexterm><primary>spirit::qi::byte_</primary></indexterm><indexterm><primary>byte_, spirit::qi</primary></indexterm> and <varname>boost::spirit::qi::word</varname><indexterm><primary>spirit::qi::word</primary></indexterm><indexterm><primary>word, spirit::qi</primary></indexterm> can be used to read one or two bytes. <varname>boost::spirit::qi::word</varname> and other binary parsers recognize the endianness of a platform and parse accordingly. If you want to parse based on a specific endianness, regardless of the platform, you can use parsers like <varname>boost::spirit::qi::little_word</varname><indexterm><primary>spirit::qi::little_word</primary></indexterm><indexterm><primary>little_word, spirit::qi</primary></indexterm> and <varname>boost::spirit::qi::big_word</varname><indexterm><primary>spirit::qi::big_word</primary></indexterm><indexterm><primary>big_word, spirit::qi</primary></indexterm>.</para>
  </sect1>
  <sect1 xml:id="boost.spirit-actions">
    <title>Actions</title>
    <para>So far, the examples in this chapter only detect two things: whether the parser was successful and where the parse ended. However, parsers normally process data in some way, as you will see in the next examples.</para>
    <example xml:id="ex.spirit_09">
      <title>Linking actions with parsers</title>
      <programlisting><xi:include href="../src/spirit_09/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.spirit_09" xrefstyle="enp"/> uses <varname>boost::spirit::qi::int_</varname> to parse an integer, then writes that integer to standard output. That’s why an <emphasis role="concept">action</emphasis><indexterm><primary>action, Boost.Spirit</primary></indexterm> has been linked with <varname>boost::spirit::qi::int_</varname>. Actions are functions or function objects that are called when a parser is applied. Linking is done with the operator <methodname role="operator">operator[]</methodname>, which is overloaded by <varname>boost::spirit::qi::int_</varname> and other parsers. <xref linkend="ex.spirit_09" xrefstyle="enp"/> uses a lambda function as an action that expects a sole parameter of type <type>int</type> and writes it to standard output.</para>
    <para>If you start <xref linkend="ex.spirit_09" xrefstyle="enp"/> and enter a number, the number is displayed.</para>
    <para>The type of the parameter passed to an action depends on the parser. For example, <varname>boost::spirit::qi::int_</varname> forwards an <type>int</type> value, while <varname>boost::spirit::qi::float_</varname> passes a <type>float</type> value.</para>
    <example xml:id="ex.spirit_10">
      <title>Boost.Spirit with Boost.Phoenix</title>
      <programlisting><xi:include href="../src/spirit_10/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.spirit_10" xrefstyle="enp"/> uses Boost.Phoenix to store the <type>int</type> value parsed with <varname>boost::spirit::qi::int_</varname> in <varname>i</varname>. If <function>boost::spirit::qi::phrase_parse</function> returns <literal>true</literal>, <varname>i</varname> is written to standard output.</para>
    <para>This example defines the macro <code>BOOST_SPIRIT_USE_PHOENIX_V3</code><indexterm><primary>BOOST_SPIRIT_USE_PHOENIX_V3, Boost.Spirit</primary></indexterm> before including the header files from Boost.Spirit. This macro selects the third and current version of Boost.Phoenix. This is important because Boost.Phoenix was forked from Boost.Spirit, and Boost.Spirit contains the second version of Boost.Phoenix. If <code>BOOST_SPIRIT_USE_PHOENIX_V3</code> isn’t defined, the second version of Boost.Phoenix will be included through the Boost.Spirit header files and the third version through <filename class="headerfile">boost/phoenix/phoenix.hpp</filename>. The different versions will lead to a compiler error.</para>
    <para>Please note how the lambda function is defined in detail. <function>boost::phoenix::ref</function> creates a reference to the variable <varname>i</varname>. However, the placeholder <varname>_1</varname> isn’t from Boost.Phoenix, it’s from Boost.Spirit. This is important because <varname>boost::spirit::qi::_1</varname> provides access to the parsed value with the normally expected type &#x2013; <type>int</type> in <xref linkend="ex.spirit_10" xrefstyle="enp"/>. If the lambda function used <varname>boost::phoenix::placeholders::arg1</varname>, the compiler would report an error because <varname>boost::phoenix::placeholders::arg1</varname> wouldn’t represent an <type>int</type>; it would be based on another type from Boost.Spirit, and the <type>int</type> value would need to be extracted.</para>
    <para>The Boost.Spirit documentation contains an <link xlink:href="http://www.boost.org/libs/spirit/doc/html/spirit/qi/quick_reference/phoenix.html">overview on tools that support a Boost.Phoenix integration</link>.</para>
  </sect1>
  <sect1 xml:id="boost.spirit-attributes">
    <title>Attributes</title>
    <para>Actions are one option to process parsed values. Another option is to pass objects to <function>boost::spirit::qi::parse</function> or <function>boost::spirit::qi::phrase_parse</function> that will be used to store parsed values. These objects are called attributes. Their types must match the parsers’ types.</para>
    <para>You have already used attributes in the previous section. Parameters passed to actions are attributes, too. Every parser has an attribute. For example, the parser <varname>boost::spirit::qi::int_</varname> has an attribute of type <type>int</type>. In the following examples, attributes aren’t passed as parameters to functions. Instead, parsed values are stored in attributes and can be processed after <function>boost::spirit::qi::parse</function> or <function>boost::spirit::qi::phrase_parse</function> return.</para>
    <example xml:id="ex.spirit_11">
      <title>Storing an <type>int</type> value in an attribute</title>
      <programlisting><xi:include href="../src/spirit_11/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.spirit_11" xrefstyle="enp" /> uses the parser <varname>boost::spirit::qi::int_</varname>. The parsed <type>int</type> value is stored in the variable <varname>i</varname>. <varname>i</varname> is passed as another parameter to <function>boost::spirit::qi::phrase_parse</function> and, thus, becomes an attribute of the parser <varname>boost::spirit::qi::int_</varname>.</para>
    <para>If you start <xref linkend="ex.spirit_11" xrefstyle="enp"/> and enter a digit, the digit will be written to the standard output stream.</para>
    <example xml:id="ex.spirit_12">
      <title>Storing several <type>int</type> values in an attribute</title>
      <programlisting><xi:include href="../src/spirit_12/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.spirit_12" xrefstyle="enp"/> uses a parser that is defined with <code>qi::int_ % ','</code>. The parser accepts any number of integers delimited by commas. As usual spaces are ignored.</para>
    <para>Because the parser can return multiple <type>int</type> values, the attribute’s type must support storing multiple <type>int</type> values. The example passes a vector. If you start the example and enter multiple integers delimited by commas, the integers are written to the standard output stream delimited by semicolons.</para>
    <para>Instead of a vector, you can also pass containers of other types, such as <classname>std::list</classname>.</para>
    <para>The Boost.Spirit documentation describes <link xlink:href="http://www.boost.org/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/operator.html">which attribute types must be used with which operators</link>.</para>
  </sect1>
  <sect1 xml:id="boost.spirit-rules">
    <title>Rules</title>
    <para>In Boost.Spirit, parsers consist of rules. As rules are typically based on parsers provided by Boost.Spirit, there is no clear distinction. For example, <varname>boost::spirit::ascii::digit</varname> can be both a parser and a rule. Typically, rules refer to more complicated expressions like <code>qi::int_ % ','</code>.</para>
    <para>In all of the examples thus far, rules were passed to <function>boost::spirit::qi::parse</function> or <function>boost::spirit::qi::phrase_parse</function> directly. With <classname>boost::spirit::qi::rule</classname><indexterm><primary>spirit::qi::rule</primary></indexterm><indexterm><primary>rule, spirit::qi</primary></indexterm>, Boost.Spirit provides a class to define rule variables. For example, <classname>boost::spirit::qi::rule</classname> is required if a rule should be stored in a member variable of a class.</para>
    <example xml:id="ex.spirit_13">
      <title>Defining rules with <classname>boost::spirit::qi::rule</classname></title>
      <programlisting><xi:include href="../src/spirit_13/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.spirit_13" xrefstyle="enp"/> works like <xref linkend="ex.spirit_12" xrefstyle="enp" />. If you enter multiple integers delimited by commas, they are displayed with semicolons. In contrast to the previous example, the parser isn’t passed directly to <function>boost::spirit::qi::phrase_parse</function>, but defined in a <classname>boost::spirit::qi::rule</classname> variable.</para>
    <para><classname>boost::spirit::qi::rule</classname> is a class template. The only mandatory parameter is the iterator type of the string being parsed. In the example, two more optional template parameters are also passed.</para>
    <para>The second template parameter is <type>std::vector&lt;int&gt;()</type>, which is the signature of a function that returns a vector of type <type>std::vector&lt;int&gt;</type> and expects no parameter. This template parameter indicates that the type of the attribute parsed is an <type>int</type> vector.</para>
    <para>The third template parameter is the type of the skipper used by <function>boost::spirit::qi::phrase_parse</function>. In the example, the skipper <varname>boost::spirit::ascii::space</varname> is used. The type of this skipper is available through <classname>boost::spirit::ascii::space_type</classname><indexterm><primary>spirit::ascii::space_type</primary></indexterm><indexterm><primary>space_type, spirit::ascii</primary></indexterm> and is passed as a template parameter to <classname>boost::spirit::qi::rule</classname>.</para>
    <note>
      <para>If you want your code to be platform independent and work with a C++11 development environment, you should prefer <classname>boost::spirit::qi::rule</classname> over the keyword <code>auto</code>. If <varname>values</varname> is defined with <code>auto</code>, the example works as expected with GCC and Clang. However with Visual C++ 2013, only the first number is parsed and written to standard output.</para>
    </note>
    <example xml:id="ex.spirit_14">
      <title>Nesting Rules</title>
      <programlisting><xi:include href="../src/spirit_14/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.spirit_14" xrefstyle="enp"/> defines two rules, one of which refers to the other: <varname>values</varname> is defined as <code>value % ','</code>, and <varname>value</varname> is set to <code>qi::int_ | qi::bool_</code>. <varname>values</varname> says that any number of values delimited by commas can be parsed. <varname>value</varname> defines a value as an integer or bool. Together, the rules say that integers and boolean values separated with commas can be entered in any order.</para>
    <para>To store any number of values, a container of type <classname>std::vector</classname> is provided. Because the type of the values is either <type>int</type> or <type>bool</type>, a class is required that can store an <type>int</type> or a <type>bool</type> value. According to the <link xlink:href="http://www.boost.org/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/operator.html">overview on attribute types and operators</link>, the class <classname>boost::variant</classname> from Boost.Variant must be used.</para>
    <para>If you start the example and enter integers and boolean values delimited by commas, the values are written to the standard output stream delimited by semicolons. This is accomplished with the help of the function <function>boost::apply_visitor</function>, which is provided by Boost.Variant. This function expects a visitor &#x2013; an object of the class <classname>print</classname> in this example.</para>
    <para>Please note that boolean values must be entered as <userinput>true</userinput> and <userinput>false</userinput>.</para>
  </sect1>
  <sect1 xml:id="boost.spirit-grammar">
    <title>Grammar</title>
    <para>If you want to parse complex formats and need to define multiple rules that refer to each other, you can group them with <classname>boost::spirit::qi::grammar</classname><indexterm><primary>spirit::qi::grammar</primary></indexterm><indexterm><primary>grammar, spirit::qi</primary></indexterm>.</para>
    <example xml:id="ex.spirit_15">
      <title>Grouping rules in a grammar</title>
      <programlisting><xi:include href="../src/spirit_15/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.spirit_15" xrefstyle="enp"/> works like <xref linkend="ex.spirit_14" xrefstyle="enp" />: you can enter integers and boolean values in any order, delimited by commas. They will be written to the standard output stream in the same order, but delimited by semicolons. The example uses the same rules &#x2013; <varname>value</varname> and <varname>values</varname> &#x2013; as the previous one. However, this time the rules are grouped in a grammar. The grammar is defined in a class called <classname>my_grammar</classname>, which is derived from <classname>boost::spirit::qi::grammar</classname>.</para>
    <para>Both <classname>my_grammar</classname> and <classname>boost::spirit::qi::grammar</classname> are class templates. The template parameters expected by <classname>boost::spirit::qi::grammar</classname> are the same as those expected by <classname>boost::spirit::qi::rule</classname>. The iterator type of the string to be parsed has to be passed to <classname>boost::spirit::qi::grammar</classname>. You can also pass the signature of a function that defines the attribute type and the type of the skipper.</para>
    <para>In <classname>my_grammar</classname>, <classname>boost::spirit::qi::rule</classname> is used to define the rules <varname>value</varname> and <varname>values</varname>. The rules are defined as member variables and are initialized in the constructor.</para>
    <para>Please note that the outermost rule has to be passed with <type>base_type</type> to the constructor of the base class. This way, Boost.Spirit knows which rule is the entry point of the grammar.</para>
    <para>Once a grammar is defined, it can be used like a parser. In <xref linkend="ex.spirit_15" xrefstyle="enp"/>, <classname>my_grammar</classname> is instantiated in <function>main</function> to create <varname>g</varname>. <varname>g</varname> is then passed to <function>boost::spirit::qi::phrase_parse</function>.</para>
    <example xml:id="ex.spirit_16">
      <title>Storing parsed values in structures</title>
      <programlisting><xi:include href="../src/spirit_16/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.spirit_16" xrefstyle="enp"/> is based on the previous example, but expects at least two values. The rule <varname>values</varname> is defined as <code>value &gt;&gt; ',' &gt;&gt; value % ','</code>.</para>
    <para>The first component in <varname>values</varname> is <code>value</code>, and the second one is <code>value % ','</code>. The value parsed by the first component has to be stored in an object of type <classname>boost::variant</classname>. The values parsed by the second component have to be stored in a container. With <classname>int_or_bool_values</classname>, the example provides a structure to store values parsed by both components of the rule <varname>values</varname>.</para>
    <para>To use <classname>int_or_bool_values</classname> with Boost.Spirit, the macro <code>BOOST_FUSION_ADAPT_STRUCT</code> must be used. This macro is provided by Boost.Fusion. This macro makes it possible to treat <classname>int_or_bool_values</classname> like a tuple with two values of type <type>int_or_bool</type> and <type>std::vector&lt;int_or_bool&gt;</type>. Because this tuple has the right number of values with the right types, it is possible to define <varname>values</varname> with the signature <code>int_or_bool_values()</code>. <varname>values</varname> will store the first parsed value in <varname>first</varname> and all other parsed values in <varname>others</varname>.</para>
    <para>An object of type <classname>int_or_bool_values</classname> is passed to <function>boost::spirit::qi::phrase_parse</function> as an attribute. If you start the example and enter at least two integers or boolean values delimited by commas, they are all stored in the attribute and written to the standard output stream.</para>
    <note>
      <para>The parser has been changed from what was used in the previous example. If <varname>values</varname> was defined with <code>value % ','</code>, <classname>int_or_bool_values</classname> would have only one member variable, and all parsed values could be stored in a vector, as in the previous example. Thus, <classname>int_or_bool_values</classname> would be like a tuple with only one value &#x2013; which Boost.Spirit doesn’t support. Structures with only one member variable will cause a compiler error. There are various <link xlink:href="http://stackoverflow.com/questions/19823413/spirit-qi-attribute-propagation-issue-with-single-member-struct">workarounds</link> for that problem.</para>
    </note>
    <simplesect role="exercises" xml:id="boost.spirit-grammar-exercises">
      <title>Exercises</title>
      <orderedlist>
        <listitem><para>Create a parser that can add and subtract integers. The parser should be able to process input like 1+2-5+8 and write the result &#x2013; here 6 &#x2013; to standard output.</para></listitem>
        <listitem><para>Extend your parser: It should now also support floating point numbers. Furthermore, it should be possible to use fractions. The new parser should be able to process input like 1.2+6/5-0.9 and should write the result &#x2013; here 1.5 &#x2013; to standard output.</para></listitem>
      </orderedlist>
    </simplesect>
  </sect1>
</chapter>
