<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.multiarray">
  <title>Boost.MultiArray</title><indexterm><primary>Boost.MultiArray</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/multi_array">Boost.MultiArray</link> is a library that simplifies using arrays with multiple dimensions. The most important advantage is that multidimensional arrays can be used like containers from the standard library. For example, there are member functions, such as <methodname>begin</methodname> and <methodname>end</methodname>, that let you access elements in multidimensional arrays through iterators. Iterators are easier to use than the pointers normally used with C arrays, especially with arrays that have many dimensions.</para>
  <example xml:id="ex.multiarray_01">
    <title>One-dimensional array with <classname>boost::multi_array</classname></title>
    <programlisting><xi:include href="../src/multiarray_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Boost.MultiArray provides the class <classname>boost::multi_array</classname><indexterm><primary>multi_array, Boost.MultiArray</primary></indexterm> to create arrays. This is the most important class provided. It is defined in <filename class="headerfile">boost/multi_array.hpp</filename>.</para>
  <para><classname>boost::multi_array</classname> is a template expecting two parameters: The first parameter is the type of the elements to store in the array. The second parameter determines how many dimensions the array should have.</para>
  <para>The second parameter only sets the number of dimensions, not the number of elements in each dimension. Thus, in <xref linkend="ex.multiarray_01" xrefstyle="enp"/>, <varname>a</varname> is a one-dimensional array.</para>
  <para>The number of elements in a dimension is set at runtime. <xref linkend="ex.multiarray_01" xrefstyle="enp"/> uses the global object <varname>boost::extents</varname><indexterm><primary>extents, Boost.MultiArray</primary></indexterm> to set dimension sizes. This object is passed to the constructor of <varname>a</varname>.</para>
  <para>An object of type <classname>boost::multi_array</classname> can be used like a normal C array. Elements are accessed by passing an index to <methodname role="operator">operator[]</methodname>. <xref linkend="ex.multiarray_01" xrefstyle="enp"/> stores five letters and a null character in <varname>a</varname> &#x2013; a one-dimensional array with six elements. <methodname>origin</methodname><indexterm><primary>multi_array::origin</primary></indexterm><indexterm><primary>origin, multi_array</primary></indexterm> returns a pointer to the first element. The example uses this pointer to write the word stored in the array &#x2013; <computeroutput>Boost</computeroutput> &#x2013; to standard output.</para>
  <para>Unlike containers from the standard library, <methodname role="operator">operator[]</methodname> checks whether an index is valid. If an index is not valid, the program exits with <function>std::abort</function>. If you don’t want the validity of indexes to be checked, define the macro <code>BOOST_DISABLE_ASSERTS</code><indexterm><primary>BOOST_DISABLE_ASSERTS, Boost.MultiArray</primary></indexterm> before you include <filename class="headerfile">boost/multi_array.hpp</filename>.</para>
  <example xml:id="ex.multiarray_02">
    <title>Views and subarrays of a two-dimensional array</title>
    <programlisting><xi:include href="../src/multiarray_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.multiarray_02" xrefstyle="enp"/> creates a two-dimensional array. The number of elements in the first dimension is set to 2 and for the second dimension set to 6. Think of the array as a table with two rows and six columns.</para>
  <para>The first row of the table will contain the word Boost. Since only five letters need to be stored for this word, a <emphasis role="concept">view</emphasis><indexterm><primary>view, Boost.MultiArray</primary></indexterm> is created which spans exactly five elements of the array.</para>
  <para>A view, which is based on the class <classname>boost::multi_array::array_view</classname><indexterm><primary>multi_array::array_view</primary></indexterm><indexterm><primary>array_view, multi_array</primary></indexterm>, lets you access a part of an array and treat that part as though it were a separate array.</para>
  <para><classname>boost::multi_array::array_view</classname> is a template that expects the number of dimensions in the view as a template parameter. In <xref linkend="ex.multiarray_02" xrefstyle="enp"/> the number of dimensions for the view is 1. Because the array <varname>a</varname> has two dimensions, one dimension is ignored. To save the word Boost, a one-dimensional array is sufficient; more dimensions would be confusing.</para>
  <para>As with <classname>boost::multi_array</classname>, the number of dimensions is passed in as a template parameter, and the size of each dimension is set at runtime. However, with <classname>boost::multi_array::array_view</classname> this isn’t done with <varname>boost::extents</varname>. Instead it’s done with <varname>boost::indices</varname><indexterm><primary>indices, Boost.MultiArray</primary></indexterm>, which is another global object provided by Boost.MultiArray.</para>
  <para>As with <varname>boost::extents</varname>, indexes must be passed to <varname>boost::indices</varname>. While only numbers may be passed to <varname>boost::extents</varname>, <varname>boost::indices</varname> accepts also ranges. These are defined using <classname>boost::multi_array_types::index_range</classname><indexterm><primary>multi_array_types::index_range</primary></indexterm><indexterm><primary>index_range, multi_array_types</primary></indexterm>.</para>
  <para>In <xref linkend="ex.multiarray_02" xrefstyle="enp"/>, the first parameter passed to <varname>boost::indices</varname> isn’t a range, it’s the number 0. When a number is passed, you cannot use <classname>boost::multi_array_types::index_range</classname>. In the example, the view will take the first dimension of <varname>a</varname> &#x2013; the one with index 0.</para>
  <para>For the second parameter, <classname>boost::multi_array_types::index_range</classname> is used to define a range. By passing 0 and 5 to the constructor, the first five elements of the first dimension of <varname>a</varname> are made available. The range starts at index 0 and ends at index 5 &#x2013; excluding the element at index 5. The sixth element in the first dimension is ignored.</para>
  <para>Thus, <varname>view</varname> is a one-dimensional array consisting of five elements &#x2013; the first five elements in the first row of <varname>a</varname>. When <varname>view</varname> is accessed to copy a string with <function>std::memcpy</function> and reverse the elements with <function>std::reverse</function>, this relation doesn’t matter. Once the view is created, it acts like an independent array with five elements.</para>
  <para>When <methodname role="operator">operator[]</methodname> is called on an array of type <classname>boost::multi_array</classname>, the return value depends on the number of dimensions. In <xref linkend="ex.multiarray_01" xrefstyle="ewp"/>, the operator returns <type>char</type> elements because the array accessed is one dimensional.</para>
  <para>In <xref linkend="ex.multiarray_02" xrefstyle="enp"/>, <varname>a</varname> is a two-dimensional array. Thus, <methodname role="operator">operator[]</methodname> returns a subarray rather than a <type>char</type> element. Because the type of the subarray isn’t public, <classname>boost::multi_array::reference</classname><indexterm><primary>multi_array::reference</primary></indexterm><indexterm><primary>reference, multi_array</primary></indexterm> must be used. This type isn’t identical to <classname>boost::multi_array::array_view</classname>, even if the subarray behaves like a view. A view must be defined explicitly and can span arbitrary parts of an array, whereas a subarray is automatically returned by <methodname role="operator">operator[]</methodname> and spans all elements in every dimension.</para>
  <example xml:id="ex.multiarray_03">
    <title>Wrapping a C array with <classname>boost::multi_array_ref</classname></title>
    <programlisting><xi:include href="../src/multiarray_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para>The class <classname>boost::multi_array_ref</classname><indexterm><primary>multi_array_ref, Boost.MultiArray</primary></indexterm> wraps an existing C array. In <xref linkend="ex.multiarray_03" xrefstyle="enp" />, <varname>a</varname> provides the same interface as <classname>boost::multi_array</classname>, but without allocating memory. With <classname>boost::multi_array_ref</classname>, a C array &#x2013; no matter how many dimensions it has &#x2013; can be treated like a multidimensional array of type <classname>boost::multi_array</classname>. The C array just needs to be added as an additional parameter to the constructor.</para>
  <para>Boost.MultiArray also provides the class <classname>boost::const_multi_array_ref</classname><indexterm><primary>const_multi_array_ref, Boost.MultiArray</primary></indexterm>, which treats a C array as a constant multidimensional array.</para>
</chapter>
