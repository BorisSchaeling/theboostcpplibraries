<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.unordered">
  <title>Boost.Unordered</title><indexterm><primary>Boost.Unordered</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/unordered">Boost.Unordered</link> provides the classes <classname>boost::unordered_set</classname><indexterm><primary>unordered_set Boost.Unordered</primary></indexterm>, <classname>boost::unordered_multiset</classname><indexterm><primary>unordered_multiset, Boost.Unordered</primary></indexterm>, <classname>boost::unordered_map</classname><indexterm><primary>unordered_map, Boost.Unordered</primary></indexterm>, and <classname>boost::unordered_multimap</classname><indexterm><primary>unordered_multimap, Boost.Unordered</primary></indexterm>. These classes are identical to the hash containers that were added to the standard library with C++11. Thus, you can ignore the containers from Boost.Unordered if you work with a development environment supporting C++11.</para>
  <example xml:id="ex.unordered_01">
    <title>Using <classname>boost::unordered_set</classname></title>
    <programlisting><xi:include href="../src/unordered_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><classname>boost::unordered_set</classname> can be replaced with <classname>std::unordered_set</classname> in <xref linkend="ex.unordered_01" xrefstyle="enp"/>. <classname>boost::unordered_set</classname> doesn’t differ from <classname>std::unordered_set</classname>.</para>
  <example xml:id="ex.unordered_02">
    <title>Using <classname>boost::unordered_map</classname></title>
    <programlisting><xi:include href="../src/unordered_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.unordered_02" xrefstyle="enp"/> uses <classname>boost::unordered_map</classname> to store the names and the number of legs for several animals. Once again, <classname>boost::unordered_map</classname> could be replaced with <classname>std::unordered_map</classname>.</para>
  <example xml:id="ex.unordered_03">
    <title>User-defined type with Boost.Unordered</title>
    <programlisting><xi:include href="../src/unordered_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para>In <xref linkend="ex.unordered_03" xrefstyle="enp"/> elements of type <classname>animal</classname> are stored in a container of type <classname>boost::unordered_set</classname>. Because the hash function of <classname>boost::unordered_set</classname> doesn’t know the class <classname>animal</classname>, hash values can’t be automatically calculated for elements of this type. That’s why a hash function must be defined &#x2013; otherwise the example can’t be compiled.</para>
  <para>The name of the hash function to define is <function>hash_value</function>. It must expect as its sole parameter an object of the type the hash value should be calculated for. The type of the return value of <function>hash_value</function> must be <type>std::size_t</type>.</para>
  <para>The function <function>hash_value</function> is automatically called when the hash value has to be calculated for an object. This function is defined for various types in the Boost libraries, including <classname>std::string</classname>. For user-defined types like <classname>animal</classname>, it must be defined by the developer.</para>
  <para>Usually, the definition of <function>hash_value</function> is rather simple: Hash values are created by accessing the member variables of an object one after another. This is done with the function <function>boost::hash_combine</function><indexterm><primary>hash_combine, Boost.Unordered</primary></indexterm>, which is provided by Boost.Hash and defined in <filename class="headerfile">boost/functional/hash.hpp</filename>. You don’t have to include this header file if you use Boost.Unordered because all containers from this library access Boost.Hash to calculate hash values.</para>
  <para>In addition to defining <function>hash_value</function>, you need to make sure two objects can be compared using <code>==</code>. That’s why the operator <methodname role="operator">operator==</methodname> is overloaded for <classname>animal</classname> in <xref linkend="ex.unordered_03" xrefstyle="enp"/>.</para>
  <para>The hash containers from the C++11 standard library use a hash function from the header file <filename class="headerfile">functional</filename>. The hash containers from Boost.Unordered expect the hash function <function>hash_value</function>. Whether you use Boost.Hash within <function>hash_value</function> doesn’t matter. Boost.Hash makes sense because functions like <function>boost::hash_combine</function> make it easier to calculate hash values from multiple member variables step by step. However, this is only an implementation detail of <function>hash_value</function>. Apart from the different hash functions used, the hash containers from Boost.Unordered and the standard library are basically equivalent.</para>
</chapter>
