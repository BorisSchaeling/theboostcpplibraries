<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.stringalgorithms">
  <title>Boost.StringAlgorithms</title><indexterm><primary>Boost.StringAlgorithms</primary></indexterm>
  <para>The <link xlink:href="http://www.boost.org/libs/algorithm/string">Boost.StringAlgorithms</link> library provides many free-standing functions for string manipulation. Strings can be of type <classname>std::string</classname>, <classname>std::wstring</classname>, or any other instance of the class template <classname>std::basic_string</classname>. This includes the string classes <classname>std::u16string</classname> and <classname>std::u32string</classname> introduced with C++11.</para>
  <para>The functions are categorized within different header files. For example, functions converting from uppercase to lowercase are defined in <filename class="headerfile">boost/algorithm/string/case_conv.hpp</filename>. Because Boost.StringAlgorithms consists of more than 20 different categories and as many header files, <filename class="headerfile">boost/algorithm/string.hpp</filename> acts as the common header including all other header files for convenience.</para>
  <example xml:id="ex.stringalgorithms_01">
    <title>Converting strings to uppercase</title>
    <programlisting><xi:include href="../src/stringalgorithms_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para>The function <function>boost::algorithm::to_upper_copy</function><indexterm><primary>algorithm::to_upper_copy</primary></indexterm><indexterm><primary>to_upper_copy, algorithm</primary></indexterm> converts a string to uppercase, and <function>boost::algorithm::to_lower_copy</function><indexterm><primary>algorithm::to_lower_copy</primary></indexterm><indexterm><primary>to_lower_copy, algorithm</primary></indexterm> converts a string to lowercase. Both functions return a copy of the input string, converted to the specified case. To convert the string in place, use the functions <function>boost::algorithm::to_upper</function><indexterm><primary>algorithm::to_upper</primary></indexterm><indexterm><primary>to_upper, algorithm</primary></indexterm> or <function>boost::algorithm::to_lower</function><indexterm><primary>algorithm::to_lower</primary></indexterm><indexterm><primary>to_lower, algorithm</primary></indexterm>.</para>
  <para><xref linkend="ex.stringalgorithms_01" xrefstyle="enp"/> converts the string <quote>Boost C++ Libraries</quote> to uppercase using <function>boost::algorithm::to_upper_copy</function>. The example writes <computeroutput>BOOST C++ LIBRARIES</computeroutput> to standard output.</para>
  <para>Functions from Boost.StringAlgorithms consider locales. Functions like <function>boost::algorithm::to_upper_copy</function> use the global locale if no locale is passed explicitly as a parameter.</para>
  <example xml:id="ex.stringalgorithms_02">
    <title>Converting a string to uppercase with a locale</title>
    <programlisting><xi:include href="../src/stringalgorithms_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.stringalgorithms_02" xrefstyle="enp"/> calls <function>boost::algorithm::to_upper_copy</function> twice to convert the Turkish string <quote>Boost C++ kütüphaneleri</quote> to uppercase. The first call to <function>boost::algorithm::to_upper_copy</function> uses the global locale, which in this case is the C locale. In the C locale, there is no uppercase mapping for characters with umlauts, so the output will look like this: <computeroutput>BOOST C++ KüTüPHANELERI</computeroutput>.</para>
  <para>The Turkish locale is passed to the second call to <function>boost::algorithm::to_upper_copy</function>. Since this locale does have uppercase equivalents for umlauts, the entire string can be converted to uppercase. Therefore, the second call to <function>boost::algorithm::to_upper_copy</function> correctly converts the string, which looks like this: <computeroutput>BOOST C++ KÜTÜPHANELERI</computeroutput>.</para>
  <note>
    <para>If you want to run the example on a POSIX operating system, replace <quote>Turkish</quote> with <quote>tr_TR</quote>, and make sure the Turkish locale is installed.</para>
  </note>
  <example xml:id="ex.stringalgorithms_03">
    <title>Algorithms to remove characters from a string</title>
    <programlisting><xi:include href="../src/stringalgorithms_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Boost.StringAlgorithms provides several functions you can use to delete individual characters from a string (see <xref linkend="ex.stringalgorithms_03" xrefstyle="enp"/>). For example, <function>boost::algorithm::erase_all_copy</function><indexterm><primary>algorithm::erase_all_copy</primary></indexterm><indexterm><primary>erase_all_copy, algorithm</primary></indexterm> will remove all occurrences of a particular character from a string. To remove only the first occurrence of the character, use <function>boost::algorithm::erase_first_copy</function><indexterm><primary>algorithm::erase_first_copy</primary></indexterm><indexterm><primary>erase_first_copy, algorithm</primary></indexterm> instead. To shorten a string by a specific number of characters on either end, use the functions <function>boost::algorithm::erase_head_copy</function><indexterm><primary>algorithm::erase_head_copy</primary></indexterm><indexterm><primary>erase_head_copy, algorithm</primary></indexterm> and <function>boost::algorithm::erase_tail_copy</function><indexterm><primary>algorithm::erase_tail_copy</primary></indexterm><indexterm><primary>erase_tail_copy, algorithm</primary></indexterm>.</para>
  <example xml:id="ex.stringalgorithms_04">
    <title>Searching for substrings with <function>boost::algorithm::find_first</function></title>
    <programlisting><xi:include href="../src/stringalgorithms_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Functions such as <function>boost::algorithm::find_first</function><indexterm><primary>algorithm::find_first</primary></indexterm><indexterm><primary>find_first, algorithm</primary></indexterm>, <function>boost::algorithm::find_last</function><indexterm><primary>algorithm::find_last</primary></indexterm><indexterm><primary>find_last, algorithm</primary></indexterm>, <function>boost::algorithm::find_nth</function><indexterm><primary>algorithm::find_nth</primary></indexterm><indexterm><primary>find_nth, algorithm</primary></indexterm>, <function>boost::algorithm::find_head</function><indexterm><primary>algorithm::find_head</primary></indexterm><indexterm><primary>find_head, algorithm</primary></indexterm> and <function>boost::algorithm::find_tail</function><indexterm><primary>algorithm::find_tail</primary></indexterm><indexterm><primary>find_tail, algorithm</primary></indexterm> are available to find strings within strings.</para>
  <para>All of these functions return a pair of iterators of type <classname>boost::iterator_range</classname><indexterm><primary>iterator_range, Boost.StringAlgorithms</primary></indexterm>. This class originates from Boost.Range, which implements a range concept based on the iterator concept. Because the operator <methodname role="operator">operator&lt;&lt;</methodname> is overloaded for <classname>boost::iterator_range</classname>, the result of the individual search algorithm can be written directly to standard output. <xref linkend="ex.stringalgorithms_04" xrefstyle="enp"/> prints <computeroutput>C++</computeroutput> for the first result and an empty string for the second one.</para>
  <example xml:id="ex.stringalgorithms_05">
    <title>Concatenating strings with <function>boost::algorithm::join</function></title>
    <programlisting><xi:include href="../src/stringalgorithms_05/main.cpp" parse="text"/></programlisting>
  </example>
  <para>A container of strings is passed as the first parameter to the function <function>boost::algorithm::join</function>,<indexterm><primary>algorithm::join</primary></indexterm><indexterm><primary>join, algorithm</primary></indexterm> which concatenates them separated by the second parameter. <xref linkend="ex.stringalgorithms_05" xrefstyle="enp"/> will output <computeroutput>Boost C++ Libraries</computeroutput>.</para>
  <example xml:id="ex.stringalgorithms_06">
    <title>Algorithms to replace characters in a string</title>
    <programlisting><xi:include href="../src/stringalgorithms_06/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Like the functions for searching strings or removing characters from strings, Boost.StringAlgorithms also provides functions for replacing substrings within a string. These include the following functions: <function>boost::algorithm::replace_first_copy</function><indexterm><primary>algorithm::replace_first_copy</primary></indexterm><indexterm><primary>replace_first_copy, algorithm</primary></indexterm>, <function>boost::algorithm::replace_nth_copy</function><indexterm><primary>algorithm::replace_nth_copy</primary></indexterm><indexterm><primary>replace_nth_copy, algorithm</primary></indexterm>, <function>boost::algorithm::replace_last_copy</function><indexterm><primary>algorithm::replace_last_copy</primary></indexterm><indexterm><primary>replace_last_copy, algorithm</primary></indexterm>, <function>boost::algorithm::replace_all_copy</function><indexterm><primary>algorithm::replace_all_copy</primary></indexterm><indexterm><primary>replace_all_copy, algorithm</primary></indexterm>, <function>boost::algorithm::replace_head_copy</function><indexterm><primary>algorithm::replace_head_copy</primary></indexterm><indexterm><primary>replace_head_copy, algorithm</primary></indexterm> and <function>boost::algorithm::replace_tail_copy</function><indexterm><primary>algorithm::replace_tail_copy</primary></indexterm><indexterm><primary>replace_tail_copy, algorithm</primary></indexterm>. They can be applied in the same way as the functions for searching and removing, except they require an additional parameter &#x2013; the replacement string (see <xref linkend="ex.stringalgorithms_06" xrefstyle="enp"/>).</para>
  <example xml:id="ex.stringalgorithms_07">
    <title>Algorithms to trim strings</title>
    <programlisting><xi:include href="../src/stringalgorithms_07/main.cpp" parse="text"/></programlisting>
  </example>
  <para>To remove spaces on either end of a string, use <function>boost::algorithm::trim_left_copy</function><indexterm><primary>algorithm::trim_left_copy</primary></indexterm><indexterm><primary>trim_left_copy, algorithm</primary></indexterm>, <function>boost::algorithm::trim_right_copy</function><indexterm><primary>algorithm::trim_right_copy</primary></indexterm><indexterm><primary>trim_right_copy, algorithm</primary></indexterm> and <function>boost::algorithm::trim_copy</function><indexterm><primary>algorithm::trim_copy</primary></indexterm><indexterm><primary>trim_copy, algorithm</primary></indexterm> (see <xref linkend="ex.stringalgorithms_07" xrefstyle="enp"/>). The global locale determines which characters are considered to be spaces.</para>
  <para>Boost.StringAlgorithms lets you provide a predicate as an additional parameter for different functions to determine which characters of the string the function is applied to. The versions with predicates are: <function>boost::algorithm::trim_right_copy_if</function><indexterm><primary>algorithm::trim_left_copy_if</primary></indexterm><indexterm><primary>trim_left_copy_if, algorithm</primary></indexterm>, <function>boost::algorithm::trim_left_copy_if</function><indexterm><primary>algorithm::trim_right_copy_if</primary></indexterm><indexterm><primary>trim_right_copy_if, algorithm</primary></indexterm>, and <function>boost::algorithm::trim_copy_if</function><indexterm><primary>algorithm::trim_copy_if</primary></indexterm><indexterm><primary>trim_copy_if, algorithm</primary></indexterm>.</para>
  <example xml:id="ex.stringalgorithms_08">
    <title>Creating predicates with <function>boost::algorithm::is_any_of</function></title>
    <programlisting><xi:include href="../src/stringalgorithms_08/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.stringalgorithms_08" xrefstyle="enp"/> uses another function called <function>boost::algorithm::is_any_of</function><indexterm><primary>algorithm::is_any_of</primary></indexterm><indexterm><primary>is_any_of, algorithm</primary></indexterm>, which is a helper function to create a predicate that checks whether a certain character &#x2013; passed as parameter to <function>is_any_of</function> &#x2013; exists in a string. With <function>boost::algorithm::is_any_of</function>, the characters for trimming a string can be specified. <xref linkend="ex.stringalgorithms_08" xrefstyle="enp"/> uses the hyphen character.</para>
  <para>Boost.StringAlgorithms provides many helper functions that return commonly used predicates.</para>
  <example xml:id="ex.stringalgorithms_09">
    <title>Creating predicates with <function>boost::algorithm::is_digit</function></title>
    <programlisting><xi:include href="../src/stringalgorithms_09/main.cpp" parse="text"/></programlisting>
  </example>
  <para>The predicate returned by <function>boost::algorithm::is_digit</function><indexterm><primary>algorithm::is_digit</primary></indexterm><indexterm><primary>is_digit, algorithm</primary></indexterm> tests whether a character is numeric. In <xref linkend="ex.stringalgorithms_09" xrefstyle="enp"/>, <function>boost::algorithm::is_digit</function> is used to remove digits from the string <varname>s</varname>.</para>
  <para>Boost.StringAlgorithms also provides helper functions to check whether a character is uppercase or lowercase: <function>boost::algorithm::is_upper</function><indexterm><primary>algorithm::is_upper</primary></indexterm><indexterm><primary>is_upper, algorithm</primary></indexterm> and <function>boost::algorithm::is_lower</function><indexterm><primary>algorithm::is_lower</primary></indexterm><indexterm><primary>is_lower, algorithm</primary></indexterm>. All of these functions use the global locale by default, unless you pass in a different locale as a parameter.</para>
  <para>Besides the predicates that verify individual characters of a string, Boost.StringAlgorithms also offers functions that work with strings instead (see <xref linkend="ex.stringalgorithms_10" xrefstyle="enp"/>).</para>
  <example xml:id="ex.stringalgorithms_10">
    <title>Algorithms to compare strings with others</title>
    <programlisting><xi:include href="../src/stringalgorithms_10/main.cpp" parse="text"/></programlisting>
  </example>
  <para>The <function>boost::algorithm::starts_with</function><indexterm><primary>algorithm::starts_with</primary></indexterm><indexterm><primary>starts_with, algorithm</primary></indexterm>, <function>boost::algorithm::ends_with</function><indexterm><primary>algorithm::ends_with</primary></indexterm><indexterm><primary>ends_with, algorithm</primary></indexterm>, <function>boost::algorithm::contains</function><indexterm><primary>algorithm::contains</primary></indexterm><indexterm><primary>contains, algorithm</primary></indexterm>, and <function>boost::algorithm::lexicographical_compare</function><indexterm><primary>algorithm::lexicographical_compare</primary></indexterm><indexterm><primary>lexicographical_compare, algorithm</primary></indexterm> functions compare two individual strings.</para>
  <para><xref linkend="ex.stringalgorithms_11" xrefstyle="enp"/> introduces a function that splits a string into smaller parts.</para>
  <example xml:id="ex.stringalgorithms_11">
    <title>Splitting strings with <function>boost::algorithm::split</function></title>
    <programlisting><xi:include href="../src/stringalgorithms_11/main.cpp" parse="text"/></programlisting>
  </example>
  <para>With <function>boost::algorithm::split</function><indexterm><primary>algorithm::split</primary></indexterm><indexterm><primary>split, algorithm</primary></indexterm>, a given string can be split based on a delimiter. The substrings are stored in a container. The function requires as its third parameter a predicate that tests each character and checks whether the string should be split at the given position. <xref linkend="ex.stringalgorithms_11" xrefstyle="enp"/> uses the helper function <function>boost::algorithm::is_space</function><indexterm><primary>algorithm::is_space</primary></indexterm><indexterm><primary>is_space, algorithm</primary></indexterm> to create a predicate that splits the string at every space character.</para>
  <para>Many of the functions introduced in this chapter have versions that ignore the case of the string. These versions typically have the same name, except for a leading <quote>i</quote>. For example, the equivalent function to <function>boost::algorithm::erase_all_copy</function> is <function>boost::algorithm::ierase_all_copy</function><indexterm><primary>algorithm::ierase_all_copy</primary></indexterm><indexterm><primary>ierase_all_copy, algorithm</primary></indexterm>.</para>
  <para>Finally, many functions of Boost.StringAlgorithms also support regular expressions. <xref linkend="ex.stringalgorithms_12" xrefstyle="enp"/> uses the function <function>boost::algorithm::find_regex</function><indexterm><primary>algorithm::find_regex</primary></indexterm><indexterm><primary>find_regex, algorithm</primary></indexterm> to search for a regular expression.</para>
  <example xml:id="ex.stringalgorithms_12">
    <title>Searching strings with <function>boost::algorithm::find_regex</function></title>
    <programlisting><xi:include href="../src/stringalgorithms_12/main.cpp" parse="text"/></programlisting>
  </example>
  <para>In order to use the regular expression, the program accesses a class called <classname>boost::regex</classname>, which is presented in <xref linkend="boost.regex" xrefstyle="t"/>.</para>
  <para><xref linkend="ex.stringalgorithms_12" xrefstyle="enp"/> writes <computeroutput>C++</computeroutput> to standard output.</para>
  <simplesect role="exercises" xml:id="boost.stringalgorithms-exercises">
    <title>Exercise</title>
    <para>Create a program which asks the user to enter his full name. The program should greet the user with <quote>Hello</quote> followed by the user's name followed by an exclamation mark. The user's first- and lastname should start with a capital letter followed by lowercase letters. Furthermore, the user's first- und lastname should be separated with exactly one space. There should be no space before the exclamation mark.</para>
  </simplesect>
</chapter>
