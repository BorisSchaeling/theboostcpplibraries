<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.exception">
  <title>Boost.Exception</title><indexterm><primary>Boost.Exception</primary></indexterm>
  <para>The library <link xlink:href="http://www.boost.org/libs/exception">Boost.Exception</link> provides a new exception type, <exceptionname>boost::exception</exceptionname><indexterm><primary>exception, Boost.Exception</primary></indexterm>, that lets you add data to an exception after it has been thrown. This type is defined in <filename class="headerfile">boost/exception/exception.hpp</filename>. Because Boost.Exception spreads its classes and functions over multiple header files, the following examples access the master header file <filename class="headerfile">boost/exception/all.hpp</filename> to avoid including header files one by one.</para>
  <para>Boost.Exception supports the mechanism from the C++11 standard that transports an exception from one thread to another. <classname>boost::exception_ptr</classname><indexterm><primary>exception_ptr, Boost.Exception</primary></indexterm> is similar to <classname>std::exception_ptr</classname>. However, Boost.Exception isn’t a full replacement for the header file <filename class="headerfile">exception</filename> from the standard library. For example, Boost.Exception is missing support for nested exceptions of type <classname>std::nested_exception</classname>.</para>
  <note>
    <para>To compile the examples in this chapter with Visual C++ 2013, remove the keyword <code>noexcept</code>. This version of the Microsoft compiler doesn’t support <code>noexcept</code> yet.</para>
  </note>
  <example xml:id="ex.exception_01">
    <title>Using <classname>boost::exception</classname></title>
    <programlisting><xi:include href="../src/exception_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.exception_01" xrefstyle="enp"/> calls the function <function>write_lots_of_zeros</function>, which in turn calls <function>allocate_memory</function>. <function>allocate_memory</function> allocates memory dynamically. The function passes <code>std::nothrow</code> to <code>new</code> and checks whether the return value is 0. If memory allocation fails, an exception of type <exceptionname>allocation_failed</exceptionname> is thrown. <classname>allocation_failed</classname> replaces the exception <exceptionname>std::bad_alloc</exceptionname> thrown by default if <code>new</code> fails to allocate memory.</para>
  <para><function>write_lots_of_zeros</function> calls <function>allocate_memory</function> to try and allocate a memory block with the greatest possible size. This is done with the help of <methodname>max</methodname> from <classname>std::numeric_limits</classname>. The example intentionally tries to allocate that much memory to make the allocation fail.</para>
  <para><exceptionname>allocation_failed</exceptionname> is derived from <exceptionname>boost::exception</exceptionname> and <exceptionname>std::exception</exceptionname>. Deriving the class from <exceptionname>std::exception</exceptionname> is not necessary. <exceptionname>allocation_failed</exceptionname> could have also been derived from a class from a different class hierarchy in order to embed it in an existing framework. While <xref linkend="ex.exception_01" xrefstyle="enp"/> uses the class hierarchy defined by the standard, deriving <exceptionname>allocation_failed</exceptionname> solely from <exceptionname>boost::exception</exceptionname> would have been sufficient.</para>
  <para>If an exception of type <exceptionname>allocation_failed</exceptionname> is caught, <function>allocate_memory</function> must be the origin of the exception, since it is the only function that throws exceptions of this type. In programs that have many functions calling <function>allocate_memory</function>, knowing the type of the exception is no longer sufficient to debug the program effectively. In those cases, it would help to know which function tried to allocate more memory than <function>allocate_memory</function> could provide.</para>
  <para>The challenge is that <function>allocate_memory</function> does not have any additional information, such as the caller name, to add to the exception. <function>allocate_memory</function> can’t enrich the exception. This can only be done in the calling context.</para>
  <para>With Boost.Exception, data can be added to an exception at any time. You just need to define a type based on <classname>boost::error_info</classname><indexterm><primary>error_info, Boost.Exception</primary></indexterm> for each bit of data you need to add.</para>
  <para><classname>boost::error_info</classname> is a template that expects two parameters. The first parameter is a <emphasis role="concept">tag</emphasis><indexterm><primary>tag, Boost.Exception</primary></indexterm> that uniquely identifies the newly created type. This is typically a structure with a unique name. The second parameter refers to the type of the value stored inside the exception. <xref linkend="ex.exception_01" xrefstyle="enp"/> defines a new type, <classname>errmsg_info</classname> &#x2013; uniquely identifiable via the structure <classname>tag_errmsg</classname> &#x2013; that stores a string of type <classname>std::string</classname>.</para>
  <para>In the <code>catch</code> handler of <function>write_lots_of_zeros</function>, <classname>errmsg_info</classname> is used to create an object that is initialized with the string <quote>writing lots of zeros failed</quote>. This object is then added to the exception of type <classname>boost::exception</classname> using <methodname role="operator">operator&lt;&lt;</methodname>. Then the exception is re-thrown.</para>
  <para>Now, the exception doesn’t just denote a failed memory allocation. It also says that the memory allocation failed when the program tried to write lots of zeros in the function <function>write_lots_of_zeros</function>. Knowing which function called <function>allocate_memory</function> makes debugging larger programs easier.</para>
  <para>To retrieve all available data from an exception, the function <function>boost::diagnostic_information</function><indexterm><primary>diagnostic_information, Boost.Exception</primary></indexterm> can be called in the <code>catch</code> handler of <function>main</function>. <function>boost::diagnostic_information</function> calls the member function <methodname>what</methodname> for each exception passed to it and accesses all of the additional data stored inside the exception. <function>boost::diagnostic_information</function> returns a string of type <classname>std::string</classname>, which, for example, can be written to standard error.</para>
  <para>When compiled with Visual C++ 2013, <xref linkend="ex.exception_01" xrefstyle="enp"/> will display the following message:</para>
  <screen>Throw location unknown (consider using BOOST_THROW_EXCEPTION)
Dynamic exception type: struct allocation_failed
std::exception::what: allocation failed
[struct tag_errmsg *] = writing lots of zeros failed</screen>
  <para>The message contains the type of the exception, the error message retrieved from <methodname>what</methodname>, and the description, including the name of the structure.</para>
  <para><function>boost::diagnostic_information</function> checks at run time whether or not a given exception is derived from <exceptionname>std::exception</exceptionname>. <methodname>what</methodname> will only be called if that is the case.</para>
  <para>The name of the function that threw the exception of type <exceptionname>allocation_failed</exceptionname> is unknown.</para>
  <para>Boost.Exception provides a macro to throw an exception that contains not only the name of the function, but also additional data such as the file name and the line number.</para>
  <example xml:id="ex.exception_02">
    <title>More data with <code>BOOST_THROW_EXCEPTION</code></title>
    <?dbfo keep-together="auto"?>
    <programlisting><xi:include href="../src/exception_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Using the macro <code>BOOST_THROW_EXCEPTION</code><indexterm><primary>BOOST_THROW_EXCEPTION, Boost.Exception</primary></indexterm> instead of <code>throw</code>, data such as function name, file name, and line number are automatically added to the exception. But this only works if the compiler supports macros for the additional data. While macros such as <code>__FILE__</code> and <code>__LINE__</code> have been standardized since C++98, the macro <code>__func__</code>, which gets the name of the current function, only became standard with C++11. Because many compilers provided such a macro before C++11, <code>BOOST_THROW_EXCEPTION</code> tries to identify the underlying compiler and use the corresponding macro if it exists.</para>
  <para>Compiled with Visual C++ 2013, <xref linkend="ex.exception_02" xrefstyle="enp"/> displays the following message:</para>
  <screen>main.cpp(20): Throw in function char *__cdecl allocate_memory(unsigned int)
Dynamic exception type: class boost::exception_detail::clone_impl&lt;struct boost::exception_detail::error_info_injector&lt;struct allocation_failed&gt; &gt;
std::exception::what: allocation failed
[struct tag_errmsg *] = writing lots of zeros failed</screen>
  <para>In <xref linkend="ex.exception_02" xrefstyle="enp" />, <exceptionname>allocation_failed</exceptionname> is no longer derived from <exceptionname>boost::exception</exceptionname>. <code>BOOST_THROW_EXCEPTION</code> accesses the function <function>boost::enable_error_info</function><indexterm><primary>enable_error_info, Boost.Exception</primary></indexterm>, which identifies whether or not an exception is derived from <exceptionname>boost::exception</exceptionname>. If not, it creates a new exception type derived from the specified type and <exceptionname>boost::exception</exceptionname>. This is why the message shown above contains a different exception type than <exceptionname>allocation_failed</exceptionname>.</para>
  <example xml:id="ex.exception_03">
    <title>Selectively accessing data with <function>boost::get_error_info</function></title>
    <programlisting><xi:include href="../src/exception_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.exception_03" xrefstyle="enp"/> does not use <function>boost::diagnostic_information</function>, it uses <function>boost::get_error_info</function><indexterm><primary>get_error_info, Boost.Exception</primary></indexterm> to directly access the error message of type <classname>errmsg_info</classname>. Because <function>boost::get_error_info</function> returns a smart pointer of type <classname>boost::shared_ptr</classname>, <methodname role="operator">operator*</methodname> is used to fetch the error message. If the parameter passed to <function>boost::get_error_info</function> is not of type <exceptionname>boost::exception</exceptionname>, a null pointer is returned. If the macro <code>BOOST_THROW_EXCEPTION</code> is always used to throw an exception, the exception will always be derived from <exceptionname>boost::exception</exceptionname> &#x2013; there is no need to check the returned smart pointer for null in that case.</para>
</chapter>
