<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.timer">
  <title>Boost.Timer</title>
  <para><link xlink:href="http://www.boost.org/libs/timer">Boost.Timer</link> provides clocks to measure code performance. At first, it may seem like this library competes with Boost.Chrono. However, while Boost.Chrono provides clocks to measure arbitrary periods, Boost.Timer measures the time it takes to execute code. Although Boost.Timer uses Boost.Chrono, when you want to measure code performance, you should use Boost.Timer rather than Boost.Chrono.</para>
  <para>Since version 1.48.0 of the Boost libraries, there have been two versions of Boost.Timer. The first version of Boost.Timer has only one header file: <filename class="headerfile">boost/timer.hpp</filename>. Do not use this header file. It belongs to the first version of Boost.Timer, which shouldn’t be used anymore.</para>
  <para>The clocks provided by Boost.Timer are implemented in the classes <classname>boost::timer::cpu_timer</classname> and <classname>boost::timer::auto_cpu_timer</classname>. <classname>boost::timer::auto_cpu_timer</classname> is derived from <classname>boost::timer::cpu_timer</classname> and automatically stops the time in the destructor. It then writes the time to an output stream.</para>
  <para><xref linkend="ex.timer_01" xrefstyle="enp" /> starts by introducing the class <classname>boost::timer::cpu_timer</classname><indexterm><primary>timer::cpu_timer</primary></indexterm><indexterm><primary>cpu_timer, timer</primary></indexterm>. This example and the following examples do some calculations to make sure enough time elapses to be measurable. Otherwise the timers would always measure 0, and it would be difficult to introduce the clocks from this library. </para>
  <example xml:id="ex.timer_01">
    <title>Measuring time with <classname>boost::timer::cpu_timer</classname></title>
    <programlisting><xi:include href="../src/timer_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Measurement starts when <classname>boost::timer::cpu_timer</classname> is instantiated. You can call the member function <methodname>format</methodname><indexterm><primary>timer::cpu_timer::format</primary></indexterm><indexterm><primary>format, timer::cpu_timer</primary></indexterm> at any point to get the elapsed time. <xref linkend="ex.timer_01" xrefstyle="enp" /> displays output in the following format: <computeroutput>0.099170s wall, 0.093601s user + 0.000000s system = 0.093601s CPU (94.4%)</computeroutput>.</para>
  <para>Boost.Timer measures wall and CPU time. The wall time is the time which passes according to a wall clock. You could measure this time yourself with a stop watch. The CPU time says how much time the program spent executing code. On today’s multitasking systems a processor isn’t available for a program all the time. A program may also need to halt and wait for user input. In these cases the wall time moves on but not the CPU time.</para>
  <para>CPU time is divided between time spent in <emphasis role="concept">user space</emphasis><indexterm><primary>user space, Boost.Timer</primary></indexterm> and time spent in <emphasis role="concept">kernel space</emphasis><indexterm><primary>kernel space, Boost.Timer</primary></indexterm>. Kernel space refers to code that is part of the operating system. User space is code that doesn’t belong to the operating system. User space includes your program code and code from third-party libraries. For example, the Boost libraries are included in user space. The amount of time spent in kernel space depends on the operating system functions called and how much time those functions need.</para>
  <example xml:id="ex.timer_02">
    <title>Stopping and resuming timers</title>
    <programlisting><xi:include href="../src/timer_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><classname>boost::timer::cpu_timer</classname> provides the member functions <methodname>stop</methodname><indexterm><primary>timer::cpu_timer::stop</primary></indexterm><indexterm><primary>stop, timer::cpu_timer</primary></indexterm> and <methodname>resume</methodname><indexterm><primary>timer::cpu_timer::resume</primary></indexterm><indexterm><primary>resume, timer::cpu_timer</primary></indexterm>, which stop and resume timers. In <xref linkend="ex.timer_02" xrefstyle="enp" />, the timer is stopped before the second <code>for</code> loop runs and resumed afterwards. Thus, the second <code>for</code> loop isn’t measured. This is similar to a stop watch that is stopped and then resumed after a while. The time returned by the second call to <methodname>format</methodname> in <xref linkend="ex.timer_02" xrefstyle="enp" /> is the same as if the second <code>for</code> loop didn’t exist.</para>
  <para><classname>boost::timer::cpu_timer</classname> also provides a member function <methodname>start</methodname><indexterm><primary>timer::cpu_timer::start</primary></indexterm><indexterm><primary>start, timer::cpu_timer</primary></indexterm>. If you call <methodname>start</methodname>, instead of <methodname>resume</methodname>, the timer restarts from zero. The constructor of <classname>boost::timer::cpu_timer</classname> calls <methodname>start</methodname>, which is why the timer starts immediately when <classname>boost::timer::cpu_timer</classname> is instantiated.</para>
  <example xml:id="ex.timer_03">
    <title>Getting wall and CPU time as a tuple</title>
    <programlisting><xi:include href="../src/timer_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para>While <methodname>format</methodname> returns the measured wall and CPU time as a string, it is also possible to receive the times in a tuple (see <xref linkend="ex.timer_03" xrefstyle="enp" />). <classname>boost::timer::cpu_timer</classname> provides the member function <methodname>elapsed</methodname><indexterm><primary>timer::cpu_timer::elapsed</primary></indexterm><indexterm><primary>elapsed, timer::cpu_timer</primary></indexterm> for that. <methodname>elapsed</methodname> returns a tuple of type <classname>boost::timer::times</classname><indexterm><primary>timer::times</primary></indexterm><indexterm><primary>times, timer</primary></indexterm>. This tuple has three member variables: <varname>wall</varname><indexterm><primary>timer::times::wall</primary></indexterm><indexterm><primary>wall, timer::times</primary></indexterm>, <varname>user</varname><indexterm><primary>timer::times::user</primary></indexterm><indexterm><primary>user, timer::times</primary></indexterm>, and <varname>system</varname><indexterm><primary>timer::times::system</primary></indexterm><indexterm><primary>system, timer::times</primary></indexterm>. These member variables contain the wall and CPU times in nanoseconds. Their type is <type>boost::int_least64_t</type>.</para>
  <para><classname>boost::timer::times</classname> provides the member function <methodname>clear</methodname><indexterm><primary>timer::times::clear</primary></indexterm><indexterm><primary>clear, timer::times</primary></indexterm> to set <varname>wall</varname>, <varname>user</varname>, and <varname>system</varname> to 0.</para>
  <example xml:id="ex.timer_04">
    <title>Measuring times automatically with <classname>boost::timer::auto_cpu_timer</classname></title>
    <programlisting><xi:include href="../src/timer_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para>You can measure the wall and CPU time of a code block with <classname>boost::timer::auto_cpu_timer</classname><indexterm><primary>timer::auto_cpu_timer</primary></indexterm><indexterm><primary>auto_cpu_timer, timer</primary></indexterm>. Because the destructor of this class stops measuring time and writes the time to the standard output stream, <xref linkend="ex.timer_04" xrefstyle="enp"/> does the same thing as <xref linkend="ex.timer_01" xrefstyle="ewp"/>.</para>
  <para><classname>boost::timer::auto_cpu_timer</classname> provides several constructors. For example, you can pass an output stream that will be used to display the time. By default, the output stream is <varname>std::cout</varname>.</para>
  <para>You can specify the format of reported times for <classname>boost::timer::auto_cpu_timer</classname> and <classname>boost::timer::cpu_timer</classname>. Boost.Timer provides format flags similar to the format flags supported by Boost.Format or <function>std::printf</function>. The documentation contains an overview of the format flags.</para>
</chapter>
