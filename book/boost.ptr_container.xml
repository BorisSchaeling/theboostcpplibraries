<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.pointer_container">
  <title>Boost.PointerContainer</title><indexterm><primary>Boost.PointerContainer</primary></indexterm>
  <para>The library <link xlink:href="http://www.boost.org/libs/ptr_container">Boost.PointerContainer</link> provides containers specialized to manage dynamically allocated objects. For example, with C++11 you can use <type>std::vector&lt;std::unique_ptr&lt;int&gt;&gt;</type> to create such a container. However, the containers from Boost.PointerContainer can provide some extra comfort.</para>
  <example xml:id="ex.pointer_container_01">
    <title>Using <classname>boost::ptr_vector</classname></title>
    <programlisting><xi:include href="../src/ptr_container_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para>The class <classname>boost::ptr_vector</classname><indexterm><primary>ptr_vector, Boost.PointerContainer</primary></indexterm> basically works like <type>std::vector&lt;std::unique_ptr&lt;int&gt;&gt;</type> (see <xref linkend="ex.pointer_container_01" xrefstyle="enp"/>). However, because <classname>boost::ptr_vector</classname> knows that it stores dynamically allocated objects, member functions like <methodname>back</methodname><indexterm><primary>ptr_vector::back</primary></indexterm><indexterm><primary>back, ptr_vector</primary></indexterm> return a reference to a dynamically allocated object and not a pointer. Thus, the example writes <computeroutput>2</computeroutput> to standard output.</para>
  <example xml:id="ex.pointer_container_02">
    <title><classname>boost::ptr_set</classname> with intuitively correct order</title>
    <programlisting><xi:include href="../src/ptr_container_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.pointer_container_02" xrefstyle="enp" /> illustrates another reason to use a specialized container. The example stores dynamically allocated variables of type <type>int</type> in a <classname>boost::ptr_set</classname><indexterm><primary>ptr_set, Boost.PointerContainer</primary></indexterm> and a <classname>std::set</classname>. <classname>std::set</classname> is used together with <classname>std::unique_ptr</classname>.</para>
  <para>With <classname>boost::ptr_set</classname>, the order of the elements depends on the <type>int</type> values. <classname>std::set</classname> compares pointers of type <classname>std::unique_ptr</classname> and not the variables the pointers refer to. To make <classname>std::set</classname> sort the elements based on <type>int</type> values, the container must be told how to compare elements. In <xref linkend="ex.pointer_container_02" xrefstyle="enp"/>, <classname>boost::indirect_fun</classname><indexterm><primary>indirect_fun, Boost.PointerContainer</primary></indexterm> (provided by Boost.PointerContainer) is used. With <classname>boost::indirect_fun</classname>, <classname>std::set</classname> is told that elements shouldn’t be sorted based on pointers of type <classname>std::unique_ptr</classname>, but instead based on the <type>int</type> values the pointers refer to. That’s why the example displays <computeroutput>1</computeroutput> twice.</para>
  <para>Besides <classname>boost::ptr_vector</classname> and <classname>boost::ptr_set</classname>, there are other containers available for managing dynamically allocated objects. Examples of these additional containers include <classname>boost::ptr_deque</classname><indexterm><primary>ptr_deque, Boost.PointerContainer</primary></indexterm>, <classname>boost::ptr_list</classname><indexterm><primary>ptr_list, Boost.PointerContainer</primary></indexterm>, <classname>boost::ptr_map</classname><indexterm><primary>ptr_map, Boost.PointerContainer</primary></indexterm>, <classname>boost::ptr_unordered_set</classname>,<indexterm><primary>ptr_unordered_set, Boost.PointerContainer</primary></indexterm> and <classname>boost::ptr_unordered_map</classname><indexterm><primary>ptr_unordered_map, Boost.PointerContainer</primary></indexterm>. These containers correspond to the well-known containers from the standard library.</para>
  <example xml:id="ex.pointer_container_03">
    <title>Inserters for containers from Boost.PointerContainer</title>
    <programlisting><xi:include href="../src/ptr_container_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Boost.PointerContainer provides inserters for its containers. They are defined in the namespace <package>boost::ptr_container</package>. To have access to the inserters, you must include the header file <filename class="headerfile">boost/ptr_container/ptr_inserter.hpp</filename>.</para>
  <para><xref linkend="ex.pointer_container_03" xrefstyle="enp" /> uses the function <function>boost::ptr_container::ptr_back_inserter</function><indexterm><primary>ptr_container::ptr_back_inserter</primary></indexterm><indexterm><primary>ptr_back_inserter, ptr_container</primary></indexterm>, which creates an inserter of type <classname>boost::ptr_container::ptr_back_insert_iterator</classname><indexterm><primary>ptr_container::ptr_back_insert_iterator</primary></indexterm><indexterm><primary>ptr_back_insert_iterator, ptr_container</primary></indexterm>. This inserter is passed to <function>std::copy</function> to copy all numbers from the array <varname>a</varname> to the vector <varname>v</varname>. Because <varname>v</varname> is a container of type <classname>boost::ptr_vector</classname>, which expects addresses of dynamically allocated <type>int</type> objects, the inserter creates copies with <code>new</code> on the heap and adds the addresses to the container.</para>
  <para>In addition to <function>boost::ptr_container::ptr_back_inserter</function>, Boost.PointerContainer provides the functions <function>boost::ptr_container::ptr_front_inserter</function><indexterm><primary>ptr_container::ptr_front_inserter</primary></indexterm><indexterm><primary>ptr_front_inserter, ptr_container</primary></indexterm> and <function>boost::ptr_container::ptr_inserter</function><indexterm><primary>ptr_container::ptr_inserter</primary></indexterm><indexterm><primary>ptr_inserter, ptr_container</primary></indexterm> to create corresponding inserters.</para>
  <simplesect role="exercises" xml:id="boost.pointer_container-exercises">
    <title>Exercise</title>
    <para>Create a program with multiple objects of a type <classname>animal</classname> with the member variables <varname>name</varname>, <varname>legs</varname> and <varname>has_tail</varname>. Store the objects in a container from Boost.PointerContainer. Sort the container in ascending order based on legs and write all elements to standard output.</para>
  </simplesect>
</chapter>
