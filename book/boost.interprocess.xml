<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.interprocess">
  <title>Boost.Interprocess</title><indexterm><primary>Boost.Interprocess</primary></indexterm>
  <para>Interprocess communication describes mechanisms to exchange data between programs running on the same computer. It does not include network communication. To exchange data between programs running on different computers connected through a network, see <xref linkend="boost.asio"/>, which covers Boost.Asio.</para>
  <para>This chapter presents the library <link xlink:href="http://www.boost.org/libs/interprocess">Boost.Interprocess</link>, which contains numerous classes that abstract operating system specific interfaces for interprocess communication. Even though the concepts of interprocess communication are similar between different operating systems, the interfaces can vary greatly. Boost.Interprocess provides platform-independent access.</para>
  <para>While Boost.Asio can be used to exchange data between processes running on the same computer, Boost.Interprocess usually provides better performance. Boost.Interprocess calls operating system functions optimized for data exchange between processes running on the same computer and thus should be the first choice to exchange data without a network.</para>
  <sect1 xml:id="boost.interprocess-shared-memory">
    <title>Shared Memory</title>
    <para>Shared memory is typically the fastest form of interprocess communication. It provides a memory area that is shared between processes. One process can write data to the area and another process can read it.</para>
    <para>In Boost.Interprocess the class <classname>boost::interprocess::shared_memory_object</classname><indexterm><primary>interprocess::shared_memory_object</primary></indexterm><indexterm><primary>shared_memory_object, interprocess</primary></indexterm> is used to represent shared memory. Include the header file <filename class="headerfile">boost/interprocess/shared_memory_object.hpp</filename> to use this class.</para>
    <example xml:id="ex.interprocess_01">
      <title>Creating shared memory</title>
      <programlisting><xi:include href="../src/interprocess_01/main.cpp" parse="text"/></programlisting>
    </example>
    <para>The constructor of <classname>boost::interprocess::shared_memory_object</classname> expects three parameters. The first parameter specifies whether the shared memory should be created or just opened. <xref linkend="ex.interprocess_01" xrefstyle="enp"/> handles both cases. <code>boost::interprocess::open_or_create</code><indexterm><primary>interprocess::open_or_create</primary></indexterm><indexterm><primary>open_or_create, interprocess</primary></indexterm> will open shared memory if it already exists or create shared memory if it doesnâ€™t.</para>
    <para>Opening existing shared memory assumes that it has been created before. To uniquely identify shared memory, a name is assigned. That name is specified by the second parameter passed to the constructor of <classname>boost::interprocess::shared_memory_object</classname>.</para>
    <para>The third parameter determines how a process can access shared memory. In <xref linkend="ex.interprocess_01" xrefstyle="enp" />, <code>boost::interprocess::read_write</code><indexterm><primary>interprocess::read_write</primary></indexterm><indexterm><primary>read_write, interprocess</primary></indexterm> says the process has read-write access.</para>
    <para>After creating an object of type <classname>boost::interprocess::shared_memory_object</classname>, a corresponding shared memory block will exist within the operating system. The size of this memory area is initially 0. To use the area, call <methodname>truncate</methodname><indexterm><primary>interprocess::shared_memory_object::truncate</primary></indexterm><indexterm><primary>truncate, interprocess::shared_memory_object</primary></indexterm>, passing in the size of the shared memory in bytes. In <xref linkend="ex.interprocess_01" xrefstyle="enp"/>, the shared memory provides space for 1,024 bytes. <methodname>truncate</methodname> can only be called if the shared memory has been opened with <code>boost::interprocess::read_write</code>. If not, an exception of type <exceptionname>boost::interprocess::interprocess_exception</exceptionname><indexterm><primary>interprocess::interprocess_exception</primary></indexterm><indexterm><primary>interprocess_exception, interprocess</primary></indexterm> is thrown. <methodname>truncate</methodname> can be called repeatedly to adjust the size of the shared memory.</para>
    <para>After creating shared memory, member functions such as <methodname>get_name</methodname><indexterm><primary>interprocess::shared_memory_object::get_name</primary></indexterm><indexterm><primary>get_name, interprocess::shared_memory_object</primary></indexterm> and <methodname>get_size</methodname><indexterm><primary>interprocess::shared_memory_object::get_size</primary></indexterm><indexterm><primary>get_size, interprocess::shared_memory_object</primary></indexterm> can be used to query the name and the size of the shared memory.</para>
    <para>Because shared memory is used to exchange data between different processes, each process needs to map the shared memory into its address space. The class <classname>boost::interprocess::mapped_region</classname><indexterm><primary>interprocess::mapped_region</primary></indexterm><indexterm><primary>mapped_region, interprocess</primary></indexterm> is used to do this. It may come as a surprise that two classes (<classname>boost::interprocess::shared_memory_object</classname> and <classname>boost::interprocess::mapped_region</classname>) are needed to access shared memory. This is done so that the class <classname>boost::interprocess::mapped_region</classname> can also be used to map other objects into the address space of a process.</para>
    <example xml:id="ex.interprocess_02">
      <title>Mapping shared memory into the address space of a process</title>
      <programlisting><xi:include href="../src/interprocess_02/main.cpp" parse="text"/></programlisting>
    </example>
    <para>To use the class <classname>boost::interprocess::mapped_region</classname>, include the header file <filename class="headerfile">boost/interprocess/mapped_region.hpp</filename>. An object of type <classname>boost::interprocess::shared_memory_object</classname> must be passed as the first parameter to the constructor of <classname>boost::interprocess::mapped_region</classname>. The second parameter determines whether access to the memory area is read-only or read-write.</para>
    <para><xref linkend="ex.interprocess_02" xrefstyle="enp"/> creates two objects of type <classname>boost::interprocess::mapped_region</classname>. The shared memory named Boost is mapped twice into the address space of the process. The address and the size of the mapped memory area is written to standard output using the member functions <methodname>get_address</methodname><indexterm><primary>interprocess::mapped_region::get_address</primary></indexterm><indexterm><primary>get_address, interprocess::mapped_region</primary></indexterm> and <methodname>get_size</methodname><indexterm><primary>interprocess::mapped_region::get_size</primary></indexterm><indexterm><primary>get_size, interprocess::mapped_region</primary></indexterm>. <methodname>get_size</methodname> returns 1024 in both cases, but the return value of <methodname>get_address</methodname> is different for each object.</para>
    <note>
      <para><xref linkend="ex.interprocess_02" xrefstyle="enp"/>, and some of the examples that follow, will cause a compiler error with Visual C++ 2013 and Boost 1.55.0. The bug is described in <link xlink:href="https://svn.boost.org/trac/boost/ticket/9332">ticket 9332</link>. This bug has been fixed in Boost 1.56.0.</para>
    </note>
    <example xml:id="ex.interprocess_03">
      <title>Writing and reading a number in shared memory</title>
      <programlisting><xi:include href="../src/interprocess_03/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.interprocess_03" xrefstyle="enp"/> uses the mapped memory area to write and read a number. <varname>region</varname> writes the number 99 to the beginning of the shared memory. <varname>region2</varname> then reads the same location in shared memory and writes the number to the standard output stream. Even though <varname>region</varname> and <varname>region2</varname> represent different memory areas within the process, as seen by the return values of <methodname>get_address</methodname> in the previous example, the program prints <computeroutput>99</computeroutput> because both memory areas access the same underlying shared memory.</para>
    <example xml:id="ex.interprocess_04">
      <title>Deleting shared memory</title>
      <programlisting><xi:include href="../src/interprocess_04/main.cpp" parse="text"/></programlisting>
    </example>
    <para>To delete shared memory, <classname>boost::interprocess::shared_memory_object</classname> offers the static member function <methodname>remove</methodname><indexterm><primary>interprocess::shared_memory_object::remove</primary></indexterm><indexterm><primary>remove, interprocess::shared_memory_object</primary></indexterm>, which takes the name of the shared memory to be deleted as a parameter (see <xref linkend="ex.interprocess_04" xrefstyle="enp"/>).</para>
    <para>Boost.Interprocess partially supports the <acronym>RAII</acronym> idiom through a class called <classname>boost::interprocess::remove_shared_memory_on_destroy</classname><indexterm><primary>interprocess::remove_shared_memory_on_destroy</primary></indexterm><indexterm><primary>remove_shared_memory_on_destroy, interprocess</primary></indexterm>. Its constructor expects the name of an existing shared memory. If an object of this class is destroyed, the shared memory is automatically deleted in the destructor.</para>
    <para>The constructor of <classname>boost::interprocess::remove_shared_memory_on_destroy</classname> does not create or open the shared memory. Therefore, this class is not a typical representative of the <acronym>RAII</acronym> idiom.</para>
    <para>If <methodname>remove</methodname> is never called, the shared memory continues to exist even if the program terminates. Whether or not the shared memory is automatically deleted depends on the underlying operating system. Windows and many Unix operating systems, including Linux, automatically delete shared memory once the system is restarted.</para>
    <para>Windows provides a special kind of shared memory that is automatically deleted once the last process using it has been terminated. Access the class <classname>boost::interprocess::windows_shared_memory</classname><indexterm><primary>interprocess::windows_shared_memory</primary></indexterm><indexterm><primary>windows_shared_memory, interprocess</primary></indexterm>, which is defined in <filename>boost/interprocess/windows_shared_memory.hpp</filename>, to use this kind of shared memory (see <xref linkend="ex.interprocess_05" xrefstyle="enp"/>).</para>
    <example xml:id="ex.interprocess_05">
      <title>Using Windows-specific shared memory</title>
      <programlisting><xi:include href="../src/interprocess_05/main.cpp" parse="text"/></programlisting>
    </example>
    <para><classname>boost::interprocess::windows_shared_memory</classname> does not provide a member function <methodname>truncate</methodname>. Instead, the size of the shared memory needs to be passed as the fourth parameter to the constructor.</para>
    <para>Even though the class <classname>boost::interprocess::windows_shared_memory</classname> is not portable and can only be used on Windows, it is useful when data needs to be exchanged with an existing Windows program that uses this special kind of shared memory.</para>
  </sect1>
  <sect1 xml:id="boost.interprocess-managed-shared-memory">
    <title>Managed Shared Memory</title>
    <para>The previous section introduced the class <classname>boost::interprocess::shared_memory_object</classname>, which can be used to create and manage shared memory. In practice, this class is rarely used because it requires the program to read and write individual bytes from and to the shared memory. C++ style favors creating objects of classes and hiding the specifics of where and how data is stored in memory.</para>
    <para>Boost.Interprocess provides <classname>boost::interprocess::managed_shared_memory</classname><indexterm><primary>interprocess::managed_shared_memory</primary></indexterm><indexterm><primary>managed_shared_memory, interprocess</primary></indexterm>, a class that is defined in <filename class="headerfile">boost/interprocess/managed_shared_memory.hpp</filename>, to support <emphasis role="concept">managed shared memory</emphasis>. This class lets you instantiate objects that have their memory located in shared memory, making the objects automatically available to any program that accesses the same shared memory.</para>
    <example xml:id="ex.interprocess_06">
      <title>Using managed shared memory</title>
      <programlisting><xi:include href="../src/interprocess_06/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.interprocess_06" xrefstyle="enp"/> opens the shared memory named Boost with a size of 1,024 bytes. If the shared memory does not exist, it will be automatically created.</para>
    <para>In regular shared memory, individual bytes are directly accessed to read or write data. Managed shared memory uses member functions such as <methodname>construct</methodname><indexterm><primary>interprocess::managed_shared_memory::construct</primary></indexterm><indexterm><primary>construct, interprocess::managed_shared_memory</primary></indexterm>, which expects a type as a template parameter (in <xref linkend="ex.interprocess_06" xrefstyle="enp"/>, <type>int</type>). The member function expects a name to denote the object created in the managed shared memory. <xref linkend="ex.interprocess_06" xrefstyle="enp"/> uses the name Integer.</para>
    <para>Because <methodname>construct</methodname> returns a proxy object, parameters can be passed to it to initialize the created object. The syntax looks like a call to a constructor. This ensures that objects can be created and initialized in managed shared memory.</para>
    <para>To access a particular object in managed shared memory, the member function <methodname>find</methodname><indexterm><primary>interprocess::managed_shared_memory::find</primary></indexterm><indexterm><primary>find, interprocess::managed_shared_memory</primary></indexterm> is used. By passing the name of the object to find, <methodname>find</methodname> returns either a pointer to the object, or in case no object with the given name was found, 0.</para>
    <para>As seen in <xref linkend="ex.interprocess_06" xrefstyle="enp"/>, <methodname>find</methodname> returns an object of type <classname>std::pair</classname>. The pointer to the object is provided as the member variable <varname>first</varname>. <xref linkend="ex.interprocess_07" xrefstyle="enp"/> shows what is received in <varname>second</varname>.</para>
    <example xml:id="ex.interprocess_07">
      <title>Creating arrays in managed shared memory</title>
      <programlisting><xi:include href="../src/interprocess_07/main.cpp" parse="text"/></programlisting>
    </example>
    <para>In <xref linkend="ex.interprocess_07" xrefstyle="enp"/>, an array with ten elements of type <type>int</type> is created by providing the value 10 enclosed by square brackets after the call to <methodname>construct</methodname>. The same <computeroutput>10</computeroutput> is written to the standard output stream using the member variable <varname>second</varname>. Thanks to this member variable, you can tell whether objects returned by <methodname>find</methodname> are single objects or arrays. For the former, <varname>second</varname> is set to 1, while for the latter, <varname>second</varname> is set to the number of elements in the array.</para>
    <para>Please note that all ten elements in the array are initialized with the value 99. If you want to initialize elements with different values, pass an iterator.</para>
    <para><methodname>construct</methodname> will fail if an object already exists with the given name in the managed shared memory. In this case, <methodname>construct</methodname> returns 0 and no initialization occurs. To use an existing object, use the member function <methodname>find_or_construct</methodname><indexterm><primary>interprocess::managed_shared_memory::find_or_construct</primary></indexterm><indexterm><primary>find_or_construct, interprocess::managed_shared_memory</primary></indexterm>, which returns a pointer to an existing object or creates a new one.</para>
    <example xml:id="ex.interprocess_08">
      <title>An exception of type <exceptionname>boost::interprocess::bad_alloc</exceptionname></title>
      <programlisting><xi:include href="../src/interprocess_08/main.cpp" parse="text"/></programlisting>
    </example>
    <para>There are other cases that will cause <methodname>construct</methodname> to fail. <xref linkend="ex.interprocess_08" xrefstyle="enp"/> tries to create an array of type <type>int</type> with 4,096 elements. The managed shared memory, however, only contains 1,024 bytes. This causes an exception of type <classname>boost::interprocess::bad_alloc</classname><indexterm><primary>interprocess::bad_alloc</primary></indexterm><indexterm><primary>bad_alloc, interprocess</primary></indexterm> to be thrown.</para>
    <para>Once objects have been created in a managed shared memory, they can be deleted with the member function <methodname>destroy</methodname><indexterm><primary>interprocess::managed_shared_memory::destroy</primary></indexterm><indexterm><primary>destroy, interprocess::managed_shared_memory</primary></indexterm>.</para>
    <example xml:id="ex.interprocess_09">
      <title>Removing objects in shared memory</title>
      <programlisting><xi:include href="../src/interprocess_09/main.cpp" parse="text"/></programlisting>
    </example>
    <para>In <xref linkend="ex.interprocess_09" xrefstyle="enp"/>, the name of the object to be deleted is passed as the only parameter to <methodname>destroy</methodname>. The return value of type <type>bool</type> can be checked to verify whether the given object was found and deleted successfully. Because an object will always be deleted if found, a return value of <literal>false</literal> indicates that no object with the given name was found.</para>
    <para>The member function <methodname>destroy_ptr</methodname><indexterm><primary>interprocess::managed_shared_memory::destroy_ptr</primary></indexterm><indexterm><primary>destroy_ptr, interprocess::managed_shared_memory</primary></indexterm> can be used to pass a pointer to an object in the managed shared memory. It can also be used to delete arrays.</para>
    <para>Because managed shared memory makes it fairly easy to share objects between processes, it seems natural to use containers from the standard library as well. However, these containers allocate memory using <code>new</code>. In order to use these containers in managed shared memory, they need to be told to allocate memory in the shared memory.</para>
    <para>Many implementations of the standard library are not flexible enough to use containers such as <classname>std::string</classname> or <classname>std::list</classname> with Boost.Interprocess. This includes the implementations shipped with Visual C++ 2013, GCC and Clang.</para>
    <para>To allow developers to use the containers from the standard library, Boost.Interprocess provides a more flexible implementation in the namespace <package>boost::interprocess</package>. For example, <classname>boost::interprocess::string</classname><indexterm><primary>interprocess::string</primary></indexterm><indexterm><primary>string, interprocess</primary></indexterm> acts exactly like its C++ counterpart <classname>std::string</classname>, except that strings can be safely stored in a managed shared memory (see <xref linkend="ex.interprocess_10" xrefstyle="enp"/>).</para>
    <example xml:id="ex.interprocess_10">
      <title>Putting strings into shared memory</title>
      <programlisting><xi:include href="../src/interprocess_10/main.cpp" parse="text"/></programlisting>
    </example>
    <para>To create a string that will allocate memory in the same managed shared memory it resides in, a corresponding type must be defined. The new string type must use an allocator provided by Boost.Interprocess instead of the default allocator provided by the standard.</para>
    <para>For this purpose, Boost.Interprocess provides the class <classname>boost::interprocess::allocator</classname><indexterm><primary>interprocess::allocator</primary></indexterm><indexterm><primary>allocator, interprocess</primary></indexterm>, which is defined in <filename class="headerfile">boost/interprocess/allocators/allocator.hpp</filename>. With this class, an allocator can be created that internally uses the <emphasis role="concept">segment manager</emphasis><indexterm><primary>segment manager, Boost.Interprocess</primary></indexterm> of the managed shared memory. The segment manager is responsible for managing the memory within a managed shared memory block. Using the newly created allocator, a corresponding type for the string can be defined. As indicated above, use <classname>boost::interprocess::basic_string</classname><indexterm><primary>interprocess::basic_string</primary></indexterm><indexterm><primary>basic_string, interprocess</primary></indexterm> instead of <classname>std::basic_string</classname>. The new type &#x2013; called <classname>string</classname> in <xref linkend="ex.interprocess_10" xrefstyle="enp"/> &#x2013; is based on <classname>boost::interprocess::basic_string</classname> and accesses the segment manager via its allocator. To let the particular instance of <classname>string</classname> created by a call to <methodname>find_or_construct</methodname> know which segment manager it should access, pass a pointer to the corresponding segment manager as the second parameter to the constructor.</para>
    <para>Boost.Interprocess provides implementations for many other containers from the standard library. For example, <classname>boost::interprocess::vector</classname><indexterm><primary>interprocess::vector</primary></indexterm><indexterm><primary>vector, interprocess</primary></indexterm> and <classname>boost::interprocess::map</classname><indexterm><primary>interprocess::map</primary></indexterm><indexterm><primary>map, interprocess</primary></indexterm> are defined in <filename class="headerfile">boost/interprocess/containers/vector.hpp</filename> and <filename class="headerfile">boost/interprocess/containers/map.hpp</filename>, respectively.</para>
    <para>Please note that the containers from Boost.Container support Boost.Interprocess and can be put into shared memory. They can be used instead of containers from <package>boost::interprocess</package>. Boost.Container is introduced in <xref linkend="boost.container"/>.</para>
    <para>Whenever the same managed shared memory is accessed from different processes, operations such as creating, finding, and destroying objects are automatically synchronized. If two programs try to create objects with different names in the managed shared memory, the access is serialized accordingly. To execute multiple operations at one time without being interrupted by operations from a different process, use the member function <methodname>atomic_func</methodname><indexterm><primary>interprocess::managed_shared_memory::atomic_func</primary></indexterm><indexterm><primary>atomic_func, interprocess::managed_shared_memory</primary></indexterm> (see <xref linkend="ex.interprocess_11" xrefstyle="enp"/>).</para>
    <example xml:id="ex.interprocess_11">
      <title>Atomic access on a managed shared memory</title>
      <programlisting><xi:include href="../src/interprocess_11/main.cpp" parse="text"/></programlisting>
    </example>
    <para><methodname>atomic_func</methodname> expects as its single parameter a function that takes no parameters and has no return value. The passed function will be called in a fashion that ensures exclusive access to the managed shared memory. However, exclusive access is only ensured if all other processes that access the managed shared memory also use <methodname>atomic_func</methodname>. If another process has a pointer to an object within the managed shared memory, it could access and modify this object using its pointer.</para>
    <para>Boost.Interprocess can also be used to synchronize object access. Since Boost.Interprocess does not know who can access individual objects at a particular time, synchronization needs to be explicitly handled. The following section introduces the classes provided for synchronization.</para>
  </sect1>
  <sect1 xml:id="boost.interprocess-synchronization">
    <title>Synchronization</title>
    <para>Boost.Interprocess allows multiple processes to use shared memory concurrently. Because shared memory is, by definition, shared between processes, Boost.Interprocess needs to support some kind of synchronization.</para>
    <para>Thinking about synchronization, classes from the C++11 standard library or Boost.Thread come to mind. But these classes can only be used to synchronize threads within the same process; they do not support synchronization of different processes. However, since the challenge in both cases is the same, the concepts are also the same.</para>
    <para>While synchronization objects such as mutexes and condition variables reside in the same address space in multithreaded applications, and therefore are available to all threads, the challenge with shared memory is that independent processes need to share these objects. For example, if one process creates a mutex, it somehow needs to be accessible from a different process.</para>
    <para>Boost.Interprocess provides two kinds of synchronization objects: anonymous objects are directly stored in the shared memory, which makes them automatically available to all processes. Named objects are managed by the operating system, are not stored in the shared memory, and can be referenced from programs by name.</para>
    <example xml:id="ex.interprocess_12">
      <title>Using a named mutex with <classname>boost::interprocess::named_mutex</classname></title>
      <programlisting><xi:include href="../src/interprocess_12/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.interprocess_12" xrefstyle="enp"/> creates and uses a named mutex using the class <classname>boost::interprocess::named_mutex</classname><indexterm><primary>interprocess::named_mutex</primary></indexterm><indexterm><primary>named_mutex, interprocess</primary></indexterm>, which is defined in <filename class="headerfile">boost/interprocess/sync/named_mutex.hpp</filename>.</para>
    <para>The constructor of <classname>boost::interprocess::named_mutex</classname> expects a parameter specifying whether the mutex should be created or opened and a name for the mutex. Every process that knows the name can open the same mutex. To access the data in shared memory, the program needs to take ownership of the mutex by calling the member function <methodname>lock</methodname><indexterm><primary>interprocess::named_mutex::lock</primary></indexterm><indexterm><primary>lock, interprocess::named_mutex</primary></indexterm>. Because mutexes can only be owned by one process at a time, another process may need to wait until the mutex has been released by <methodname>unlock</methodname><indexterm><primary>interprocess::named_mutex::unlock</primary></indexterm><indexterm><primary>unlock, interprocess::named_mutex</primary></indexterm>. Once a process takes ownership of a mutex, it has exclusive access to the resource the mutex guards. In <xref linkend="ex.interprocess_12" xrefstyle="enp"/>, the resource is a variable of type <type>int</type> that is incremented and written to the standard output stream.</para>
    <para>If the sample program is started multiple times, each instance will print a value incremented by 1 compared to the previous value. Thanks to the mutex, access to the shared memory and the variable itself is synchronized between different processes.</para>
    <example xml:id="ex.interprocess_13">
      <title>Using an anonymous mutex with <classname>interprocess_mutex</classname></title>
      <programlisting><xi:include href="../src/interprocess_13/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.interprocess_13" xrefstyle="enp"/> uses an anonymous mutex of type <classname>boost::interprocess::interprocess_mutex</classname><indexterm><primary>interprocess::interprocess_mutex</primary></indexterm><indexterm><primary>interprocess_mutex, interprocess</primary></indexterm>, which is defined in <filename class="headerfile">boost/interprocess/sync/interprocess_mutex.hpp</filename>. In order for the mutex to be accessible for all processes, it is stored in the shared memory.</para>
    <para><xref linkend="ex.interprocess_13" xrefstyle="enp"/> behaves exactly like the previous one. The only difference is the mutex, which is now stored directly in shared memory. This can be done with the member functions <methodname>construct</methodname> or <methodname>find_or_construct</methodname> from the class <classname>boost::interprocess::managed_shared_memory</classname>.</para>
    <para>In addition to <methodname>lock</methodname>, both <classname>boost::interprocess::named_mutex</classname> and <classname>boost::interprocess::interprocess_mutex</classname> provide the member functions <methodname>try_lock</methodname><indexterm><primary>interprocess::named_mutex::try_lock</primary></indexterm><indexterm><primary>try_lock, interprocess::named_mutex</primary></indexterm><indexterm><primary>interprocess::interprocess_mutex::try_lock</primary></indexterm><indexterm><primary>try_lock, interprocess::interprocess_mutex</primary></indexterm> and <methodname>timed_lock</methodname><indexterm><primary>interprocess::named_mutex::timed_lock</primary></indexterm><indexterm><primary>timed_lock, interprocess::named_mutex</primary></indexterm><indexterm><primary>interprocess::interprocess_mutex::timed_lock</primary></indexterm><indexterm><primary>timed_lock, interprocess::interprocess_mutex</primary></indexterm>. They behave exactly like their counterparts in the standard library and Boost.Thread. If recursive mutexes are required, Boost.Interprocess provides two classes: <classname>boost::interprocess::named_recursive_mutex</classname><indexterm><primary>interprocess::named_recursive_mutex</primary></indexterm><indexterm><primary>named_recursive_mutex, interprocess</primary></indexterm> and <classname>boost::interprocess::interprocess_recursive_mutex</classname><indexterm><primary>interprocess::interprocess_recursive_mutex</primary></indexterm><indexterm><primary>interprocess_recursive_mutex, interprocess</primary></indexterm>.</para>
    <para>While mutexes guarantee exclusive access to a shared resource, <emphasis role="concept">condition variables</emphasis><indexterm><primary>condition variable, Boost.Interprocess</primary></indexterm> control who has exclusive access at what time. In general, the condition variables provided by Boost.Interprocess work like the ones provided by the C++11 standard library and Boost.Thread. They have similar interfaces, which makes users of these libraries feel immediately at home when using these variables in Boost.Interprocess.</para>
    <example xml:id="ex.interprocess_14">
      <title>Using a named condition with <classname>boost::interprocess::named_condition</classname></title>
      <programlisting><xi:include href="../src/interprocess_14/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.interprocess_14" xrefstyle="enp"/> uses a condition variable of type <classname>boost::interprocess::named_condition</classname><indexterm><primary>interprocess::named_condition</primary></indexterm><indexterm><primary>named_condition, interprocess</primary></indexterm>, which is defined in <filename class="headerfile">boost/interprocess/sync/named_condition.hpp</filename>. Because it is a named variable, it does not need to be stored in shared memory.</para>
    <para>The application uses a <code>while</code> loop to increment a variable of type <type>int</type>, which is stored in shared memory. Although the variable is incremented with each iteration of the loop, it will only be written to the standard output stream with every second iteration &#x2013; only odd numbers are written.</para>
    <para>Every time the variable is incremented by 1, the member function <methodname>wait</methodname><indexterm><primary>interprocess::named_condition::wait</primary></indexterm><indexterm><primary>wait, interprocess::named_condition</primary></indexterm> of the condition variable <varname>named_cnd</varname> is called. A <emphasis role="concept">lock</emphasis><indexterm><primary>lock, Boost.Interprocess</primary></indexterm> &#x2013; in <xref linkend="ex.interprocess_14" xrefstyle="enp"/>, the variable named <varname>lock</varname> &#x2013; is passed to this member function. This is based on the <acronym>RAII</acronym> idiom of taking ownership of a mutex inside the constructor and releasing it inside the destructor.</para>
    <para>The lock is created before the <code>while</code> loop and takes ownership of the mutex for the entire execution of the program. However, if passed to <methodname>wait</methodname> as a parameter, the lock is automatically released.</para>
    <para>Condition variables are used to wait for a signal indicating that the wait is over. Synchronization is controlled by the member functions <methodname>wait</methodname> and <methodname>notify_all</methodname><indexterm><primary>interprocess::named_condition::notify_all</primary></indexterm><indexterm><primary>notify_all, interprocess::named_condition</primary></indexterm>. When a program calls <methodname>wait</methodname>, ownership of the corresponding mutex is released. The program then waits until <methodname>notify_all</methodname> is called on the same condition variable.</para>
    <para>When started, <xref linkend="ex.interprocess_14" xrefstyle="enp"/> does not seem to do much. After the variable <varname>i</varname> is incremented from 0 to 1 within the <code>while</code> loop, the program waits for a signal by calling <methodname>wait</methodname>. In order to fire the signal, a second instance of the program needs to be started.</para>
    <para>The second instance tries to take ownership of the same mutex before entering the <code>while</code> loop. This succeeds since the first instance released the mutex by calling <methodname>wait</methodname>. Because the variable has been incremented once, the second instance executes the <code>else</code> branch of the <code>if</code> expression and writes the current value to the standard output stream. Then the value is incremented by 1.</para>
    <para>Now the second instance also calls <methodname>wait</methodname>. However, before it does, it calls <methodname>notify_all</methodname>, which ensures that the two instances cooperate correctly. The first instance is notified and tries to take ownership of the mutex again, which is still owned by the second instance. However, because the second instance calls <methodname>wait</methodname> right after calling <methodname>notify_all</methodname>, which automatically releases ownership, the first instance will take ownership at that point.</para>
    <para>Both instances alternate, incrementing the variable in the shared memory. However, only one instance writes the value to the standard output stream. As soon as the variable reaches the value 10, the <code>while</code> loop is finished. In order to avoid having the other instance wait for a signal forever, <methodname>notify_all</methodname> is called one more time after the loop. Before terminating, the shared memory, the mutex, and the condition variable are destroyed.</para>
    <para>Just as there are two types of mutexes &#x2013; an anonymous type that must be stored in shared memory and a named type &#x2013; there are also two types of condition variables. <xref linkend="ex.interprocess_15" xrefstyle="enp"/> is a rewrite of the previous example using an anonymous condition variable.</para>
    <example xml:id="ex.interprocess_15">
      <title>Using an anonymous condition with <classname>interprocess_condition</classname></title>
      <programlisting><xi:include href="../src/interprocess_15/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.interprocess_15" xrefstyle="enp"/> works exactly like the previous one and also needs to be started twice to increment the <type>int</type> variable ten times.</para>
    <para>Besides mutexes and condition variables, Boost.Interprocess also supports <emphasis role="concept">semaphores</emphasis><indexterm><primary>semaphore, Boost.Interprocess</primary></indexterm> and <emphasis role="concept">file locks</emphasis><indexterm><primary>file lock, Boost.Interprocess</primary></indexterm>. Semaphores are similar to condition variables except they do not distinguish between two states; instead, they are based on a counter. File locks behave like mutexes, except they are used with files on a hard drive, rather than objects in memory.</para>
    <para>In the same way that the C++11 standard library and Boost.Thread distinguish between different types of mutexes and locks, Boost.Interprocess provides several mutexes and locks. For example, mutexes can be owned exclusively or non-exclusively. This is helpful if multiple processes need to read data simultaneously since an exclusive mutex is only required to write data. Different classes for locks are available to apply the <acronym>RAII</acronym> idiom to individual mutexes.</para>
    <para>Names should be unique unless anonymous synchronization objects are used. Even though mutexes and condition variables are objects based on different classes, this may not necessarily hold true for the operating system dependent interfaces wrapped by Boost.Interprocess. On Windows, the same operating system functions are used for both mutexes and condition variables. If the same name is used for two objects, one of each type, the program will not behave correctly on Windows.</para>
    <simplesect role="exercises" xml:id="boost.interprocess-synchronization-exercises">
      <title>Exercise</title>
      <para>Create a client and a server which communicate via shared memory. When the client is started, a filename should be passed as a command line option. The client should send the file to the server. The server should save the file in the current working directory.</para>
    </simplesect>
  </sect1>
</chapter>
