<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.coroutine">
  <title>Boost.Coroutine</title><indexterm><primary>Boost.Coroutine</primary></indexterm>
  <para>With <link xlink:href="http://www.boost.org/libs/coroutine">Boost.Coroutine</link> it is possible to use <emphasis role="concept">coroutines</emphasis><indexterm><primary>coroutine, Boost.Coroutine</primary></indexterm> in C++. Coroutines are a feature of other programming languages, which often use the keyword <code>yield</code> for coroutines. In these programming languages, <code>yield</code> can be used like <code>return</code>. However, when <code>yield</code> is used, the function remembers the location, and if the function is called again, execution continues from that location.</para>
  <para>C++ doesn’t define a keyword <code>yield</code>. However, with Boost.Coroutine it is possible to return from functions and continue later from the same location. The Boost.Asio library also uses Boost.Coroutine and benefits from coroutines.</para>
  <para>There are two versions of Boost.Coroutine. This chapter introduces the second version, which is the current version. This version has been available since Boost 1.55.0 and replaces the first one.</para>
  <example xml:id="ex.coroutine_01">
    <title>Using coroutines</title>
    <programlisting><xi:include href="../src/coroutine_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.coroutine_01" xrefstyle="enp"/> defines a function, <function>cooperative</function>, which is called from <function>main</function> as a coroutine. <function>cooperative</function> returns to <function>main</function> early and is called a second time. On the second call, it continues from where it left off.</para>
  <para>To use <function>cooperative</function> as a coroutine, the types <type>pull_type</type><indexterm><primary>coroutines::coroutine::pull_type</primary></indexterm><indexterm><primary>pull_type, coroutines::coroutine</primary></indexterm> and <type>push_type</type><indexterm><primary>coroutines::coroutine::push_type</primary></indexterm><indexterm><primary>push_type, coroutines::coroutine</primary></indexterm> are used. These types are provided by <classname>boost::coroutines::coroutine</classname><indexterm><primary>coroutines::coroutine</primary></indexterm><indexterm><primary>coroutine, coroutines</primary></indexterm>, which is a template that is instantiated with <type>void</type> in <xref linkend="ex.coroutine_01" xrefstyle="enp"/>.</para>
  <para>To use coroutines, you need <type>pull_type</type> and <type>push_type</type>. One of these types will be used to create an object that will be initialized with the function you want to use as a coroutine. The other type will be the first parameter of the coroutine function.</para>
  <para><xref linkend="ex.coroutine_01" xrefstyle="enp"/> creates an object named <varname>source</varname> of type <type>pull_type</type> in <function>main</function>. <function>cooperative</function> is passed to the constructor. <type>push_type</type> is used as the sole parameter in the signature of <function>cooperative</function>.</para>
  <para>When <varname>source</varname> is created, the function <function>cooperative</function>, which is passed to the constructor, is immediately called as a coroutine. This happens because <varname>source</varname> is based on <type>pull_type</type>. If <varname>source</varname> was based on <type>push_type</type>, the constructor wouldn’t call <function>cooperative</function> as a coroutine.</para>
  <para><function>cooperative</function> writes <computeroutput>Hello</computeroutput> to standard output. Afterwards, the function accesses <varname>sink</varname> as if it were a function. This is possible because <type>push_type</type> overloads <methodname role="operator">operator()</methodname>. While <varname>source</varname> in <function>main</function> represents the coroutine <function>cooperative</function>, <varname>sink</varname> in <function>cooperative</function> represents the function <function>main</function>. Calling <varname>sink</varname> makes <function>cooperative</function> return, and <function>main</function> continues from where <function>cooperative</function> was called and writes a comma to standard output.</para>
  <para>Then, <function>main</function> calls <varname>source</varname> as if it were a function. Again, this is possible because of the overloaded <methodname role="operator">operator()</methodname>. This time, <function>cooperative</function> continues from the point where it left off and writes <computeroutput>world</computeroutput> to standard output. Because there is no other code in <function>cooperative</function>, the coroutine ends. It returns to <function>main</function>, which writes an exclamation mark to standard output.</para>
  <para>The result is that <xref linkend="ex.coroutine_01" xrefstyle="enp"/> displays <computeroutput>Hello, world!</computeroutput></para>
  <para>You can think of coroutines as cooperative threads. To a certain extent, the functions <function>main</function> and <function>cooperative</function> run concurrently. Code is executed in turns in <function>main</function> and <function>cooperative</function>. Instructions inside each function are executed sequentially. Thanks to coroutines, a function doesn’t need to return before another function can be executed.</para>
  <example xml:id="ex.coroutine_02">
    <title>Returning a value from a coroutine</title>
    <programlisting><xi:include href="../src/coroutine_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.coroutine_02" xrefstyle="enp"/> is similar to the previous example. This time the template <classname>boost::coroutines::coroutine</classname> is instantiated with <type>int</type>. This makes it possible to return an <type>int</type> from the coroutine to the caller.</para>
  <para>The direction the <type>int</type> value is passed depends on where <type>pull_type</type> and <type>push_type</type> are used. The example uses <type>pull_type</type> to instantiate an object in <function>main</function>. <function>cooperative</function> has access to an object of type <type>push_type</type>. <type>push_type</type> sends a value, and <type>pull_type</type> receives a value; thus, the direction of the data transfer is set.</para>
  <para><function>cooperative</function> calls <varname>sink</varname>, with a parameter of type <type>int</type>. This parameter is required because the coroutine was instantiated with the data type <type>int</type>. The value passed to <varname>sink</varname> is received from <varname>source</varname> in <function>main</function> by using the member function <methodname>get</methodname>, which is provided by <type>pull_type</type>.</para>
  <para><xref linkend="ex.coroutine_02" xrefstyle="enp"/> also illustrates how a function with multiple parameters can be used as a coroutine. <function>cooperative</function> has an additional parameter of type <type>int</type>, which can’t be passed directly to the constructor of <type>pull_type</type>. The example uses <function>std::bind</function> to link the function with <type>pull_type</type>.</para>
  <para>The example writes <computeroutput>1</computeroutput> and <computeroutput>2</computeroutput> followed by <computeroutput>end</computeroutput> to standard output.</para>
  <example xml:id="ex.coroutine_03">
    <title>Passing two values to a coroutine</title>
    <programlisting><xi:include href="../src/coroutine_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.coroutine_03" xrefstyle="enp"/> uses <type>push_type</type> in <function>main</function> and <type>pull_type</type> in <function>cooperative</function>, which means data is transferred from the caller to the coroutine.</para>
  <para>This example illustrates how multiple values can be passed. Boost.Coroutine doesn’t support passing multiple values, so a tuple must be used. You need to pack multiple values into a tuple or another structure.</para>
  <para><xref linkend="ex.coroutine_03" xrefstyle="enp"/> displays <computeroutput>0 aaa</computeroutput>, <computeroutput>1 bbb</computeroutput>, and <computeroutput>end</computeroutput>.</para>
  <example xml:id="ex.coroutine_04">
    <title>Coroutines and exceptions</title>
    <programlisting><xi:include href="../src/coroutine_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para>A coroutine returns immediately when an exception is thrown. The exception is transported to the caller of the coroutine where it can be caught. Thus, exceptions are no different than with regular function calls.</para>
  <para><xref linkend="ex.coroutine_04" xrefstyle="enp"/> shows how this works. This example will write the string <computeroutput>error</computeroutput> to standard output.</para>
</chapter>
