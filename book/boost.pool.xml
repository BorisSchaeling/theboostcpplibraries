<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.pool">
  <title>Boost.Pool</title><indexterm><primary>Boost.Pool</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/pool">Boost.Pool</link> is a library that contains a few classes to manage memory. While C++ programs usually use <code>new</code> to allocate memory dynamically, the details of how memory is provided depends on the implementation of the standard library and the operating system. With Boost.Pool you can, for example, accelerate memory management to provide memory to your program faster.</para>
  <para>Boost.Pool doesn’t change the behavior of <code>new</code> or of the operating system. Boost.Pool works because the managed memory is requested from the operating system first &#x2013; for example using <code>new</code>. From the outside, your program has already allocated the memory, but internally, the memory isn’t required yet and is handed over to Boost.Pool to manage it.</para>
  <para>Boost.Pool partitions memory segments with the same size. Every time you request memory from Boost.Pool, the library accesses the next free segment and assigns memory from that segment to you. The entire segment is then marked as used, no matter how many bytes you actually need from that segment.</para>
  <para>This memory management concept is called <emphasis role="concept">simple segregated storage</emphasis><indexterm><primary>simple segregated storage, Boost.Pool</primary></indexterm>. This is the only concept supported by Boost.Pool. It is especially useful if many objects of the same size have to be created and destroyed frequently. In this case the required memory can be provided and released quickly.</para>
  <para>Boost.Pool provides the class <classname>boost::simple_segregated_storage</classname><indexterm><primary>simple_segregated_storage, Boost.Pool</primary></indexterm> to create and manage segregated memory. <classname>boost::simple_segregated_storage</classname> is a low-level class that you usually will not use in your programs directly. It is only used in <xref linkend="ex.pool_01" xrefstyle="enp"/> to illustrate simple segregated storage. All other classes from Boost.Pool are internally based on <classname>boost::simple_segregated_storage</classname>.</para>
  <example xml:id="ex.pool_01">
    <title>Using <classname>boost::simple_segregated_storage</classname></title>
    <programlisting><xi:include href="../src/pool_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para>The header file <filename class="headerfile">boost/pool/simple_segregated_storage.hpp</filename> must be included to use the class template <classname>boost::simple_segregated_storage</classname>. <xref linkend="ex.pool_01" xrefstyle="enp" /> passes <type>std::size_t</type> as the template parameter. This parameter specifies which type should be used for numbers passed to member functions of <classname>boost::simple_segregated_storage</classname> to refer, for example, to the size of a segment. The practical relevance of this template parameter is rather low.</para>
  <para>More interesting are the member functions called on <classname>boost::simple_segregated_storage</classname>. First, <methodname>add_block</methodname><indexterm><primary>simple_segregated_storage::add_block</primary></indexterm><indexterm><primary>add_block, simple_segregated_storage</primary></indexterm> is called to pass a memory block with 1024 bytes to <varname>storage</varname>. The memory is provided by the vector <varname>v</varname>. The third parameter passed to <methodname>add_block</methodname> specifies that the memory block should be partitioned in segments with 256 bytes each. Because the total size of the memory block is 1024 bytes, the memory managed by <varname>storage</varname> consists of four segments.</para>
  <para>The calls to <methodname>malloc</methodname><indexterm><primary>simple_segregated_storage::malloc</primary></indexterm><indexterm><primary>malloc, simple_segregated_storage</primary></indexterm> and <methodname>malloc_n</methodname><indexterm><primary>simple_segregated_storage::malloc_n</primary></indexterm><indexterm><primary>malloc_n, simple_segregated_storage</primary></indexterm> request memory from <varname>storage</varname>. While <methodname>malloc</methodname> returns a pointer to a free segment, <methodname>malloc_n</methodname> returns a pointer to one or more contiguous segments that provide as many bytes in one block as requested. <xref linkend="ex.pool_01" xrefstyle="enp"/> requests a block with 512 bytes with <methodname>malloc_n</methodname>. This call consumes two segments, since each segment is 256 bytes. After the calls to <methodname>malloc</methodname> and <methodname>malloc_n</methodname>, <varname>storage</varname> has only one unused segment left.</para>
  <para>At the end of the example, all segments are released with <methodname>free</methodname><indexterm><primary>simple_segregated_storage::free</primary></indexterm><indexterm><primary>free, simple_segregated_storage</primary></indexterm> and <methodname>free_n</methodname><indexterm><primary>simple_segregated_storage::free_n</primary></indexterm><indexterm><primary>free_n, simple_segregated_storage</primary></indexterm>. After these two calls, all segments are available and could be requested again with <methodname>malloc</methodname> or <methodname>malloc_n</methodname>.</para>
  <para>You usually don’t use <classname>boost::simple_segregated_storage</classname> directly. Boost.Pool provides other classes that allocate memory automatically without requiring you to allocate memory yourself and pass it to <classname>boost::simple_segregated_storage</classname>.</para>
  <example xml:id="ex.pool_02">
    <title>Using <classname>boost::object_pool</classname></title>
    <programlisting><xi:include href="../src/pool_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.pool_02" xrefstyle="enp"/> uses the class <classname>boost::object_pool</classname><indexterm><primary>object_pool, Boost.Pool</primary></indexterm>, which is defined in <filename class="headerfile">boost/pool/object_pool.hpp</filename>. Unlike <classname>boost::simple_segregated_storage</classname>, <classname>boost::object_pool</classname> knows the type of the objects that will be stored in memory. <varname>pool</varname> in <xref linkend="ex.pool_02" xrefstyle="enp"/> is simple segregated storage for <type>int</type> values. The memory managed by <varname>pool</varname> consists of segments, each of which is the size of an <type>int</type> &#x2013; 4 bytes for example.</para>
  <para>Another difference is that you don’t need to provide memory to <classname>boost::object_pool</classname>. <classname>boost::object_pool</classname> allocates memory automatically. In <xref linkend="ex.pool_02" xrefstyle="enp"/>, the call to <methodname>malloc</methodname><indexterm><primary>object_pool::malloc</primary></indexterm><indexterm><primary>malloc, object_pool</primary></indexterm> makes <varname>pool</varname> allocate a memory block with space for 32 <type>int</type> values. <methodname>malloc</methodname> returns a pointer to the first of these 32 segments that an <type>int</type> value can fit into exactly.</para>
  <para>Please note that <methodname>malloc</methodname> returns a pointer of type <type>int*</type>. Unlike <classname>boost::simple_segregated_storage</classname> in <xref linkend="ex.pool_01" xrefstyle="enp"/>, no cast operator is required.</para>
  <para><methodname>construct</methodname><indexterm><primary>object_pool::construct</primary></indexterm><indexterm><primary>construct, object_pool</primary></indexterm> is similar to <methodname>malloc</methodname> but initializes an object via a call to the constructor. In <xref linkend="ex.pool_02" xrefstyle="enp"/>, <varname>j</varname> refers to an <type>int</type> object initialized with the value 2.</para>
  <para>Please note that <varname>pool</varname> can return a free segment from the pool of 32 segments when <methodname>construct</methodname> is called. The call to <methodname>construct</methodname> does not make <xref linkend="ex.pool_02" xrefstyle="enp"/> request memory from the operating system.</para>
  <para>The last member function called in <xref linkend="ex.pool_02" xrefstyle="enp"/> is <methodname>destroy</methodname><indexterm><primary>object_pool::destroy</primary></indexterm><indexterm><primary>destroy, object_pool</primary></indexterm>, which releases an <type>int</type> object.</para>
  <example xml:id="ex.pool_03">
    <title>Changing the segment size with <classname>boost::object_pool</classname></title>
    <programlisting><xi:include href="../src/pool_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para>You can pass two parameters to the constructor of <classname>boost::object_pool</classname>. The first parameter sets the size of the memory block that <classname>boost::object_pool</classname> will allocate when the first segment is requested with a call to <methodname>malloc</methodname> or <methodname>construct</methodname>. The second parameter sets the maximum size of the memory block to allocate.</para>
  <para>If <methodname>malloc</methodname> or <methodname>construct</methodname> are called so often that all segments in a memory block are used, the next call to one of these member functions will cause <classname>boost::object_pool</classname> to allocate a new memory block, which will be twice as big as the previous one. The size will double each time a new memory block is allocated by <classname>boost::object_pool</classname>. <classname>boost::object_pool</classname> can manage an arbitrary number of memory blocks, but their sizes will grow exponentially. The second constructor parameter lets you limit the growth.</para>
  <para>The default constructor of <classname>boost::object_pool</classname> does the same as what the call to the constructor in <xref linkend="ex.pool_03" xrefstyle="enp"/> does. The first parameter sets the size of the memory block to 32 <type>int</type> values. The second parameter specifies that there is no maximum size. If 0 is passed, <classname>boost::object_pool</classname> can double the size of the memory block indefinitely.</para>
  <para>The call to <methodname>construct</methodname> in <xref linkend="ex.pool_03" xrefstyle="enp" /> makes <varname>pool</varname> allocate a memory block of 32 <type>int</type> values. <varname>pool</varname> can serve up to 32 calls to <methodname>malloc</methodname> or <methodname>construct</methodname> without requesting memory from the operating system. If more memory is required, the next memory block to allocate will have space for 64 <type>int</type> values.</para>
  <para><methodname>get_next_size</methodname><indexterm><primary>object_pool::get_next_size</primary></indexterm><indexterm><primary>get_next_size, object_pool</primary></indexterm> returns the size of the next memory block to allocate. <methodname>set_next_size</methodname><indexterm><primary>object_pool::set_next_size</primary></indexterm><indexterm><primary>set_next_size, object_pool</primary></indexterm> lets you set the size of the next memory block. In <xref linkend="ex.pool_03" xrefstyle="enp"/> <methodname>get_next_size</methodname> returns 64. The call to <methodname>set_next_size</methodname> changes the size of the next memory block to allocate from 64 to 8 <type>int</type> values. With <methodname>set_next_size</methodname> the size of the next memory block can be changed directly. If you only want to set a maximum size, pass it via the second parameter to the constructor.</para>
  <para>With <classname>boost::singleton_pool</classname>, Boost.Pool provides a class between <classname>boost::simple_segregated_storage</classname> and <classname>boost::object_pool</classname> (see <xref linkend="ex.pool_04" xrefstyle="enp"/>).</para>
  <example xml:id="ex.pool_04">
    <title>Using <classname>boost::singleton_pool</classname></title>
    <programlisting><xi:include href="../src/pool_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para><classname>boost::singleton_pool</classname><indexterm><primary>singleton_pool, Boost.Pool</primary></indexterm> is defined in <filename class="headerfile">boost/pool/singleton_pool.hpp</filename>. This class is similar to <classname>boost::simple_segregated_storage</classname> since it also expects the segment size as a template parameter but not the type of the objects to store. That’s why member functions such as <methodname>ordered_malloc</methodname><indexterm><primary>singleton_pool::ordered_malloc</primary></indexterm><indexterm><primary>ordered_malloc, singleton_pool</primary></indexterm> and <methodname>malloc</methodname><indexterm><primary>singleton_pool::malloc</primary></indexterm><indexterm><primary>malloc, singleton_pool</primary></indexterm>return a pointer of type <type>void*</type>, which must be cast explicitly.</para>
  <para>This class is also similar to <classname>boost::object_pool</classname> because it allocates memory automatically. The size of the next memory block and an optional maximum size are passed as template parameters. Here <classname>boost::singleton_pool</classname> differs from <classname>boost::object_pool</classname>: you can’t change the size of the next memory block in <classname>boost::singleton_pool</classname> at run time.</para>
  <para>You can create multiple objects with <classname>boost::singleton_pool</classname> if you want to manage several memory pools. The first template parameter passed to <classname>boost::singleton_pool</classname> is a <emphasis role="concept">tag</emphasis><indexterm><primary>tag, Boost.Pool</primary></indexterm>. The tag is an arbitrary type that serves as a name for the memory pool. <xref linkend="ex.pool_04" xrefstyle="enp"/> uses the structure <classname>int_pool</classname> as a tag to highlight that <classname>singleton_int_pool</classname> is a pool that manages <type>int</type> values. Thanks to tags, multiple singletons can manage different memory pools, even if the second template parameter for the size is the same. The tag has no purpose other than creating separate instances of <classname>boost::singleton_pool</classname>.</para>
  <para><classname>boost::singleton_pool</classname> provides two member functions to release memory: <methodname>release_memory</methodname><indexterm><primary>singleton_pool::release_memory</primary></indexterm><indexterm><primary>release_memory, singleton_pool</primary></indexterm> releases all memory blocks that aren’t used at the moment, and <methodname>purge_memory</methodname><indexterm><primary>singleton_pool::purge_memory</primary></indexterm><indexterm><primary>purge_memory, singleton_pool</primary></indexterm> releases all memory blocks &#x2013; including those currently being used. The call to <methodname>purge_memory</methodname> resets <classname>boost::singleton_pool</classname>.</para>
  <para><methodname>release_memory</methodname> and <methodname>purge_memory</methodname> return memory to the operating system. To return memory to <classname>boost::singleton_pool</classname> instead of the operating system, call member functions such as <methodname>free</methodname><indexterm><primary>singleton_pool::free</primary></indexterm><indexterm><primary>free, singleton_pool</primary></indexterm> or <methodname>ordered_free</methodname><indexterm><primary>singleton_pool::ordered_free</primary></indexterm><indexterm><primary>ordered_free, singleton_pool</primary></indexterm>.</para>
  <para><classname>boost::object_pool</classname> and <classname>boost::singleton_pool</classname> allow you to request memory explicitly. You do this by calling member functions such as <methodname>malloc</methodname> or <methodname>construct</methodname>. Boost.Pool also provides the class <classname>boost::pool_allocator</classname>, which you can pass as an allocator to containers (see <xref linkend="ex.pool_05" xrefstyle="enp"/>).</para>
  <example xml:id="ex.pool_05">
    <title>Using <classname>boost::pool_allocator</classname></title>
    <programlisting><xi:include href="../src/pool_05/main.cpp" parse="text"/></programlisting>
  </example>
  <para><classname>boost::pool_allocator</classname><indexterm><primary>pool_allocator, Boost.Pool</primary></indexterm> is defined in <filename class="headerfile">boost/pool/pool_alloc.hpp</filename>. The class is an allocator that is usually passed as a second template parameter to containers from the standard library. The allocator provides memory required by the container.</para>
  <para><classname>boost::pool_allocator</classname> is based on <classname>boost::singleton_pool</classname>. To release memory, you have to use a tag to access <classname>boost::singleton_pool</classname> and call <methodname>purge_memory</methodname> or <methodname>release_memory</methodname>. <xref linkend="ex.pool_05" xrefstyle="enp"/> uses the tag <classname>boost::pool_allocator_tag</classname>. This tag is defined by Boost.Pool and is used by <classname>boost::pool_allocator</classname> for the internal <classname>boost::singleton_pool</classname>.</para>
  <para>When <xref linkend="ex.pool_05" xrefstyle="enp"/> calls <methodname>push_back</methodname> the first time, <varname>v</varname> accesses the allocator to get the requested memory. Because the allocator <classname>boost::pool_allocator</classname> is used, a memory block with space for 32 <type>int</type> values is allocated. <varname>v</varname> receives the pointer to the first segment in that memory block that has the size of an <type>int</type>. With every subsequent call to <methodname>push_back</methodname>, another segment is used from the memory block until the allocator detects that a bigger memory block is required.</para>
  <para>Please note that you should call <methodname>clear</methodname> on a container before you release memory with <methodname>purge_memory</methodname> (see <xref linkend="ex.pool_05" xrefstyle="enp"/>). A call to <methodname>purge_memory</methodname> releases memory but doesn’t notify the container that it doesn’t own the memory anymore. A call to <methodname>release_memory</methodname> is less dangerous because it only releases memory blocks that aren’t in use.</para>
  <para>Boost.Pool also provides an allocator called <classname>boost::fast_pool_allocator</classname> (see <xref linkend="ex.pool_06" xrefstyle="enp"/>).</para>
  <example xml:id="ex.pool_06">
    <title>Using <classname>boost::fast_pool_allocator</classname></title>
    <programlisting><xi:include href="../src/pool_06/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Both allocators are used in the same way, but <classname>boost::pool_allocator</classname> should be preferred if you are requesting contiguous segments. <classname>boost::fast_pool_allocator</classname><indexterm><primary>fast_pool_allocator, Boost.Pool</primary></indexterm> can be used if segments are requested one by one. Grossly simplified: You use <classname>boost::pool_allocator</classname> for <classname>std::vector</classname> and <classname>boost::fast_pool_allocator</classname> for <classname>std::list</classname>.</para>
  <para><xref linkend="ex.pool_06" xrefstyle="enp"/> illustrates which template parameters can be passed to <classname>boost::fast_pool_allocator</classname>. <classname>boost::pool_allocator</classname> accepts the same parameters.</para>
  <para><classname>boost::default_user_allocator_new_delete</classname><indexterm><primary>default_user_allocator_new_delete, Boost.Pool</primary></indexterm> is a class that allocates memory blocks with <code>new</code> and releases them with <code>delete[]</code>. You can also use <classname>boost::default_user_allocator_malloc_free</classname><indexterm><primary>default_user_allocator_malloc_free, Boost.Pool</primary></indexterm>, which calls <function>malloc</function> and <function>free</function>.</para>
  <para><type>boost::details::pool::default_mutex</type> is a type definition that is set to <classname>boost::mutex</classname> or <classname>boost::details::pool::null_mutex</classname><indexterm><primary>details::pool::null_mutex</primary></indexterm><indexterm><primary>null_mutex, details::pool</primary></indexterm>. <classname>boost::mutex</classname> is the default type that supports multiple threads requesting memory from the allocator. If the macro <code>BOOST_POOL_NO_MT</code><indexterm><primary>BOOST_POOL_NO_MT, Boost.Pool</primary></indexterm> is defined as in <xref linkend="ex.pool_06" xrefstyle="enp" />, multithreading support for Boost.Pool is disabled. The allocator in <xref linkend="ex.pool_06" xrefstyle="enp"/> uses a null mutex.</para>
  <para>The last two parameters passed to <classname>boost::fast_pool_allocator</classname> in <xref linkend="ex.pool_06" xrefstyle="enp"/> set the size of the first memory block and the maximum size of memory blocks to allocate.</para>
</chapter>
