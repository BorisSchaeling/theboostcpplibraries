<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.parameter">
  <title>Boost.Parameter</title><indexterm><primary>Boost.Parameter</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/parameter">Boost.Parameter</link> makes it possible to pass parameters as key/value pairs. In addition to supporting function parameters, the library also supports template parameters. Boost.Parameter is especially useful if you are using long parameter lists, and the order and meaning of parameters is difficult to remember. Key/value pairs make it possible to pass parameters in any order. Because every value is passed with a key, the meaning of the various values is also clearer.</para>
  <example xml:id="ex.parameter_01">
    <title>Function parameters as key/value pairs</title>
    <programlisting><xi:include href="../src/parameter_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.parameter_01" xrefstyle="enp"/> defines a function <function>complicated</function>, which expects five parameters. The parameters may be passed in any order. Boost.Parameter provides the macro <code>BOOST_PARAMETER_FUNCTION</code><indexterm><primary>BOOST_PARAMETER_FUNCTION, Boost.Parameter</primary></indexterm> to define such a function.</para>
  <para>Before <code>BOOST_PARAMETER_FUNCTION</code> can be used, the parameters for the key/value pairs must be defined. This is done with the macro <code>BOOST_PARAMETER_NAME</code><indexterm><primary>BOOST_PARAMETER_NAME, Boost.Parameter</primary></indexterm>, which is just passed a parameter name. The example uses <code>BOOST_PARAMETER_NAME</code> five times to define the parameter names <varname>a</varname>, <varname>b</varname>, <varname>c</varname>, <varname>d</varname>, and <varname>e</varname>.</para>
  <para>Please note that the parameter names are automatically defined in the namespace <package>tag</package>. This should avoid clashes with identically named definitions in a program.</para>
  <para>After the parameter names have been defined, <code>BOOST_PARAMETER_FUNCTION</code> is used to define the function <function>complicated</function>. The first parameter passed to <code>BOOST_PARAMETER_FUNCTION</code> is the type of the return value. This is <type>void</type> in the example. Please note that the type must be wrapped in parentheses &#x2013; the first parameter is <code>(void)</code>.</para>
  <para>The second parameter is the name of the function being defined. The third parameter is the namespace containing the parameter names. In the fourth parameter, the parameter names are accessed to further specify them.</para>
  <para>In <xref linkend="ex.parameter_01" xrefstyle="enp"/> the fourth parameter starts with <code>required</code>, which is a keyword that makes the parameters that follow mandatory. <code>required</code> is followed by one or more pairs consisting of a parameter name and a type. It is important to wrap the type in parentheses.</para>
  <para>Various types are used for the parameters <varname>a</varname>, <varname>b</varname>, <varname>c</varname>, and <varname>d</varname>. For example, <varname>a</varname> can be used to pass an <type>int</type> value to <function>complicated</function>. No type is given for <varname>e</varname>. Instead, an asterisk is used, which means that the value passed may have any type. <varname>e</varname> is a template parameter.</para>
  <para>After the various parameters have been passed to <code>BOOST_PARAMETER_FUNCTION</code>, the function body is defined. This is done, as usual, between a pair of curly brackets. Parameters can be accessed in the function body. They can be used like variables, with the types assigned within <code>BOOST_PARAMETER_FUNCTION</code>. <xref linkend="ex.parameter_01" xrefstyle="enp"/> writes the parameters to standard output.</para>
  <para><function>complicated</function> is called from <function>main</function>. The parameters are passed to <function>complicated</function> in an arbitrary order. Parameter names start with an underscore. Boost.Parameter uses the underscore to avoid name clashes with other variables.</para>
  <note>
    <para>To pass function parameters as key/value pairs in C++, you can also use the <link xlink:href="http://www.parashift.com/c++-faq/named-parameter-idiom.html">named parameter idiom</link>, which doesn’t require a library like Boost.Parameter.</para>
  </note>
  <example xml:id="ex.parameter_02">
    <title>Optional function parameters</title>
    <programlisting><xi:include href="../src/parameter_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><code>BOOST_PARAMETER_FUNCTION</code> also supports defining optional parameters.</para>
  <para>In <xref linkend="ex.parameter_02" xrefstyle="enp"/> the parameters <varname>c</varname>, <varname>d</varname>, and <varname>e</varname> are optional. These parameters are defined in <code>BOOST_PARAMETER_FUNCTION</code> using the <code>optional</code> keyword.</para>
  <para>Optional parameters are defined like required parameters: a parameter name is given followed by a type. As usual, the type is wrapped in parentheses. However, optional parameters need to have a default value.</para>
  <para>With the call to <function>complicated</function>, only the parameters <varname>a</varname> and <varname>b</varname> are passed. These are the only required parameters. As the parameters <varname>c</varname>, <varname>d</varname>, and <varname>e</varname> aren’t used, they are set to default values.</para>
  <para>Boost.Parameter provides macros in addition to <code>BOOST_PARAMETER_FUNCTION</code>. For example, you can use <code>BOOST_PARAMETER_MEMBER_FUNCTION</code><indexterm><primary>BOOST_PARAMETER_MEMBER_FUNCTION, Boost.Parameter</primary></indexterm> to define a member function, and <code>BOOST_PARAMETER_CONST_MEMBER_FUNCTION</code><indexterm><primary>BOOST_PARAMETER_CONST_MEMBER_FUNCTION, Boost.Parameter</primary></indexterm> to define a constant member function.</para>
  <para>You can define functions with Boost.Parameter that try to assign values to parameters automatically. In that case, you don’t need to pass key/value pairs &#x2013; it is sufficient to pass values only. If the types of all values are different, Boost.Parameter can detect which value belongs to which parameter. This might require you to have a deeper knowledge of template meta programming.</para>
  <example xml:id="ex.parameter_03">
    <title>Template parameters as key/value pairs</title>
    <programlisting><xi:include href="../src/parameter_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.parameter_03" xrefstyle="enp"/> uses Boost.Parameter to pass template parameters as key/value pairs. As with functions, it is possible to pass the template parameters in any order.</para>
  <para>The example defines a class <classname>complicated</classname>, which expects three template parameters. Because the order of the parameters doesn’t matter, they are called <code>A</code>, <code>B</code>, and <code>C</code>. <code>A</code>, <code>B</code>, and <code>C</code> aren’t the names of the parameters that will be used when the class template is accessed. As with functions, the parameter names are defined using a macro. For template parameters, <code>BOOST_PARAMETER_TEMPLATE_KEYWORD</code><indexterm><primary>BOOST_PARAMETER_TEMPLATE_KEYWORD, Boost.Parameter</primary></indexterm> is used. <xref linkend="ex.parameter_03" xrefstyle="enp"/> defines three parameter names <type>integral_type</type>, <type>floating_point_type</type>, and <type>any_type</type>.</para>
  <para>After the parameter names have been defined, you must specify the types that may be passed. For example, the parameter <type>integral_type</type> can be used to pass types such as <code>int</code> or <code>long</code>, but not a type like <classname>std::string</classname>. <classname>boost::parameter::parameters</classname><indexterm><primary>parameter::parameters</primary></indexterm><indexterm><primary>parameters, parameter</primary></indexterm> is used to create a signature that refers to the parameter names and defines which types may be passed with each of them.</para>
  <para><classname>boost::parameter::parameters</classname> is a tuple that describes parameters. Required parameters are marked with <classname>boost::parameter::required</classname><indexterm><primary>parameter::required</primary></indexterm><indexterm><primary>required, parameter</primary></indexterm>.</para>
  <para><classname>boost::parameter::required</classname> requires two parameters. The first is the name of the parameter defined with <code>BOOST_PARAMETER_TEMPLATE_KEYWORD</code>. The second identifies the type the parameter may be set to. For example, <type>integral_type</type> may be set to an integral type. This requirement is expressed with <code>std::is_integral&lt;_&gt;</code>. <code>std::is_integral&lt;_&gt;</code> is a lambda function based on Boost.MPL. <classname>boost::mpl::placeholders::_</classname> is a placeholder provided by this library. If the type to which <type>integral_type</type> is set is passed to <classname>std::is_integral</classname> instead of <classname>boost::mpl::placeholders::_</classname>, and the result is true, a valid type is used. The requirements for the other parameters <type>floating_point_type</type> and <type>any_type</type> are defined similarly.</para>
  <para>After the signature has been created and defined as <type>complicated_signature</type>, it is used by the class <classname>complicated</classname>. First, the signature is bound with <code>complicated_signature::bind</code> to the template parameters <code>A</code>, <code>B</code>, and <code>C</code>. The new type, <type>args</type>, represents the connection between the template parameters passed and the requirements that must be met by the template parameters. Next, <type>args</type> is accessed to get the parameter values. This is done with <classname>boost::parameter::value_type</classname><indexterm><primary>parameter::value_type</primary></indexterm><indexterm><primary>value_type, parameter</primary></indexterm>. <classname>boost::parameter::value_type</classname> expects <type>args</type> and a parameter to be passed. The parameter determines the type created. In <xref linkend="ex.parameter_03" xrefstyle="enp" />, the type definition <type>integral_type</type> in the class <classname>complicated</classname> is used to get the type that was passed with the parameter <type>integral_type</type> to <classname>complicated</classname>.</para>
  <para><function>main</function> accesses <classname>complicated</classname> to instantiate the class. The parameter <type>integral_type</type> is set to <type>int</type>, <type>floating_point_type</type> to <type>double</type>, and <type>any_type</type> to <type>bool</type>. The order of the parameters passed doesn’t matter. The type definitions <type>integral_type</type>, <type>floating_point_type</type>, and <type>any_type</type> are then accessed by <code>typeid</code> to get their underlying types. Compiled with Visual C++ 2013, the example writes <computeroutput>int</computeroutput>, <computeroutput>double</computeroutput> and <computeroutput>bool</computeroutput> to standard output.</para>
  <example xml:id="ex.parameter_04">
    <title>Optional template parameters</title>
    <programlisting><xi:include href="../src/parameter_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.parameter_04" xrefstyle="enp"/> introduces optional template parameters. The signature uses <classname>boost::parameter::optional</classname><indexterm><primary>parameter::optional</primary></indexterm><indexterm><primary>optional, parameter</primary></indexterm> for the optional template parameters. The optional template parameters from <classname>complicated</classname> are set to <classname>boost::parameter::void_</classname><indexterm><primary>parameter::void_</primary></indexterm><indexterm><primary>void_, parameter</primary></indexterm>, and <classname>boost::parameter::value_type</classname> is given a default value. This default value is the type an optional parameter will be set to if the type isn’t otherwise set.</para>
  <para><classname>complicated</classname> is instantiated in <function>main</function>. This time only the parameters <type>integral_type</type> and <type>floating_point_type</type> are used. <type>any_type</type> is not used. Compiled with Visual C++ 2013, the example writes <computeroutput>short</computeroutput> for <type>integral_type</type>, <computeroutput>double</computeroutput> for <type>floating_point_type</type>, and <computeroutput>bool</computeroutput> for <type>any_type</type> to standard output.</para>
  <para>Boost.Parameter can automatically detect template parameters. You can create signatures that allow types to be automatically assigned to parameters. As with function parameters, deeper knowledge in template meta programming is required to do this.</para>
</chapter>
