<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.fusion">
  <title>Boost.Fusion</title><indexterm><primary>Boost.Fusion</primary></indexterm>
  <para>The standard library provides numerous containers that have one thing in common: They are homogeneous. That is, containers from the standard library can only store elements of one type. A vector of the type <type>std::vector&lt;int&gt;</type> can only store <type>int</type> values, and a vector of type <type>std::vector&lt;std::string&gt;</type> can only store strings.</para>
  <para><link xlink:href="http://www.boost.org/libs/fusion">Boost.Fusion</link> makes it possible to create heterogeneous containers. For example, you can create a vector whose first element is an <type>int</type> and whose second element is a string. In addition, Boost.Fusion provides algorithms to process heterogeneous containers. You can think of Boost.Fusion as the standard library for heterogeneous containers.</para>
  <para>Strictly speaking, since C++11, the standard library has provided a heterogeneous container, <classname>std::tuple</classname>. You can use different types for the values stored in a tuple. <classname>boost:fusion::tuple</classname><indexterm><primary>fusion::tuple</primary></indexterm><indexterm><primary>tuple, fusion</primary></indexterm> in Boost.Fusion is a similar type. While the standard library doesn’t have much more to offer, tuples are just the starting place for Boost.Fusion.</para>
  <example xml:id="ex.fusion_01">
    <title>Processing Fusion tuples</title>
    <programlisting><xi:include href="../src/fusion_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.fusion_01" xrefstyle="enp"/> defines a tuple consisting of an <type>int</type>, a <classname>std::string</classname>, a <type>bool</type>, and a <type>double</type>. The tuple is based on <classname>boost:fusion::tuple</classname>. In <xref linkend="ex.fusion_01" xrefstyle="enp"/>, the tuple is then instantiated, initialized, and the various elements are retrieved with <function>boost::fusion::get</function><indexterm><primary>fusion::get</primary></indexterm><indexterm><primary>get, fusion</primary></indexterm> and written to standard output. The function <function>boost::fusion::get</function> is similar to <function>std::get</function>, which accesses elements in <classname>std::tuple</classname>.</para>
  <para>Fusion tuples don’t differ from tuples from the standard library. Thus it’s no surprise that Boost.Fusion provides a function <function>boost::fusion::make_tuple</function>,<indexterm><primary>fusion::make_tuple</primary></indexterm><indexterm><primary>make_tuple, fusion</primary></indexterm> which works like <function>std::make_tuple</function>. However, Boost.Fusion provides additional functions that go beyond what is offered in the standard library.</para>
  <example xml:id="ex.fusion_02">
    <title>Iterating over a tuple with <function>boost::fusion::for_each</function></title>
    <programlisting><xi:include href="../src/fusion_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.fusion_02" xrefstyle="enp"/> introduces the algorithm <function>boost::fusion::for_each</function>,<indexterm><primary>fusion::for_each</primary></indexterm><indexterm><primary>for_each, fusion</primary></indexterm> which iterates over a Fusion container. The function is used here to write the values in the tuple <varname>t</varname> to standard output.</para>
  <para><function>boost::fusion::for_each</function> is designed to work like <function>std::for_each</function>. While <function>std::for_each</function> only iterates over homogeneous containers, <function>boost::fusion::for_each</function> works with heterogeneous containers. You pass a container, not an iterator, to <function>boost::fusion::for_each</function>. If you don’t want to iterate over all elements in a container, you can use a <emphasis role="concept">view</emphasis><indexterm><primary>view, Boost.Fusion</primary></indexterm>.</para>
  <example xml:id="ex.fusion_03">
    <title>Filtering a Fusion container with <classname>boost::fusion::filter_view</classname></title>
    <programlisting><xi:include href="../src/fusion_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Boost.Fusion provides views, which act like containers but don’t store data. With views, data in a container can be accessed differently. Views are similar to adaptors from Boost.Range. However, while adaptors from Boost.Range can be applied to only one container, views from Boost.Fusion can span data from multiple containers.</para>
  <para><xref linkend="ex.fusion_03" xrefstyle="enp"/> uses the class <classname>boost::fusion::filter_view</classname><indexterm><primary>fusion::filter_view</primary></indexterm><indexterm><primary>filter_view, fusion</primary></indexterm> to filter the tuple <varname>t</varname>. The filter directs <function>boost::fusion::for_each</function> to only write elements based on an integral type.</para>
  <para><classname>boost::fusion::filter_view</classname> expects as a first template parameter the type of the container to filter. The second template parameter must be a predicate to filter elements. The predicate must filter the elements based on their type.</para>
  <para>The library is called Boost.Fusion because it combines two worlds: C++ programs process values at run time and types at compile time. For developers, values at run time are usually more important. Most tools from the standard library process values at run time. To process types at compile time, template meta programming is used. While values are processed depending on other values at run time, types are processed depending on other types at compile time. Boost.Fusion lets you process values depending on types. </para>
  <para>The second template parameter passed to <classname>boost::fusion::filter_view</classname> is a predicate, which will be applied to every type in the tuple. The predicate expects a type as a parameter and returns <literal>true</literal> if the type should be part of the view. If <literal>false</literal> is returned, the type is filtered out.</para>
  <para><xref linkend="ex.fusion_03" xrefstyle="enp"/> uses the class <classname>boost::is_integral</classname> from Boost.TypeTraits. <classname>boost::is_integral</classname> is a template that checks whether a type is integral. Because the template parameter has to be passed to <classname>boost::fusion::filter_view</classname>, a placeholder from Boost.MPL, <code>boost::mpl::arg&lt;1&gt;</code>, is used to create a lambda function. <code>boost::mpl::arg&lt;1&gt;</code> is similar to <varname>boost::phoenix::place_holders::arg1</varname> from Boost.Phoenix. In <xref linkend="ex.fusion_03" xrefstyle="enp"/>, the view <varname>v</varname> will contain only the <type>int</type> and <type>bool</type> elements from the tuple, and therefore, the example will write <computeroutput>10</computeroutput> and <computeroutput>true</computeroutput> to standard output.</para>
  <example xml:id="ex.fusion_04">
    <title>Accessing elements in Fusion containers with iterators</title>
    <programlisting><xi:include href="../src/fusion_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para>After seeing <classname>boost::fusion::tuple</classname> and <function>boost::fusion::for_each</function>, it shouldn’t come as a surprise to find iterators in <xref linkend="ex.fusion_04" xrefstyle="enp"/>. Boost.Fusion provides several free-standing functions, such as <function>boost::fusion::begin</function><indexterm><primary>fusion::begin</primary></indexterm><indexterm><primary>begin, fusion</primary></indexterm> and <function>boost::fusion::advance</function><indexterm><primary>fusion::advance</primary></indexterm><indexterm><primary>advance, fusion</primary></indexterm>, that work like the identically named functions from the standard library.</para>
  <para>The number of steps the iterator is to be incremented is passed to <function>boost::fusion::advance</function> as a template parameter. The example again uses <classname>boost::mpl::int_</classname> from Boost.MPL.</para>
  <para><function>boost::fusion::advance</function> returns an iterator of a different type from the one that was passed to the function. That’s why <xref linkend="ex.fusion_04" xrefstyle="enp" /> uses a second iterator <varname>it2</varname>. You can’t assign the return value from <function>boost::fusion::advance</function> to the first iterator <varname>it</varname>. <xref linkend="ex.fusion_04" xrefstyle="enp"/> writes <computeroutput>10</computeroutput> and <computeroutput>true</computeroutput> to standard output.</para>
  <para>In addition to the functions introduced in the example, Boost.Fusion provides other functions that work with iterators. These include the following: <function>boost::fusion::end</function><indexterm><primary>fusion::end</primary></indexterm><indexterm><primary>end, fusion</primary></indexterm>, <function>boost::fusion::distance</function><indexterm><primary>fusion::distance</primary></indexterm><indexterm><primary>distance, fusion</primary></indexterm>, <function>boost::fusion::next</function><indexterm><primary>fusion::next</primary></indexterm><indexterm><primary>next, fusion</primary></indexterm> and <function>boost::fusion::prior</function><indexterm><primary>fusion::prior</primary></indexterm><indexterm><primary>prior, fusion</primary></indexterm>.</para>
  <example xml:id="ex.fusion_05">
    <title>A heterogeneous vector with <classname>boost::fusion::vector</classname></title>
    <programlisting><xi:include href="../src/fusion_05/main.cpp" parse="text"/></programlisting>
  </example>
  <para>So far we’ve only seen one heterogeneous container, <classname>boost::fusion::tuple</classname>. <xref linkend="ex.fusion_05" xrefstyle="enp"/> introduces another container, <classname>boost::fusion::vector</classname><indexterm><primary>fusion::vector</primary></indexterm><indexterm><primary>vector, fusion</primary></indexterm>.</para>
  <para><classname>boost::fusion::vector</classname> is a vector: elements are accessed with indexes. Access is not implemented using the operator <methodname role="operator">operator[]</methodname>. Instead, it’s implemented using <function>boost::fusion::at</function><indexterm><primary>fusion::at</primary></indexterm><indexterm><primary>at, fusion</primary></indexterm>, a free-standing function. The index is passed as a template parameter wrapped with <classname>boost::mpl::int_</classname>.</para>
  <para>This example adds a new element of type <type>char</type> to the vector. This is done with the free-standing function <function>boost::fusion::push_back</function><indexterm><primary>fusion::push_back</primary></indexterm><indexterm><primary>push_back, fusion</primary></indexterm>. Two parameters are passed to <function>boost::fusion::push_back</function>: the vector to add the element to and the value to add.</para>
  <para><function>boost::fusion::push_back</function> returns a new vector. The vector <varname>v</varname> isn’t changed. The new vector is a copy of the original vector with the added element.</para>
  <para>This example gets the number of elements in the vectors <varname>v</varname> and <varname>v2</varname> with <function>boost::fusion::size</function><indexterm><primary>fusion::size</primary></indexterm><indexterm><primary>size, fusion</primary></indexterm> and writes both values to standard output. The program displays <computeroutput>4</computeroutput> and <computeroutput>5</computeroutput>. It then calls <function>boost::fusion::back</function><indexterm><primary>fusion::back</primary></indexterm><indexterm><primary>back, fusion</primary></indexterm> to get and write the last element in <varname>v2</varname> to standard output, in this case the value is <computeroutput>X</computeroutput>.</para>
  <para>If you look more closely at <xref linkend="ex.fusion_05" xrefstyle="enp"/>, you will notice that there is no difference between <classname>boost::fusion::tuple</classname> and <classname>boost::fusion::vector</classname>; they are the same. Thus, <xref linkend="ex.fusion_05" xrefstyle="enp"/> will also work with <classname>boost::fusion::tuple</classname>.</para>
  <para>Boost.Fusion provides additional heterogeneous containers, including: <classname>boost::fusion::deque</classname><indexterm><primary>fusion::deque</primary></indexterm><indexterm><primary>deque, fusion</primary></indexterm>, <classname>boost::fusion::list</classname><indexterm><primary>fusion::list</primary></indexterm><indexterm><primary>list, fusion</primary></indexterm> and <classname>boost::fusion::set</classname><indexterm><primary>fusion::set</primary></indexterm><indexterm><primary>set, fusion</primary></indexterm>. <xref linkend="ex.fusion_06" xrefstyle="enp"/> introduces <classname>boost::fusion::map</classname>,<indexterm><primary>fusion::map</primary></indexterm><indexterm><primary>map, fusion</primary></indexterm> a container for key/value pairs.</para>
  <example xml:id="ex.fusion_06">
    <title>A heterogeneous map with <classname>boost::fusion::map</classname></title>
    <programlisting><xi:include href="../src/fusion_06/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.fusion_06" xrefstyle="enp"/> creates a heterogeneous map with <function>boost::fusion::map</function>. The map’s type is <classname>boost::fusion::map</classname>, which isn’t written out in the example thanks to the keyword <code>auto</code>.</para>
  <para>A map of type <classname>boost::fusion::map</classname> stores key/value pairs like <classname>std::map</classname> does. However, the keys in the Fusion map are types. A key/value pair consists of a type and a value mapped to that type. The value may be a different type than the key. In <xref linkend="ex.fusion_06" xrefstyle="enp" />, the string <quote>Boost</quote> is mapped to the key <type>int</type>.</para>
  <para>After the map has been created, <function>boost::fusion::has_key</function><indexterm><primary>fusion::has_key</primary></indexterm><indexterm><primary>has_key, fusion</primary></indexterm> is called to check whether a key <classname>std::string</classname> exists. Then, <function>boost::fusion::at_key</function><indexterm><primary>fusion::at_key</primary></indexterm><indexterm><primary>at_key, fusion</primary></indexterm> is called to get the value mapped to that key. Because the number 10 is mapped to <classname>std::string</classname>, it is written to standard output.</para>
  <para>The key/value pair is then erased with <function>boost::fusion::erase_key</function><indexterm><primary>fusion::erase_key</primary></indexterm><indexterm><primary>erase_key, fusion</primary></indexterm>. This doesn’t change the map <varname>m</varname>. <function>boost::fusion::erase_key</function> returns a new map which is missing the erased key/value pair.</para>
  <para>The call to <function>boost::fusion::push_back</function> adds a new key/value pair to the map. The key is <type>float</type> and the value is <quote role="reverse">X</quote>. <function>boost::fusion::make_pair</function><indexterm><primary>fusion::make_pair</primary></indexterm><indexterm><primary>make_pair, fusion</primary></indexterm> is called to create the new key/value pair. This function is similar to <function>std::make_pair</function>.</para>
  <para>Finally, <function>boost::fusion::has_key</function> is called again to check whether the map has a key <classname>std::string</classname>. Because it was erased, <literal>false</literal> is returned.</para>
  <para>Please note that you don’t need to call <function>boost::fusion::has_key</function> to check whether a key exists before you call <function>boost::fusion::at_key</function>. If a key is passed to <function>boost::fusion::at_key</function> that doesn’t exist in the map, you get a compiler error.</para>
  <example xml:id="ex.fusion_07">
    <title>Fusion adaptors for structures</title>
    <programlisting><xi:include href="../src/fusion_07/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Boost.Fusion provides several macros that let you use structures as Fusion containers. This is possible because structures can act as heterogeneous containers. <xref linkend="ex.fusion_07" xrefstyle="enp"/> defines a structure which can be used as a Fusion container thanks to the macro <code>BOOST_FUSION_ADAPT_STRUCT</code><indexterm><primary>BOOST_FUSION_ADAPT_STRUCT, Boost.Fusion</primary></indexterm>. This makes it possible to use the structure with functions like <function>boost::fusion::at</function> or <function>boost::fusion::back</function>.</para>
  <example xml:id="ex.fusion_08">
    <title>Fusion support for <classname>std::pair</classname></title>
    <programlisting><xi:include href="../src/fusion_08/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Boost.Fusion supports structures such as <classname>std::pair</classname> and <classname>boost::tuple</classname> without having to use macros. You just need to include the header file <filename class="headerfile">boost/fusion/adapted.hpp</filename> (see <xref linkend="ex.fusion_08" xrefstyle="enp"/>).</para>
  <simplesect role="exercises" xml:id="boost.fusion-exercises">
    <title>Exercise</title>
    <para>Make <function>debug</function> write the member variables of the structures used in the program to standard output:</para>
    <informalexample>
      <programlisting><xi:include href="../exercises/fusion_01/main.cpp" parse="text"/></programlisting>
    </informalexample>
  </simplesect>
</chapter>
