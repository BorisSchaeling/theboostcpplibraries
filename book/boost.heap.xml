<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.heap">
  <title>Boost.Heap</title><indexterm><primary>Boost.Heap</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/heap">Boost.Heap</link> could have also been called Boost.PriorityQueue since the library provides several priority queues. However, the priority queues in Boost.Heap differ from <classname>std::priority_queue</classname> by supporting more functions.</para>
  <example xml:id="ex.heap_01">
    <title>Using <classname>boost::heap::priority_queue</classname></title>
    <programlisting><xi:include href="../src/heap_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.heap_01" xrefstyle="enp"/> uses the class <classname>boost::heap::priority_queue</classname><indexterm><primary>heap::priority_queue</primary></indexterm><indexterm><primary>priority_queue, heap</primary></indexterm>, which is defined in <filename class="headerfile">boost/heap/priority_queue.hpp</filename>. In general this class behaves like <classname>std::priority_queue</classname>, except it allows you to iterate over elements. The order of elements returned in the iteration is random.</para>
  <para>Objects of type <classname>boost::heap::priority_queue</classname> can be compared with each other. The comparison in <xref linkend="ex.heap_01" xrefstyle="enp"/> returns <literal>true</literal> because <varname>pq</varname> has more elements than <varname>pq2</varname>. If both queues had the same number of elements, the elements would be compared in pairs.</para>
  <example xml:id="ex.heap_02">
    <title>Using <classname>boost::heap::binomial_heap</classname></title>
    <programlisting><xi:include href="../src/heap_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.heap_02" xrefstyle="enp"/> introduces the class <classname>boost::heap::binomial_heap</classname><indexterm><primary>heap::binomial_heap</primary></indexterm><indexterm><primary>binomial_heap, heap</primary></indexterm>. In addition to allowing you to iterate over elements in priority order, it also lets you merge priority queues. Elements from one queue can be added to another queue.</para>
  <para>The example calls <methodname>merge</methodname><indexterm><primary>heap::binomial_heap::merge</primary></indexterm><indexterm><primary>merge, heap::binomial_heap</primary></indexterm> on the queue <varname>bh</varname>. The queue <varname>bh2</varname> is passed as a parameter. The call to <methodname>merge</methodname> moves the number 4 from <varname>bh2</varname> to <varname>bh</varname>. After the call, <varname>bh</varname> contains four numbers, and <varname>bh2</varname> is empty.</para>
  <para>The <code>for</code> loop calls <methodname>ordered_begin</methodname><indexterm><primary>heap::binomial_heap::ordered_begin</primary></indexterm><indexterm><primary>ordered_begin, heap::binomial_heap</primary></indexterm> and <methodname>ordered_end</methodname><indexterm><primary>heap::binomial_heap::ordered_end</primary></indexterm><indexterm><primary>ordered_end, heap::binomial_heap</primary></indexterm> on <varname>bh</varname>. <methodname>ordered_begin</methodname> returns an iterator that iterates from high priority elements to low priority elements. Thus, <xref linkend="ex.heap_02" xrefstyle="enp"/> writes the numbers 4, 3, 2, and 1 in order to standard output.</para>
  <example xml:id="ex.heap_03">
    <title>Changing elements in <classname>boost::heap::binomial_heap</classname></title>
    <programlisting><xi:include href="../src/heap_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para><classname>boost::heap::binomial_heap</classname> lets you change elements after they have been added to the queue. <xref linkend="ex.heap_03" xrefstyle="enp"/> saves a handle returned by <methodname>push</methodname><indexterm><primary>heap::binomial_heap::push</primary></indexterm><indexterm><primary>push, heap::binomial_heap</primary></indexterm>, making it possible to access the number 2 stored in <varname>bh</varname>.</para>
  <para><methodname>update</methodname><indexterm><primary>heap::binomial_heap::update</primary></indexterm><indexterm><primary>update, heap::binomial_heap</primary></indexterm> is a member function of <classname>boost::heap::binomial_heap</classname> that can be called to change an element. <xref linkend="ex.heap_03" xrefstyle="enp" /> calls the member function to replace 2 with 4. Afterwards, the element with the highest priority, now 4, is fetched with <methodname>top</methodname><indexterm><primary>heap::binomial_heap::top</primary></indexterm><indexterm><primary>top, heap::binomial_heap</primary></indexterm>.</para>
  <para>In addition to <methodname>update</methodname>, <classname>boost::heap::binomial_heap</classname> provides other member functions to change elements. The member functions <methodname>increase</methodname><indexterm><primary>heap::binomial_heap::increase</primary></indexterm><indexterm><primary>increase, heap::binomial_heap</primary></indexterm> or <methodname>decrease</methodname><indexterm><primary>heap::binomial_heap::decrease</primary></indexterm><indexterm><primary>decrease, heap::binomial_heap</primary></indexterm> can be called if you know in advance whether a change will result in a higher or lower priority. In <xref linkend="ex.heap_03" xrefstyle="enp"/>, the call to <methodname>update</methodname> could be replaced with a call to <methodname>increase</methodname> since the number is increased from 2 to 4.</para>
  <para>Boost.Heap provides additional priority queues whose member functions mainly differ in their runtime complexity. For example, you can use the class <classname>boost::heap::fibonacci_heap</classname><indexterm><primary>heap::fibonacci_heap</primary></indexterm><indexterm><primary>fibonacci_heap, heap</primary></indexterm> if you want the member function <methodname>push</methodname> to have a constant runtime complexity. The documentation on Boost.Heap provides a table with an overview of the runtime complexities of the various classes and functions.</para>
</chapter>
