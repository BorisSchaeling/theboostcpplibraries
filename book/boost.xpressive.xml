<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.xpressive">
  <title>Boost.Xpressive</title><indexterm><primary>Boost.Xpressive</primary></indexterm>
  <para>Like Boost.Regex, <link xlink:href="http://www.boost.org/libs/xpressive">Boost.Xpressive</link> provides functions to search strings using <emphasis role="concept">regular expressions</emphasis><indexterm><primary>regular expression, Boost.Xpressive</primary></indexterm>. However, Boost.Xpressive makes it possible to write down regular expressions as C++ code rather than strings. That makes it possible to check at compile time whether a regular expression is valid or not.</para>
  <para>Only Boost.Regex was incorporated into C++11. The standard library doesn’t provide any support for writing regular expressions as C++ code.</para>
  <para><filename class="headerfile">boost/xpressive/xpressive.hpp</filename> provides access to most library functions in Boost.Xpressive. For some functions, additional header files must be included. All definitions of the library can be found in the namespace <package>boost::xpressive</package>.</para>
  <example xml:id="ex.xpressive_01">
    <title>Comparing strings with <classname>boost::xpressive::regex_match</classname></title>
    <programlisting><xi:include href="../src/xpressive_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Boost.Xpressive basically provides the same functions as Boost.Regex, except they are defined in the namespace of Boost.Xpressive. <function>boost::xpressive::regex_match</function><indexterm><primary>xpressive::regex_match</primary></indexterm><indexterm><primary>regex_match, xpressive</primary></indexterm> compares strings, <function>boost::xpressive::regex_search</function><indexterm><primary>xpressive::regex_search</primary></indexterm><indexterm><primary>regex_search, xpressive</primary></indexterm> searches in strings, and <function>boost::xpressive::regex_replace</function><indexterm><primary>xpressive::regex_replace</primary></indexterm><indexterm><primary>regex_replace, xpressive</primary></indexterm> replaces characters in strings. You can see this in <xref linkend="ex.xpressive_01" xrefstyle="enp"/>, which uses the function <function>boost::xpressive::regex_match</function>, and which looks similar to <xref linkend="ex.regex_01" xrefstyle="ewp"/>.</para>
  <para>However, there is a fundamental difference between Boost.Xpressive and Boost.Regex. The type of the regular expression in Boost.Xpressive depends on the type of the string being searched. Because <varname>s</varname> is based on <classname>std::string</classname> in <xref linkend="ex.xpressive_01" xrefstyle="enp"/>, the type of the regular expression must be <classname>boost::xpressive::sregex</classname><indexterm><primary>xpressive::sregex</primary></indexterm><indexterm><primary>sregex, xpressive</primary></indexterm>. Compare this with <xref linkend="ex.xpressive_02" xrefstyle="enp"/>, where the regular expression is applied to a string of type <type>const char*</type>.</para>
  <example xml:id="ex.xpressive_02">
    <title><classname>boost::xpressive::cregex</classname> with strings of type <type>const char*</type></title>
    <programlisting><xi:include href="../src/xpressive_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para>For strings of type <type>const char*</type>, use the class <classname>boost::xpressive::cregex</classname><indexterm><primary>xpressive::cregex</primary></indexterm><indexterm><primary>cregex, xpressive</primary></indexterm>. If you use other string types, such as <classname>std::wstring</classname> or <type>const wchar_t*</type>, use <classname>boost::xpressive::wsregex</classname><indexterm><primary>xpressive::wsregex</primary></indexterm><indexterm><primary>wsregex, xpressive</primary></indexterm> or <classname>boost::xpressive::wcregex</classname><indexterm><primary>xpressive::wcregex</primary></indexterm><indexterm><primary>wcregex, xpressive</primary></indexterm>.</para>
  <para>You must call the static member function <methodname>compile</methodname><indexterm><primary>xpressive::sregex::compile</primary></indexterm><indexterm><primary>compile, xpressive::sregex</primary></indexterm> for regular expressions written as strings. The member function must be called on the type used for the regular expression.</para>
  <para>Boost.Xpressive supports direct initialization of regular expressions that are written as C++ code. The regular expression has to be expressed in the notation supported by Boost.Xpressive (see <xref linkend="ex.xpressive_03" xrefstyle="enp"/>).</para>
  <example xml:id="ex.xpressive_03">
    <title>A regular expression with C++ code</title>
    <programlisting><xi:include href="../src/xpressive_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para>The regular expression from <xref linkend="ex.xpressive_02" xrefstyle="enp"/>, which was written as the string <quote>\w+\s\w+</quote>, is now expressed in <xref linkend="ex.xpressive_03" xrefstyle="enp"/> as <code>+_w >> _s >> +_w</code>. It is exactly the same regular expression. Both examples search for at least one alphanumeric character followed by one space followed by at least one alphanumeric character.</para>
  <para>Boost.Xpressive makes it possible to write regular expressions with C++ code. The library provides objects for character groups. For example, the object <varname>_w</varname><indexterm><primary>xpressive::_w</primary></indexterm><indexterm><primary>_w, xpressive</primary></indexterm> is similar to <quote>\w</quote>. <varname>_s</varname><indexterm><primary>xpressive::_s</primary></indexterm><indexterm><primary>_s, xpressive</primary></indexterm> has the same meaning as <quote>\s</quote>.</para>
  <para>While <quote>\w</quote> and <quote>\s</quote> can be written one after another in a string, objects like <varname>_w</varname> and <varname>_s</varname> must be concatenated with an operator. Otherwise, the result wouldn’t be valid C++ code. Boost.Xpressive provides the operator <methodname role="operator">operator&gt;&gt;</methodname>, which is used in <xref linkend="ex.xpressive_03" xrefstyle="enp"/>.</para>
  <para>To express that at least one alphanumeric character should be found, <varname>_w</varname> is prefixed with a plus sign. While the syntax of regular expressions expects that quantifiers are put behind character groups &#x2013; like with <quote>\w+</quote> &#x2013; the plus sign must be put in front of <varname>_w</varname>. The plus sign is an unary operator, which in C++ must be put in front of an object.</para>
  <para>Boost.Xpressive emulates the rules of regular expressions as much as they can be emulated in C++. However, there are limits. For example, the question mark is a meta character in regular expressions to express that a preceding item is optional. Since the question mark isn’t a valid operator in C++, Boost.Xpressive replaces it with the exclamation mark. A notation like <quote>\w?</quote> becomes <code>!_w</code> with Boost.Xpressive because the exclamation mark must be prefixed.</para>
  <para>Boost.Xpressive supports actions that can be linked to expressions &#x2013; something Boost.Regex doesn’t support.</para>
  <example xml:id="ex.xpressive_04">
    <title>Linking actions to expressions</title>
    <programlisting><xi:include href="../src/xpressive_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.xpressive_04" xrefstyle="enp"/> returns <literal>true</literal> for <function>boost::xpressive::regex_match</function> and writes <computeroutput>Boost</computeroutput> to standard output.</para>
  <para>You can link actions to expressions. An action is executed when the respective expression is found. In <xref linkend="ex.xpressive_04" xrefstyle="enp"/>, the expression <code>+_w</code> is linked to the action <code>*boost::xpressive::ref(it) = _</code>. The action is a lambda function. The object <varname>_</varname><indexterm><primary>xpressive::_</primary></indexterm><indexterm><primary>_, xpressive</primary></indexterm> refers to characters found by the expression &#x2013; in this case the first word in <varname>s</varname>. The respective characters are assigned to the iterator <varname>it</varname>. Because <varname>it</varname> is an iterator of type <classname>std::ostream_iterator</classname>, which has been initialized with <varname>std::cout</varname>, <computeroutput>Boost</computeroutput> is written to standard output.</para>
  <para>Please note that you must use the function <function>boost::xpressive::ref</function><indexterm><primary>xpressive::ref</primary></indexterm><indexterm><primary>ref, xpressive</primary></indexterm> to wrap the iterator <varname>it</varname>. Only then it is possible to assign <varname>_</varname> to the iterator. <varname>_</varname> is an object provided by Boost.Xpressive in the namespace <package>boost::xpressive</package>, which normally couldn’t be assigned to an iterator of type <classname>std::ostream_iterator</classname>. Because the assignment happens only when the string <quote>Boost</quote> has been found with <code>+_w</code>, <function>boost::xpressive::ref</function> turns the assignment into a <emphasis role="concept">lazy</emphasis><indexterm><primary>lazy evaluation, Boost.Xpressive</primary></indexterm> operation. Although the code in square brackets attached to <code>+_w</code> is, according to C++ rules, immediately executed, the assignment to the iterator <varname>it</varname> can only occur when the regular expression is used. Thus, <code>*boost::xpressive::ref(it) = _</code> isn’t executed immediately.</para>
  <para><xref linkend="ex.xpressive_04" xrefstyle="enp"/> includes the header file <filename class="headerfile">boost/xpressive/regex_actions.hpp</filename>. This is required because actions aren’t available through <filename class="headerfile">boost/xpressive/xpressive.hpp</filename>.</para>
  <para>Like Boost.Regex, Boost.Xpressive supports iterators to split a string with regular expressions. The classes <classname>boost::xpressive::regex_token_iterator</classname><indexterm><primary>xpressive::regex_token_iterator</primary></indexterm><indexterm><primary>regex_token_iterator, xpressive</primary></indexterm> and <classname>boost::xpressive::regex_iterator</classname><indexterm><primary>xpressive::regex_iterator</primary></indexterm><indexterm><primary>regex_iterator, xpressive</primary></indexterm> do this. It is also possible to link a locale to a regular expression to use a locale other than the global one.</para>
</chapter>
