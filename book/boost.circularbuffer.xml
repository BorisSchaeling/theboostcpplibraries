<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.circularbuffer">
  <title>Boost.CircularBuffer</title><indexterm><primary>Boost.CircularBuffer</primary></indexterm>
  <para>The library <link xlink:href="http://www.boost.org/libs/circular_buffer">Boost.CircularBuffer</link> provides a <emphasis role="concept">circular buffer</emphasis><indexterm><primary>circular buffer, Boost.CircularBuffer</primary></indexterm>, which is a container with the following two fundamental properties:</para>
  <itemizedlist>
    <listitem>
      <para>The capacity of the circular buffer is constant and set by you. The capacity doesn’t change automatically when you call a member function such as <methodname>push_back</methodname>. Only you can change the capacity of the circular buffer. The size of the circular buffer can not exceed the capacity you set.</para>
    </listitem>
    <listitem>
      <para>Despite constant capacity, you can call <methodname>push_back</methodname> as often as you like to insert elements into the circular buffer. If the maximum size has been reached and the circular buffer is full, elements are overwritten.</para>
    </listitem>
  </itemizedlist>
  <para>A circular buffer makes sense when the amount of available memory is limited, and you need to prevent a container from growing arbitrarily big. Another example is continuous data flow where old data becomes irrelevant as new data becomes available. Memory is automatically reused by overwriting old data.</para>
  <para>To use the circular buffer from Boost.CircularBuffer, include the header file <filename class="headerfile">boost/circular_buffer.hpp</filename>. This header file defines the class <classname>boost::circular_buffer</classname><indexterm><primary>circular_buffer, Boost.CircularBuffer</primary></indexterm>.</para>
  <example xml:id="ex.circularbuffer_01">
    <title>Using <classname>boost::circular_buffer</classname></title>
    <programlisting><xi:include href="../src/circularbuffer_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><classname>boost::circular_buffer</classname> is a template and must be instantiated with a type. For instance, the circular buffer <varname>cb</varname> in <xref linkend="ex.circularbuffer_01" xrefstyle="enp"/> stores numbers of type <type>int</type>.</para>
  <para>The capacity of the circular buffer is specified when instantiating the class, not through a template parameter. The default constructor of <classname>boost::circular_buffer</classname> creates a buffer with a capacity of zero elements. Another constructor is available to set the capacity. In <xref linkend="ex.circularbuffer_01" xrefstyle="enp"/>, the buffer <varname>cb</varname> has a capacity of three elements.</para>
  <para>The capacity of a circular buffer can be queried by calling <methodname>capacity</methodname><indexterm><primary>circular_buffer::capacity</primary></indexterm><indexterm><primary>capacity, circular_buffer</primary></indexterm>. In <xref linkend="ex.circularbuffer_01" xrefstyle="enp"/>, <methodname>capacity</methodname> will return 3.</para>
  <para>The capacity is not equivalent to the number of stored elements. While the return value of <methodname>capacity</methodname> is constant, <methodname>size</methodname><indexterm><primary>circular_buffer::size</primary></indexterm><indexterm><primary>size, circular_buffer</primary></indexterm> returns the number of elements in the buffer, which may be different. The return value of <methodname>size</methodname> will always be between 0 and the capacity of the circular buffer.</para>
  <para><xref linkend="ex.circularbuffer_01" xrefstyle="enp"/> returns 0 the first time <methodname>size</methodname> is called since the buffer does not contain any data. After calling <methodname>push_back</methodname> three times, the buffer contains three elements, and the second call to <methodname>size</methodname> will return 3. Calling <methodname>push_back</methodname> again does not cause the buffer to grow. The three new numbers overwrite the previous three. Therefore, <methodname>size</methodname> will return 3 when called for the third time.</para>
  <para>As a verification, the stored numbers are written to standard output at the end of <xref linkend="ex.circularbuffer_01" xrefstyle="enp"/>. The output contains the numbers 3, 4, and 5 since the previously stored numbers have been overwritten.</para>
  <example xml:id="ex.circularbuffer_02">
    <title>Various member functions of <classname>boost::circular_buffer</classname></title>
    <programlisting><xi:include href="../src/circularbuffer_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.circularbuffer_02" xrefstyle="enp"/> uses the member functions <methodname>is_linearized</methodname><indexterm><primary>circular_buffer::is_linearized</primary></indexterm><indexterm><primary>is_linearized, circular_buffer</primary></indexterm>, <methodname>array_one</methodname><indexterm><primary>circular_buffer::array_one</primary></indexterm><indexterm><primary>array_one, circular_buffer</primary></indexterm>, <methodname>array_two</methodname><indexterm><primary>circular_buffer::array_two</primary></indexterm><indexterm><primary>array_two, circular_buffer</primary></indexterm> and <methodname>linearize</methodname><indexterm><primary>circular_buffer::linearize</primary></indexterm><indexterm><primary>linearize, circular_buffer</primary></indexterm>, which do not exist in other containers. These member functions clarify the internals of the circular buffer.</para>
  <para>A circular buffer is essentially comparable to <classname>std::vector</classname>. Because the beginning and end are well defined, a vector can be treated as a conventional C array. That is, memory is contiguous, and the first and last elements are always at the lowest and highest memory address. However, a circular buffer does not offer such a guarantee.</para>
  <para>Even though it may sound strange to talk about the beginning and end of a circular buffer, they do exist. Elements can be accessed via iterators, and <classname>boost::circular_buffer</classname> provides member functions such as <methodname>begin</methodname><indexterm><primary>circular_buffer::begin</primary></indexterm><indexterm><primary>begin, circular_buffer</primary></indexterm> and <methodname>end</methodname><indexterm><primary>circular_buffer::end</primary></indexterm><indexterm><primary>end, circular_buffer</primary></indexterm>. While you don’t need to be concerned about the position of the beginning and end when using iterators, the situation becomes a bit more complicated when accessing elements using regular pointers, unless you use <methodname>is_linearized</methodname>, <methodname>array_one</methodname>, <methodname>array_two</methodname>, and <methodname>linearize</methodname>.</para>
  <para>The member function <methodname>is_linearized</methodname> returns <literal>true</literal> if the beginning of the circular buffer is at the lowest memory address. In this case, all the elements in the buffer are stored consecutively from beginning to the end at increasing memory addresses, and elements can be accessed like a conventional C array.</para>
  <para>If <methodname>is_linearized</methodname> returns <literal>false</literal>, the beginning of the circular buffer is not at the lowest memory address, which is the case in <xref linkend="ex.circularbuffer_02" xrefstyle="enp" />. While the first three elements 0, 1, and 2 are stored in exactly this order, calling <methodname>push_back</methodname> for the fourth time will overwrite the number 0 with the number 3. Because 3 is the last element added by a call to <methodname>push_back</methodname>, it is now the new end of the circular buffer. The beginning is now the element with the number 1, which is stored at the next higher memory address. This means elements are no longer stored consecutively at increasing memory addresses.</para>
  <para>If the end of the circular buffer is at a lower memory address than the beginning, the elements can be accessed via two conventional C arrays. To avoid the need to calculate the position and size of each array, <classname>boost::circular_buffer</classname> provides the member functions <methodname>array_one</methodname> and <methodname>array_two</methodname>.</para>
  <para>Both <methodname>array_one</methodname> and <methodname>array_two</methodname> return a <classname>std::pair</classname> whose first element is a pointer to the corresponding array and whose second element is the size. <methodname>array_one</methodname> accesses the array at the beginning of the circular buffer, and <methodname>array_two</methodname> accesses the array at the end of the buffer.</para>
  <para>If the circular buffer is linearized and <methodname>is_linearized</methodname> returns <literal>true</literal>, <methodname>array_two</methodname> can be called, too. However, since there is only one array in the buffer, the second array contains no elements.</para>
  <para>To simplify matters and treat the circular buffer as a conventional C array, you can force a rearrangement of the elements by calling <methodname>linearize</methodname>. Once complete, you can access all stored elements using <methodname>array_one</methodname>, and you don’t need to use <methodname>array_two</methodname>.</para>
  <para>Boost.CircularBuffer offers an additional class called <classname>boost::circular_buffer_space_optimized</classname><indexterm><primary>circular_buffer_space_optimized, Boost.CircularBuffer</primary></indexterm>. This class is also defined in <filename class="headerfile">boost/circular_buffer.hpp</filename>. Although this class is used in the same way as <classname>boost::circular_buffer</classname>, it does not reserve any memory at instantiation. Rather, memory is allocated dynamically when elements are added until the capacity is reached. Removing elements releases memory accordingly. <classname>boost::circular_buffer_space_optimized</classname> manages memory more efficiently and, therefore, can be a better choice in certain scenarios. For example, it may be a good choice if you need a circular buffer with a large capacity, but your program doesn’t always use the full buffer.</para>
</chapter>
