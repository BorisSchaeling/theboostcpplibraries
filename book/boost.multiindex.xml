<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.multiindex">
  <title>Boost.MultiIndex</title><indexterm><primary>Boost.MultiIndex</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/multi_index">Boost.MultiIndex</link> makes it possible to define containers that support an arbitrary number of interfaces. While <classname>std::vector</classname> provides an interface that supports direct access to elements with an index and <classname>std::set</classname> provides an interface that sorts elements, Boost.MultiIndex lets you define containers that support both interfaces. Such a container could be used to access elements using an index and in a sorted fashion.</para>
  <para>Boost.MultiIndex can be used if elements need to be accessed in different ways and would normally need to be stored in multiple containers. Instead of having to store elements in both a vector and a set and then synchronizing the containers continuously, you can define a container with Boost.MultiIndex that provides a vector interface and a set interface.</para>
  <para>Boost.MultiIndex also makes sense if you need to access elements based on multiple different properties. In <xref linkend="ex.multiindex_01" xrefstyle="enp" />, animals are looked up by name and by number of legs. Without Boost.MultiIndex, two hash containers would be required &#x2013; one to look up animals by name and the other to look them up by number of legs.</para>
  <example xml:id="ex.multiindex_01">
    <title>Using <classname>boost::multi_index::multi_index_container</classname></title>
    <programlisting><xi:include href="../src/multiindex_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para>When you use Boost.MultiIndex, the first step is to define a new container. You have to decide which interfaces your new container should support and which element properties it should access.</para>
  <para>The class <classname>boost::multi_index::multi_index_container</classname><indexterm><primary>multi_index::multi_index_container</primary></indexterm><indexterm><primary>multi_index_container, multi_index</primary></indexterm>, which is defined in <filename class="headerfile">boost/multi_index_container.hpp</filename>, is used for every container definition. This is a class template that requires at least two parameters. The first parameter is the type of elements the container should store &#x2013; in <xref linkend="ex.multiindex_01" xrefstyle="enp" /> this is a user-defined class called <classname>animal</classname>. The second parameter is used to denote different indexes the container should provide.</para>
  <para>The key advantage of containers based on Boost.MultiIndex is that you can access elements via different interfaces. When you define a new container, you can specify the number and type of interfaces. The container in <xref linkend="ex.multiindex_01" xrefstyle="enp" /> needs to support searching for animals by name or number of legs, so two interfaces are defined. Boost.MultiIndex calls these interfaces indexes &#x2013; that’s where the library’s name comes from.</para>
  <para>Interfaces are defined with the help of the class <classname>boost::multi_index::indexed_by</classname><indexterm><primary>multi_index::indexed_by</primary></indexterm><indexterm><primary>indexed_by, multi_index</primary></indexterm>. Each interface is passed as a template parameter. Two interfaces of type <classname>boost::multi_index::hashed_non_unique</classname><indexterm><primary>multi_index::hashed_non_unique</primary></indexterm><indexterm><primary>hashed_non_unique, multi_index</primary></indexterm>, which is defined in <filename class="headerfile">boost/multi_index/hashed_index.hpp</filename>, are used in <xref linkend="ex.multiindex_01" xrefstyle="enp" />. Using these interfaces makes the container behave like <classname>std::unordered_set</classname> and look up values using a hash value.</para>
  <para>The class <classname>boost::multi_index::hashed_non_unique</classname> is a template as well and expects as its sole parameter a class that calculates hash values. Because both interfaces of the container need to look up animals, one interface calculates hash values for the name, while the other interface does so for the number of legs.</para>
  <para>Boost.MultiIndex offers the helper class template <classname>boost::multi_index::member</classname><indexterm><primary>multi_index::member</primary></indexterm><indexterm><primary>member, multi_index</primary></indexterm>, which is defined in <filename class="headerfile">boost/multi_index/member.hpp</filename>, to access a member variable. As seen in <xref linkend="ex.multiindex_01" xrefstyle="enp" />, several parameters have been specified to let <classname>boost::multi_index::member</classname> know which member variable of <classname>animal</classname> should be accessed and which type the member variable has.</para>
  <para>Even though the definition of <classname>animal_multi</classname> looks complicated at first, the class works like a map. The name and number of legs of an animal can be regarded as a key/value pair. The advantage of the container <classname>animal_multi</classname> over a map like <classname>std::unordered_map</classname> is that animals can be looked up by name or by number of legs. <classname>animal_multi</classname> supports two interfaces, one based on the name and one based on the number of legs. The interface determines which member variable is the key and which member variable is the value.</para>
  <para>To access a MultiIndex container, you need to select an interface. If you directly access the object <varname>animals</varname> using <methodname>insert</methodname><indexterm><primary>insert, Boost.MultiIndex</primary></indexterm> or <methodname>count</methodname><indexterm><primary>count, Boost.MultiIndex</primary></indexterm>, the first interface is used. In <xref linkend="ex.multiindex_01" xrefstyle="enp" />, this is the hash container for the member variable <varname>name</varname>. If you need a different interface, you must explicitly select it.</para>
  <para>Interfaces are numbered consecutively, starting at index 0 for the first interface. To access the second interface &#x2013; as shown in <xref linkend="ex.multiindex_01" xrefstyle="enp"/> &#x2013; call the member function <methodname>get</methodname><indexterm><primary>multi_index::multi_index_container::get</primary></indexterm><indexterm><primary>get, multi_index::multi_index_container</primary></indexterm> and pass in the index of the desired interface as the template parameter.</para>
  <para>The return value of <methodname>get</methodname> looks complicated. It accesses a class of the MultiIndex container called <classname>nth_index</classname><indexterm><primary>multi_index::multi_index_container::nth_index</primary></indexterm><indexterm><primary>nth_index, multi_index::multi_index_container</primary></indexterm> which, again, is a template. The index of the interface to be used must be specified as a template parameter. This index must be the same as the one passed to <methodname>get</methodname>. The final step is to access the type definition named <type>type</type> of <classname>nth_index</classname>. The value of <type>type</type> represents the type of the corresponding interface. The following examples use the keyword <code>auto</code> to simplify the code.</para>
  <para>Although you do not need to know the specifics of an interface, since they are automatically derived from <classname>nth_index</classname> and <type>type</type>, you should still understand what kind of interface is accessed. Since interfaces are numbered consecutively in the container definition, this can be answered easily, since the index is passed to both <methodname>get</methodname> and <classname>nth_index</classname>. Thus, <varname>legs_index</varname> is a hash interface that looks up animals by legs.</para>
  <para>Because data such as names and legs can be keys of the MultiIndex container, they cannot be arbitrarily changed. If the number of legs is changed after an animal has been looked up by name, an interface using legs as a key would be unaware of the change and would not know that a new hash value needs to be calculated.</para>
  <para>Just as the keys in a container of type <classname>std::unordered_map</classname> cannot be modified, neither can data stored within a MultiIndex container. Strictly speaking, all data stored in a MultiIndex container is constant. This includes member variables that aren’t used by any interface. Even if no interface accesses <varname>legs</varname>, <varname>legs</varname> cannot be changed.</para>
  <para>To avoid having to remove elements from a MultiIndex container and insert new ones, Boost.MultiIndex provides member functions to change values directly. Because these member functions operate on the MultiIndex container itself, and because no element in a container is modified directly, all interfaces will be notified and can calculate new hash values.</para>
  <example xml:id="ex.multiindex_02">
    <title>Changing elements in a MultiIndex container with <methodname>modify</methodname></title>
    <?dbfo keep-together="auto"?>
    <programlisting><xi:include href="../src/multiindex_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Every interface offered by Boost.MultiIndex provides the member function <methodname>modify</methodname><indexterm><primary>modify, Boost.MultiIndex</primary></indexterm>, which operates directly on the container. The object to be modified is identified through an iterator passed as the first parameter to <methodname>modify</methodname>. The second parameter is a function or function object that expects as its sole parameter an object of the type stored in the container. The function or function object can change the element as much as it wants. <xref linkend="ex.multiindex_02" xrefstyle="enp"/> illustrates how to use the member function <methodname>modify</methodname> to change an element.</para>
  <para>So far, only one interface has been introduced: <classname>boost::multi_index::hashed_non_unique</classname>, which calculates a hash value that does not have to be unique. In order to guarantee that no value is stored twice, use <classname>boost::multi_index::hashed_unique</classname><indexterm><primary>multi_index::hashed_unique</primary></indexterm><indexterm><primary>hashed_unique, multi_index</primary></indexterm>. Please note that values cannot be stored if they don’t satisfy the requirements of all interfaces of a particular container. If one interface does not allow you to store values multiple times, it does not matter whether another interface does allow it.</para>
  <example xml:id="ex.multiindex_03">
    <title>A MultiIndex container with <classname>boost::multi_index::hashed_unique</classname></title>
    <?dbfo keep-together="auto"?>
    <programlisting><xi:include href="../src/multiindex_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para>The container in <xref linkend="ex.multiindex_03" xrefstyle="enp"/> uses <classname>boost::multi_index::hashed_unique</classname> as the second interface. That means no two animals with the same number of legs can be stored in the container because the hash values would be the same.</para>
  <para>The example tries to store a dog, which has the same number of legs as the already stored cat. Because this violates the requirement of having unique hash values for the second interface, the dog will not be stored in the container. Therefore, when searching for animals with four legs, the program displays <computeroutput>1</computeroutput>, because only the cat was stored and counted.</para>
  <example xml:id="ex.multiindex_04">
    <title>The interfaces <classname>sequenced</classname>, <classname>ordered_non_unique</classname> and <classname>random_access</classname></title>
    <programlisting><xi:include href="../src/multiindex_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.multiindex_04" xrefstyle="enp" /> introduces the last three interfaces of Boost.MultiIndex: <classname>boost::multi_index::sequenced</classname><indexterm><primary>multi_index::sequenced</primary></indexterm><indexterm><primary>sequenced, multi_index</primary></indexterm>, <classname>boost::multi_index::ordered_non_unique</classname><indexterm><primary>multi_index::ordered_non_unique</primary></indexterm><indexterm><primary>ordered_non_unique, multi_index</primary></indexterm>, and <classname>boost::multi_index::random_access</classname><indexterm><primary>multi_index::random_access</primary></indexterm><indexterm><primary>random_access, multi_index</primary></indexterm>.</para>
  <para>The interface <classname>boost::multi_index::sequenced</classname> allows you to treat a MultiIndex container like a list of type <classname>std::list</classname>. Elements are stored in the given order.</para>
  <para>With the interface <classname>boost::multi_index::ordered_non_unique</classname>, objects are automatically sorted. This interface requires that you specify a sorting criterion when defining the container. <xref linkend="ex.multiindex_04" xrefstyle="enp"/> sorts objects of type <classname>animal</classname> by the number of legs using the helper class <classname>boost::multi_index::member</classname>.</para>
  <para><classname>boost::multi_index::ordered_non_unique</classname> provides special member functions to find specific ranges within the sorted values. Using <methodname>lower_bound</methodname><indexterm><primary>multi_index::ordered_non_unique::lower_bound</primary></indexterm><indexterm><primary>lower_bound, multi_index::ordered_non_unique</primary></indexterm> and <methodname>upper_bound</methodname><indexterm><primary>multi_index::ordered_non_unique::upper_bound</primary></indexterm><indexterm><primary>upper_bound, multi_index::ordered_non_unique</primary></indexterm>, the program searches for animals that have at least four and no more than eight legs. Because they require elements to be sorted, these member functions are not provided by other interfaces.</para>
  <para>The final interface introduced is <classname>boost::multi_index::random_access</classname>, which allows you to treat the MultiIndex container like a vector of type <classname>std::vector</classname>. The two most prominent member functions are <methodname role="operator">operator[]</methodname><indexterm><primary>multi_index::random_access::operator[]</primary></indexterm><indexterm><primary>operator[], multi_index::random_access</primary></indexterm> and <methodname>at</methodname><indexterm><primary>multi_index::random_access::at</primary></indexterm><indexterm><primary>at, multi_index::random_access</primary></indexterm>.</para>
  <para><classname>boost::multi_index::random_access</classname> includes <classname>boost::multi_index::sequenced</classname>. With <classname>boost::multi_index::random_access</classname>, all member functions of <classname>boost::multi_index::sequenced</classname> are available as well.</para>
  <para>Now that we’ve covered the four interfaces of Boost.MultiIndex, the remainder of this chapter focuses on <emphasis>key extractors</emphasis><indexterm><primary>key extractor, Boost.MultiIndex</primary></indexterm>. One of the key extractors has already been introduced: <classname>boost::multi_index::member</classname>, which is defined in <filename class="headerfile">boost/multi_index/member.hpp</filename>. This helper class is called a key extractor because it allows you to specify which member variable of a class should be used as the key of an interface.</para>
  <para><xref linkend="ex.multiindex_05" xrefstyle="enp"/> introduces two more key extractors.</para>
  <example xml:id="ex.multiindex_05">
    <title>The key extractors <classname>identity</classname> and <classname>const_mem_fun</classname></title>
    <programlisting><xi:include href="../src/multiindex_05/main.cpp" parse="text"/></programlisting>
  </example>
  <para>The key extractor <classname>boost::multi_index::identity</classname><indexterm><primary>multi_index::identity</primary></indexterm><indexterm><primary>identity, multi_index</primary></indexterm>, defined in <filename class="headerfile">boost/multi_index/identity.hpp</filename>, uses elements stored in the container as keys. This requires the class <classname>animal</classname> to be sortable because objects of type <classname>animal</classname> will be used as the key for the interface <classname>boost::multi_index::ordered_unique</classname>. In <xref linkend="ex.multiindex_05" xrefstyle="enp"/>, this is achieved through the overloaded <methodname role="operator">operator&lt;</methodname>.</para>
  <para>The header file <filename class="headerfile">boost/multi_index/mem_fun.hpp</filename> defines two key extractors &#x2013; <classname>boost::multi_index::const_mem_fun</classname><indexterm><primary>multi_index::const_mem_fun</primary></indexterm><indexterm><primary>const_mem_fun, multi_index</primary></indexterm> and <classname>boost::multi_index::mem_fun</classname><indexterm><primary>multi_index::mem_fun</primary></indexterm><indexterm><primary>mem_fun, multi_index</primary></indexterm> &#x2013; that use the return value of a member function as a key. In <xref linkend="ex.multiindex_05" xrefstyle="enp" />, the return value of <methodname>name</methodname> is used that way. <classname>boost::multi_index::const_mem_fun</classname> is used for constant member functions, while <classname>boost::multi_index::mem_fun</classname> is used for non-constant member functions.</para>
  <para>Boost.MultiIndex offers two more key extractors: <classname>boost::multi_index::global_fun</classname><indexterm><primary>multi_index::global_fun</primary></indexterm><indexterm><primary>global_fun, multi_index</primary></indexterm> and <classname>boost::multi_index::composite_key</classname><indexterm><primary>multi_index::composite_key</primary></indexterm><indexterm><primary>composite_key, multi_index</primary></indexterm>. The former can be used for free-standing or static member functions, and the latter allows you to design a key extractor made up of several other key extractors.</para>
  <simplesect role="exercises" xml:id="boost.multiindex-exercises">
    <title>Exercise</title>
    <para>Define the class <classname>animals_container</classname> with Boost.MultiIndex:</para>
    <informalexample>
      <programlisting><xi:include href="../exercises/multiindex_01/main.cpp" parse="text"/></programlisting>
    </informalexample>
  </simplesect>
</chapter>
