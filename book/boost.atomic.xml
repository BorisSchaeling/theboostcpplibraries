<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.atomic">
  <title>Boost.Atomic</title><indexterm><primary>Boost.Atomic</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/atomic">Boost.Atomic</link> provides the class <classname>boost::atomic</classname><indexterm><primary>atomic, Boost.Atomic</primary></indexterm>, which can be used to create atomic variables. They are called atomic variables because all access is atomic. Boost.Atomic is used in multithreaded programs when access to a variable in one thread shouldn’t be interrupted by another thread accessing the same variable. Without <classname>boost::atomic</classname>, attempts to access shared variables from multiple threads would need to be synchronized with locks.</para>
  <para><classname>boost::atomic</classname> depends on the target platform supporting atomic variable access. Otherwise, <classname>boost::atomic</classname> uses locks. The library allows you to detect whether a target platform supports atomic variable access.</para>
  <para>If your development environment supports C++11, you don’t need Boost.Atomic. The C++11 standard library provides a header file <filename class="headerfile">atomic</filename> that defines the same functionality as Boost.Atomic. For example, you will find a class named <classname>std::atomic</classname>.</para>
  <para>Boost.Atomic supports more or less the same functionality as the standard library. While a few functions are overloaded in Boost.Atomic, they may have different names in the standard library. The standard library also provides some functions, such as <function>std::atomic_init</function> and <function>std::kill_dependency</function>, which are missing in Boost.Atomic.</para>
  <example xml:id="ex.atomic_01">
    <title>Using <classname>boost::atomic</classname></title>
    <programlisting><xi:include href="../src/atomic_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.atomic_01" xrefstyle="enp"/> uses two threads to increment the <type>int</type> variable <varname>a</varname>. Instead of a lock, the example uses <classname>boost::atomic</classname> for atomic access to <varname>a</varname>. The example writes <computeroutput>2</computeroutput> to standard output.</para>
  <para><classname>boost::atomic</classname> works because some processors support atomic access on variables. If incrementing an <type>int</type> variable is an atomic operation, a lock isn’t required. If this example is run on a platform that cannot increment a variable as an atomic operation, <classname>boost::atomic</classname> uses a lock.</para>
  <example xml:id="ex.atomic_02">
    <title><classname>boost::atomic</classname> with or without lock</title>
    <programlisting><xi:include href="../src/atomic_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para>You can call <methodname>is_lock_free</methodname><indexterm><primary>atomic::is_lock_free</primary></indexterm><indexterm><primary>is_lock_free, atomic</primary></indexterm> on an atomic variable to check whether accessing the variable is done without a lock. If you run the example on an Intel x86 processor, it displays <computeroutput>true</computeroutput> three times. If you run it on a processor without lock-free access on <type>short</type>, <type>int</type> and <type>long</type> variables, <computeroutput>false</computeroutput> is displayed.</para>
  <para>Boost.Atomic provides the <code>BOOST_ATOMIC_INT_LOCK_FREE</code><indexterm><primary>BOOST_ATOMIC_INT_LOCK_FREE, Boost.Atomic</primary></indexterm> and <code>BOOST_ATOMIC_LONG_LOCK_FREE</code><indexterm><primary>BOOST_ATOMIC_LONG_LOCK_FREE, Boost.Atomic</primary></indexterm> macros to check, at compile time, which data types support lock-free access.</para>
  <para><xref linkend="ex.atomic_02" xrefstyle="enp" /> uses integral data types only. You should not use <classname>boost::atomic</classname> with classes like <classname>std::string</classname> or <classname>std::vector</classname>. Boost.Atomic supports integers, pointers, booleans (<type>bool</type>), and trivial classes. Examples of integral types include <type>short</type>, <type>int</type> and <type>long</type>. Trivial classes define objects that can be copied with <function>std::memcpy</function>.</para>
  <example xml:id="ex.atomic_03">
    <title><classname>boost::atomic</classname> with <varname>boost::memory_order_seq_cst</varname></title>
    <programlisting><xi:include href="../src/atomic_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.atomic_03" xrefstyle="enp"/> increments <varname>a</varname> twice &#x2013; this time not with <methodname role="operator">operator++</methodname> but with a call to <methodname>fetch_add</methodname><indexterm><primary>atomic::fetch_add</primary></indexterm><indexterm><primary>fetch_add, atomic</primary></indexterm>. The member function <methodname>fetch_add</methodname> can take two parameters: the number by which <varname>a</varname> should be incremented and the <emphasis role="concept">memory order</emphasis><indexterm><primary>memory order, Boost.Atomic</primary></indexterm>.</para>
  <para>The memory order specifies the order in which access operations on memory must occur. By default, this order is undetermined and does not depend on the order of the lines of code. Compilers and processors are allowed to change the order as long as a program behaves as if memory access operations were executed in source code order. This rule only applies to a thread. If more than one thread is used, variations in the order of memory accesses can lead to a program acting erroneously. Boost.Atomic supports specifying a memory order when accessing variables to make sure memory accesses occur in the desired order in a multithreaded program.</para>
  <note>
    <para>Specifying memory order optimizes performance, but it increases complexity and makes it more difficult to write correct code. Therefore, in practice, you should have a really good reason for using memory orders.</para>
  </note>
  <para><xref linkend="ex.atomic_03" xrefstyle="enp"/> uses the memory order <varname>boost::memory_order_seq_cst</varname><indexterm><primary>memory_order_seq_cst, Boost.Atomic</primary></indexterm> to increment <varname>a</varname> by 1. The memory order stands for <emphasis role="concept">sequential consistency</emphasis><indexterm><primary>sequential consistency, Boost.Atomic</primary></indexterm>. This is the most restrictive memory order. All memory accesses that appear before the <methodname>fetch_add</methodname> call must occur before this member function is executed. All memory accesses that appear after the <methodname>fetch_add</methodname> call must occur after this member function is executed. Compilers and processors may reorder memory accesses before and after the call to <methodname>fetch_add</methodname>, but they must not move a memory access from before to after the call to <methodname>fetch_add</methodname> or vice versa. <varname>boost::memory_order_seq_cst</varname> is a strict boundary for memory accesses in both directions.</para>
  <para><varname>boost::memory_order_seq_cst</varname> is the most restrictive memory order. It is used by default when memory order is not set. Therefore, in <xref linkend="ex.atomic_01" xrefstyle="enp"/>, when <varname>a</varname> is incremented with <methodname role="operator">operator++</methodname>, <varname>boost::memory_order_seq_cst</varname> will be used.</para>
  <para><varname>boost::memory_order_seq_cst</varname> isn’t always necessary. For example, in <xref linkend="ex.atomic_03" xrefstyle="enp"/> there is no need to synchronize memory accesses for other variables because <varname>a</varname> is the only variable the threads use. <varname>a</varname> is written to standard output in <function>main</function>, but only after both threads have terminated. The call to <methodname>join</methodname> guarantees that <varname>a</varname> is only read after both threads have finished.</para>
  <example xml:id="ex.atomic_04">
    <title><classname>boost::atomic</classname> with <varname>boost::memory_order_relaxed</varname></title>
    <programlisting><xi:include href="../src/atomic_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.atomic_04" xrefstyle="enp"/> sets the memory order to <varname>boost::memory_order_relaxed</varname><indexterm><primary>memory_order_relaxed, Boost.Atomic</primary></indexterm>. This is the least restrictive memory order: it allows arbitrary reordering of memory accesses. This example works with this memory order because the threads access no variables except <varname>a</varname>. Therefore, no specific order is required.</para>
  <example xml:id="ex.atomic_05">
    <title><classname>boost::atomic</classname> with <varname>memory_order_release</varname> and <varname>memory_order_acquire</varname></title>
    <programlisting><xi:include href="../src/atomic_05/main.cpp" parse="text"/></programlisting>
  </example>
  <para>There are choices between the most restrictive memory order, <varname>boost::memory_order_seq_cst</varname>, and the least restrictive one, <varname>boost::memory_order_relaxed</varname>. <xref linkend="ex.atomic_05" xrefstyle="enp"/> introduces the memory orders <varname>boost::memory_order_release</varname><indexterm><primary>memory_order_release, Boost.Atomic</primary></indexterm> and <varname>boost::memory_order_acquire</varname><indexterm><primary>memory_order_acquire, Boost.Atomic</primary></indexterm>.</para>
  <para>Memory accesses that appear in the code before the <varname>boost::memory_order_release</varname> statement are executed before the <varname>boost::memory_order_release</varname> statement is executed. Compilers and processors must not move memory accesses from before to after <varname>boost::memory_order_release</varname>. However, they may move memory accesses from after to before <varname>boost::memory_order_release</varname>.</para>
  <para><varname>boost::memory_order_acquire</varname> works like <varname>boost::memory_order_release</varname>, but refers to memory accesses after <varname>boost::memory_order_acquire</varname>. Compilers and processors must not move memory accesses from after the <varname>boost::memory_order_acquire</varname> statement to before it. However, they may move memory accesses from before to after <varname>boost::memory_order_acquire</varname>.</para>
  <para><xref linkend="ex.atomic_05" xrefstyle="enp"/> uses <varname>boost::memory_order_release</varname> in the first thread to make sure that <varname>b</varname> is set to 1 before <varname>a</varname> is set to 1. <varname>boost::memory_order_release</varname> guarantees that the memory access on <varname>b</varname> occurs before the memory access on <varname>a</varname>.</para>
  <para>To specify a memory order when accessing <varname>a</varname>, <methodname>store</methodname><indexterm><primary>atomic::store</primary></indexterm><indexterm><primary>store, atomic</primary></indexterm> is called. This member function corresponds to an assignment with <methodname role="operator">operator=</methodname>.</para>
  <para>The second thread reads <varname>a</varname> in a loop. This is done with the member function <methodname>load</methodname>. Again, no assignment operator is used.</para>
  <para>In the second thread, <varname>boost::memory_order_acquire</varname> makes sure that the memory access on <varname>b</varname> doesn’t occur before the memory access on <varname>a</varname>. The second thread waits in the loop for <varname>a</varname> to be set to 1 by the first thread. Once this happens, <varname>b</varname> is read.</para>
  <para>The example writes <computeroutput>1</computeroutput> to standard output. The memory orders ensure that all memory accesses occur in the right order. The first thread always writes 1 to <varname>b</varname> first before the second thread accesses and reads <varname>b</varname>.</para>
  <tip>
    <para>For more details and examples on how memory orders work, you can find an explanation in the <link xlink:href="http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync">GCC Wiki article on memory model synchronization modes</link>.</para>
  </tip>
</chapter>
