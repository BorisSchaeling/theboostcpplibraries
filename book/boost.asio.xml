<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.asio">
  <title>Boost.Asio</title><indexterm><primary>Boost.Asio</primary></indexterm>
  <para>This chapter introduces the library <link xlink:href="http://www.boost.org/libs/asio">Boost.Asio</link>. <acronym>Asio</acronym> stands for asynchronous input/output. This library makes it possible to process data asynchronously. Asynchronous means that when operations are initiated, the initiating program does not need to wait for the operation to end. Instead, Boost.Asio notifies a program when an operation has ended. The advantage is that other operations can be executed concurrently.</para>
  <para>Boost.Thread is another library that makes it possible to execute operations concurrently. The difference between Boost.Thread and Boost.Asio is that with Boost.Thread, you access resources inside of a program, and with Boost.Asio, you access resources outside of a program. For example, if you develop a function which needs to run a time-consuming calculation, you can call this function in a thread and make it execute on another CPU core. Threads allow you to access and use CPU cores. From the point of view of your program, CPU cores are an internal resource. If you want to access external resources, you use Boost.Asio.</para>
  <para>Network connections are an example of external resources. If data has to be sent or received, a network card is told to execute the operation. For a send operation, the network card gets a pointer to a buffer with the data to send. For a receive operation the network card gets a pointer to a buffer it should fill with the data being received. Since the network card is an external resource for your program, it can execute the operations independently. It only needs time &#x2013; time you could use in your program to execute other operations. Boost.Asio allows you to use the available devices more efficiently by benefiting from their ability to execute operations concurrently.</para>
  <para>Sending and receiving data over a network is implemented as an asynchronous operation in Boost.Asio. Think of an asynchronous operation as a function that immediately returns, but without any result. The result is handed over later.</para>
  <para>In the first step, an asynchronous operation is started. In the second step, a program is notified when the asynchronous operation has ended. This separation between starting and ending makes it possible to access external resources without having to call blocking functions.</para>
  <sect1 xml:id="boost.asio-io-services-and-io-objects">
    <title>I/O Services and I/O Objects</title>
    <para>Programs that use Boost.Asio for asynchronous data processing are based on <emphasis role="concept">I/O services</emphasis><indexterm><primary>I/O service, Boost.Asio</primary></indexterm> and <emphasis role="concept">I/O objects</emphasis><indexterm><primary>I/O object, Boost.Asio</primary></indexterm>. I/O services abstract the operating system interfaces that process data asynchronously. I/O objects initiate asynchronous operations. These two concepts are required to separate tasks cleanly: I/O services look towards the operating system API, and I/O objects look towards tasks developers need to do.</para>
    <para>As a user of Boost.Asio you normally don’t connect with I/O services directly. I/O services are managed by an <emphasis role="concept">I/O service object</emphasis><indexterm><primary>I/O service object, Boost.Asio</primary></indexterm>. An I/O service object is like a registry where I/O services are listed. Every I/O object knows its I/O service and gets access to its I/O service through the I/O service object.</para>
    <para>Boost.Asio defines <classname>boost::asio::io_service</classname><indexterm><primary>asio::io_service</primary></indexterm><indexterm><primary>io_service, asio</primary></indexterm>, a single class for an I/O service object. Every program based on Boost.Asio uses an object of type <classname>boost::asio::io_service</classname>. This can also be a global variable.</para>
    <para>While there is only one class for an I/O service object, several classes for I/O objects exist. Because I/O objects are task oriented, the class that needs to be instantiated depends on the task. For example, if data has to be sent or received over a TCP/IP connection, an I/O object of type <classname>boost::asio::ip::tcp::socket</classname> can be used. If data has to be transmitted asynchronously over a serial port, <classname>boost::asio::serial_port</classname> can be instantiated. If you want to wait for a time period to expire, you can use the I/O object <classname>boost::asio::steady_timer</classname><indexterm><primary>asio::steady_timer</primary></indexterm><indexterm><primary>steady_timer, asio</primary></indexterm>.</para>
    <para><classname>boost::asio::steady_timer</classname> is like an alarm clock. Instead of waiting for a blocking function to return when the alarm clock rings, your program will be notified. Because <classname>boost::asio::steady_timer</classname> just waits for a time period to expire, it would seem as though no external resource is accessed. However, in this case the external resource is the capability of the operating system to notify a program when a time period expires. This frees a program from creating a new thread just to call a blocking function. Since <classname>boost::asio::steady_timer</classname> is a very simple I/O object, it will be used to introduce Boost.Asio.</para>
    <note>
      <para>Because of a bug in Boost.Asio, it is not possible to compile some of the following examples with Clang. The bug has been reported in <link xlink:href="https://svn.boost.org/trac/boost/ticket/8835">ticket 8835</link>. As a workaround, if you replace the types from <package>std::chrono</package> with the respective types from <package>boost::chrono</package>, you can compile the examples with Clang.</para>
    </note>
    <example xml:id="ex.asio_01">
      <title>Using <classname>boost::asio::steady_timer</classname></title>
      <programlisting><xi:include href="../src/asio_01/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.asio_01" xrefstyle="enp"/> creates an I/O service object, <varname>ioservice</varname>, and uses it to initialize the I/O object <varname>timer</varname>. Like <classname>boost::asio::steady_timer</classname>, all I/O objects expect an I/O service object as a first parameter in their constructor. Since <varname>timer</varname> represents an alarm clock, a second parameter can be passed to the constructor of <classname>boost::asio::steady_timer</classname> that defines the specific time or time period when the alarm clock should ring. In <xref linkend="ex.asio_01" xrefstyle="enp"/>, the alarm clock is set to ring after 3 seconds. The time starts with the definition of <varname>timer</varname>.</para>
    <para>Instead of calling a blocking function that will return when the alarm clock rings, Boost.Asio lets you start an asynchronous operation. To do this, call the member function <methodname>async_wait</methodname><indexterm><primary>asio::steady_timer::async_wait</primary></indexterm><indexterm><primary>async_wait, asio::steady_timer</primary></indexterm>, which expects a <emphasis role="concept">handler</emphasis><indexterm><primary>handler, Boost.Asio</primary></indexterm> as the sole parameter. A handler is a function or function object that is called when the asynchronous operation ends. In <xref linkend="ex.asio_01" xrefstyle="enp"/>, a lambda function is passed as a handler.</para>
    <para><methodname>async_wait</methodname> returns immediately. Instead of waiting three seconds until the alarm clock rings, the lambda function is called after three seconds. When <methodname>async_wait</methodname> returns, a program can do something else.</para>
    <para>A member function like <methodname>async_wait</methodname> is called non-blocking. I/O objects usually also provide blocking member functions as alternatives. For example, you can call the blocking member function <methodname>wait</methodname><indexterm><primary>asio::steady_timer::wait</primary></indexterm><indexterm><primary>wait, asio::steady_timer</primary></indexterm> on <classname>boost::asio::steady_timer</classname>. Because this member function is blocking, no handler is passed. <methodname>wait</methodname> returns at a specific time or after a time period.</para>
    <para>The last statement in <function>main</function> in <xref linkend="ex.asio_01" xrefstyle="enp"/> is a call to <methodname>run</methodname><indexterm><primary>asio::io_service::run</primary></indexterm><indexterm><primary>run, asio::io_service</primary></indexterm> on the I/O service object. This call is required because operating system-specific functions have to take over control. Remember that it is the I/O service in the I/O service object which implements asynchronous operations based on operating system-specific functions.</para>
    <para>While <methodname>async_wait</methodname> initiates an asynchronous operation and returns immediately, <methodname>run</methodname> blocks. Many operating systems support asynchronous operations only through a blocking function. The following example shows why this usually isn’t a problem.</para>
    <example xml:id="ex.asio_02">
      <title>Two asynchronous operations with <classname>boost::asio::steady_timer</classname></title>
      <programlisting><xi:include href="../src/asio_02/main.cpp" parse="text"/></programlisting>
    </example>
    <para>In <xref linkend="ex.asio_02" xrefstyle="enp"/>, two objects of type <classname>boost::asio::steady_timer</classname> are used. The first I/O object is an alarm clock that rings after three seconds. The other is an alarm clock ringing after four seconds. After both time periods expire, the lambda functions that were passed to <methodname>async_wait</methodname> will be called.</para>
    <para><methodname>run</methodname> is called on the only I/O service object in this example. This call passes control to the operating system functions that execute asynchronous operations. With their help, the first lambda function is called after three seconds and the second lambda function after four seconds.</para>
    <para>It might come as a surprise that asynchronous operations require a call to a blocking function. However, this is not a problem because the program has to be prevented from exiting. If <methodname>run</methodname> wouldn’t block, <function>main</function> would return, and the program would exit. If you don’t want to wait for <methodname>run</methodname> to return, you only need to call <methodname>run</methodname> in a new thread.</para>
    <para>The reason why the examples above exit after a while is that <methodname>run</methodname> returns if there are no pending asynchronous operations. Once all alarm clocks have rung, no asynchronous operations exist that the program needs to wait for.</para>
  </sect1>
  <sect1 xml:id="boost.asio-scalability">
    <title>Scalability and Multithreading</title>
    <para>Developing a program based on a library like Boost.Asio differs from the usual C++ style. Functions that may take longer to return are no longer called in a sequential manner. Instead of calling blocking functions, Boost.Asio starts asynchronous operations. Functions which should be called after an operation has finished are now called within the corresponding handler. The drawback of this approach is the physical separation of sequentially executed functions, which can make code more difficult to understand.</para>
    <para>A library such as Boost.Asio is typically used to achieve greater efficiency. With no need to wait for an operation to finish, a program can perform other tasks in between. Therefore, it is possible to start several asynchronous operations that are all executed concurrently &#x2013; remember that asynchronous operations are usually used to access resources outside of a process. Since these resources can be different devices, they can work independently and execute operations concurrently.</para>
    <para>Scalability describes the ability of a program to effectively benefit from additional resources. With Boost.Asio it is possible to benefit from the ability of external devices to execute operations concurrently. If threads are used, several functions can be executed concurrently on available CPU cores. Boost.Asio with threads improves the scalability because your program can take advantage of internal and external devices that can execute operations independently or in cooperation with each other.</para>
    <para>If the member function <methodname>run</methodname> is called on an object of type <classname>boost::asio::io_service</classname>, the associated handlers are invoked within the same thread. By using multiple threads, a program can call <methodname>run</methodname> multiple times. Once an asynchronous operation is complete, the I/O service object will execute the handler in one of these threads. If a second operation is completed shortly after the first one, the I/O service object can execute the handler in a different thread. Now, not only can operations outside of a process be executed concurrently, but handlers within the process can be executed concurrently, too.</para>
    <example xml:id="ex.asio_03">
      <title>Two threads for the I/O service object to execute handlers concurrently</title>
      <programlisting><xi:include href="../src/asio_03/main.cpp" parse="text"/></programlisting>
    </example>
    <para>The previous example has been converted to a multithreaded program in <xref linkend="ex.asio_03" xrefstyle="enp"/>. With <classname>std::thread</classname>, two threads are created in <function>main</function>. <methodname>run</methodname> is called on the only I/O service object in each thread. This makes it possible for the I/O service object to use both threads to execute handlers when asynchronous operations complete.</para>
    <para>In <xref linkend="ex.asio_03" xrefstyle="enp"/>, both alarm clocks should ring after three seconds. Because two threads are available, both lambda functions can be executed concurrently. If the second alarm clock rings while the handler of the first alarm clock is being executed, the handler can be executed in the second thread. If the handler of the first alarm clock has already returned, the I/O service object can use any thread to execute the second handler.</para>
    <para>Of course, it doesn’t always make sense to use threads. <xref linkend="ex.asio_03" xrefstyle="enp"/> might not write the messages sequentially to the standard output stream. Instead, they might be mixed up. Both handlers, which may run in two threads concurrently, share the global resource <varname>std::cout</varname>. To avoid interruptions, access to <varname>std::cout</varname> would need to be synchronized. The advantage of threads is lost if handlers can’t be executed concurrently.</para>
    <example xml:id="ex.asio_04">
      <title>One thread for each of two I/O service objects to execute handlers concurrently</title>
      <programlisting><xi:include href="../src/asio_04/main.cpp" parse="text"/></programlisting>
    </example>
    <para>Calling <methodname>run</methodname> repeatedly on a single I/O service object is the recommended method to make a program based on Boost.Asio more scalable. However, instead of providing several threads to one I/O service object, you could also create multiple I/O service objects.</para>
    <para>Two I/O service objects are used next to two alarm clocks of type <classname>boost::asio::steady_timer</classname> in <xref linkend="ex.asio_04" xrefstyle="enp"/>. The program is based on two threads, with each thread bound to another I/O service object. The two I/O objects <varname>timer1</varname> and <varname>timer2</varname> aren’t bound to the same I/O service object anymore. They are bound to different objects.</para>
    <para><xref linkend="ex.asio_04" xrefstyle="enp"/> works the same as before. It’s not possible to give general advice about when it makes sense to use more than one I/O service object. Because <classname>boost::asio::io_service</classname> represents an operating system interface, any decision depends on the particular interface.</para>
    <para>On Windows, <classname>boost::asio::io_service</classname> is usually based on <acronym>IOCP</acronym>, on Linux, it is based on <function>epoll</function>. Having several I/O service objects means that several I/O completion ports will be used or <function>epoll</function> will be called multiple times. Whether this is better than using just one I/O completion port or one call to <function>epoll</function> depends on the individual case.</para>
  </sect1>
  <sect1 xml:id="boost.asio-network-programming">
    <title>Network programming</title>
    <para>Even though Boost.Asio can process any kind of data asynchronously, it is mainly used for network programming. This is because Boost.Asio supported network functions long before additional I/O objects were added. Network functions are a perfect use for asynchronous operations because the transmission of data over a network may take a long time, which means acknowledgments and errors may not be available as fast as the functions that send or receive data can execute.</para>
    <para>Boost.Asio provides many I/O objects to develop network programs. <xref linkend="ex.asio_05" xrefstyle="enp"/> uses the class <classname>boost::asio::ip::tcp::socket</classname><indexterm><primary>asio::ip::tcp::socket</primary></indexterm><indexterm><primary>socket, asio::ip::tcp</primary></indexterm> to establish a connection with another computer. This example sends a <acronym>HTTP</acronym> request to a web server to download the homepage.</para>
    <example xml:id="ex.asio_05">
      <title>A web client with <classname>boost::asio::ip::tcp::socket</classname></title>
      <programlisting><xi:include href="../src/asio_05/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.asio_05" xrefstyle="enp"/> uses three handlers: <function>connect_handler</function> and <function>read_handler</function> are called when the connection is established and data is received. <function>resolve_handler</function> is used for name resolution.</para>
    <para>Because data can only be received after a connection has been established, and because a connection can only be established after the name has been resolved, the various asynchronous operations are started in handlers. In <function>resolve_handler</function>, the iterator <varname>it</varname>, which points to an endpoint resolved from the name, is used with <varname>tcp_socket</varname> to establish a connection. In <function>connect_handler</function>, <varname>tcp_socket</varname> is accessed to send a <acronym>HTTP</acronym> request and start receiving data. Since all operations are asynchronous, handlers are passed to the respective functions. Depending on the operations, additional parameters may need to be passed. For example, the iterator <varname>it</varname> refers to an endpoint resolved from a name. The array <varname>bytes</varname> is used to store data received.</para>
    <para>In <function>main</function>, <classname>boost::asio::ip::tcp::resolver::query</classname><indexterm><primary>asio::ip::tcp::resolver::query</primary></indexterm><indexterm><primary>query, asio::ip::tcp::resolver</primary></indexterm> is instantiated to create an object <varname>q</varname>. <varname>q</varname> represents a query for the name resolver, an I/O object of type <classname>boost::asio::ip::tcp::resolver</classname><indexterm><primary>asio::ip::tcp::resolver</primary></indexterm><indexterm><primary>resolver, asio::ip::tcp</primary></indexterm>. By passing <varname>q</varname> to <methodname>async_resolve</methodname><indexterm><primary>asio::ip::tcp::resolver::async_resolve</primary></indexterm><indexterm><primary>async_resolve, asio::ip::tcp::resolver</primary></indexterm>, an asynchronous operation is started to resolve the name. <xref linkend="ex.asio_05" xrefstyle="enp" /> resolves the name <uri>theboostcpplibraries.com</uri>. After the asynchronous operation has been started, <methodname>run</methodname> is called on the I/O service object to pass control to the operating system.</para>
    <para>When the name has been resolved, <function>resolve_handler</function> is called. The handler first checks whether the name resolution has been successful. In this case <varname>ec</varname> is 0. Only then is the socket accessed to establish a connection. The address of the server to connect to is provided by the second parameter, which is of type <classname>boost::asio::ip::tcp::resolver::iterator</classname><indexterm><primary>asio::ip::tcp::resolver::iterator</primary></indexterm><indexterm><primary>iterator, asio::ip::tcp::resolver</primary></indexterm>. This parameter is the result of the name resolution.</para>
    <para>The call to <methodname>async_connect</methodname><indexterm><primary>asio::ip::tcp::socket::async_connect</primary></indexterm><indexterm><primary>async_connect, asio::ip::tcp::socket</primary></indexterm> is followed by a call to the handler <function>connect_handler</function>. Again <varname>ec</varname> is checked first to find out whether a connection could be established. If so, <methodname>async_read_some</methodname><indexterm><primary>asio::ip::tcp::socket::async_read_some</primary></indexterm><indexterm><primary>async_read_some, asio::ip::tcp::socket</primary></indexterm> is called on the socket. With this call, reading data begins. Data being received is stored in the array <varname>bytes</varname>, which is passed as a first parameter to <methodname>async_read_some</methodname>.</para>
    <para><function>read_handler</function> is called when one or more bytes have been received and copied to <varname>bytes</varname>. The parameter <varname>bytes_transferred</varname> of type <type>std::size_t</type> contains the number of bytes that have been received. As usual, the handler should check first <varname>ec</varname> whether the asynchronous operation was completed successfully. Only if this is the case is data written to standard output.</para>
    <para>Please note that <function>read_handler</function> calls <methodname>async_read_some</methodname> again after data has been written to <varname>std::cout</varname>. This is required because you can’t be sure that the entire homepage was downloaded and copied into <varname>bytes</varname> in a single asynchronous operation. The repeated calls to <methodname>async_read_some</methodname> followed by the repeated calls to <function>read_handler</function> only end when the connection is closed, which happens when the web server has sent the entire homepage. Then <function>read_handler</function> reports an error in <varname>ec</varname>. At this point, no further data is written to <varname>std::cout</varname> and <methodname>async_read</methodname> is not called on the socket. Because there are no pending asynchronous operations, the program exits.</para>
    <example xml:id="ex.asio_06">
      <title>A time server with <classname>boost::asio::ip::tcp::acceptor</classname></title>
      <programlisting><xi:include href="../src/asio_06/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.asio_06" xrefstyle="enp"/> is a time server. You can connect with a telnet client to get the current time. Afterwards the time server shuts down.</para>
    <para>The time server uses the I/O object <classname>boost::asio::ip::tcp::acceptor</classname><indexterm><primary>asio::ip::tcp::acceptor</primary></indexterm><indexterm><primary>acceptor, asio::ip::tcp</primary></indexterm> to accept an incoming connection from another program. You must initialize the object so it knows which protocol to use on which port. In the example, the variable <varname>tcp_endpoint</varname> of type <classname>boost::asio::ip::tcp::endpoint</classname><indexterm><primary>asio::ip::tcp::endpoint</primary></indexterm><indexterm><primary>endpoint, asio::ip::tcp</primary></indexterm> is used to tell <varname>tcp_acceptor</varname> to accept incoming connections of version 4 of the internet protocol on port 2014.</para>
    <para>After the acceptor has been initialized, <methodname>listen</methodname><indexterm><primary>asio::ip::tcp::acceptor::listen</primary></indexterm><indexterm><primary>listen, asio::ip::tcp::acceptor</primary></indexterm> is called to make the acceptor start listening. Then <methodname>async_accept</methodname><indexterm><primary>asio::ip::tcp::acceptor::async_accept</primary></indexterm><indexterm><primary>async_accept, asio::ip::tcp::acceptor</primary></indexterm> is called to accept the first connection attempt. A socket has to be passed as a first parameter to <methodname>async_accept</methodname>, which will be used to send and receive data on a new connection.</para>
    <para>Once another program establishes a connection, <function>accept_handler</function> is called. If the connection was established successfully, the current time is sent with <function>boost::asio::async_write</function><indexterm><primary>asio::async_write</primary></indexterm><indexterm><primary>async_write, asio</primary></indexterm>. This function writes all data in <varname>data</varname> to the socket. <classname>boost::asio::ip::tcp::socket</classname> also provides the member function <methodname>async_write_some</methodname><indexterm><primary>asio::ip::tcp::socket::async_write_some</primary></indexterm><indexterm><primary>async_write_some, asio::ip::tcp::socket</primary></indexterm>. This function calls the handler when at least one byte has been sent. Then the handler must check how many bytes were sent and how many still have to be sent. Then, once again, it has to call <methodname>async_write_some</methodname>. Repeatedly calculating the number of bytes left to send and calling <methodname>async_write_some</methodname> can be avoided by using <function>boost::asio::async_write</function>. The asynchronous operation that started with this function is only complete when all bytes in <varname>data</varname> have been sent.</para>
    <para>After the data has been sent, <function>write_handler</function> is called. This function calls <methodname>shutdown</methodname><indexterm><primary>asio::ip::tcp::socket::shutdown</primary></indexterm><indexterm><primary>shutdown, asio::ip::tcp::socket</primary></indexterm> with the parameter <varname>boost::asio::ip::tcp::socket::shutdown_send</varname>, which says the program is done sending data through the socket. Since there are no pending asynchronous operations, <xref linkend="ex.asio_06" xrefstyle="enp"/> exits. Please note that although <varname>data</varname> is only used in <function>accept_handler</function>, it can’t be a local variable. <varname>data</varname> is passed by reference through <function>boost::asio::buffer</function><indexterm><primary>asio::buffer</primary></indexterm><indexterm><primary>buffer, asio</primary></indexterm> to <function>boost::asio::async_write</function>. When <function>boost::asio::async_write</function> and <function>accept_handler</function> return, the asynchronous operation has started, but has not completed. <varname>data</varname> must exist until the asynchronous operation has completed. If <varname>data</varname> is a global variable, this is guaranteed.</para>
    <simplesect role="exercises" xml:id="boost.asio-network-programming-exercises">
      <title>Exercise</title>
      <para>Develop a client and a server which can transfer a file from one computer to another. When the server is started, it should display a list of IP addresses of all local interfaces and wait for the client to connect. When the client is started, an IP address from the server and the name of a local file should be passed as command line options. The client should transfer the file to the server which saves it to the current working directory. During transmission the client should display some sort of progress indicator so that the user knows that the transmission is ongoing. Implement the client and server with callbacks.</para>
    </simplesect>
  </sect1>
  <sect1 xml:id="boost.asio-coroutines">
    <title>Coroutines</title>
    <para>Since version 1.54.0, Boost.Asio supports coroutines. While you could use Boost.Coroutine directly, explicit support of coroutines in Boost.Asio makes it easier to use them.</para>
    <para>Coroutines let you create a structure that mirrors the actual program logic. Asynchronous operations don’t split functions, because there are no handlers to define what should happen when an asynchronous operation completes. Instead of having handlers call each other, the program can use a sequential structure.</para>
    <example xml:id="ex.asio_07">
      <title>Coroutines with Boost.Asio</title>
      <?dbfo keep-together="auto"?>
      <programlisting><xi:include href="../src/asio_07/main.cpp" parse="text"/></programlisting>
    </example>
    <para>The function to call to use coroutines with Boost.Asio is <function>boost::asio::spawn</function><indexterm><primary>asio::spawn</primary></indexterm><indexterm><primary>spawn, asio</primary></indexterm>. The first parameter passed must be an I/O service object. The second parameter is the function that will be the coroutine. This function must accept as its only parameter an object of type <classname>boost::asio::yield_context</classname>. It must have no return value. <xref linkend="ex.asio_07" xrefstyle="enp"/> uses <function>do_accept</function> and <function>do_write</function> as coroutines. If the function signature is different, as is the case for <function>do_write</function>, you must use an adapter like <classname>std::bind</classname> or a lambda function.</para>
    <para>Instead of a handler, you can pass an object of type <classname>boost::asio::yield_context</classname> to asynchronous functions. <function>do_accept</function> passes the parameter <varname>yield</varname> to <methodname>async_accept</methodname>. In <function>do_write</function>, <varname>yield</varname> is passed to <methodname>async_write</methodname>. These function calls still start asynchronous operations, but no handlers will be called when the operations complete. Instead, the context in which the asynchronous operations were started is restored. When these asynchronous operations complete, the program continues where it left off.</para>
    <para><function>do_accept</function> contains a <code>for</code> loop. A new socket is passed to <methodname>async_accept</methodname> every time the function is called. Once a client establishes a connection, <function>do_write</function> is called as a coroutine with <function>boost::asio::spawn</function> to send the current time to the client.</para>
    <para>The <code>for</code> loop makes it easy to see that the program can serve two clients before it exits. Because the example is based on coroutines, the repeated execution of an asynchronous operation can be implemented in a <code>for</code> loop. This improves the readability of the program since you don’t have to trace potential calls to handlers to find out when the last asynchronous operation will be completed. If the time server needs to support more than two clients, only the <code>for</code> loop has to be adapted.</para>
    <simplesect role="exercises" xml:id="boost.asio-coroutines-exercises">
      <title>Exercise</title>
      <para>Develop a client and a server which can transfer a file from one computer to another. When the server is started, it should display a list of IP addresses of all local interfaces and wait for the client to connect. When the client is started, an IP address from the server and the name of a local file should be passed as command line options. The client should transfer the file to the server which saves it to the current working directory. During transmission the client should display some sort of progress indicator so that the user knows that the transmission is ongoing. Implement the client and server with coroutines.</para>
    </simplesect>
  </sect1>
  <sect1 xml:id="boost.asio-platform-specific-io-objects">
    <title>Platform-specific I/O Objects</title>
    <para>So far, all of the examples in this chapter have been platform independent. I/O objects such as <classname>boost::asio::steady_timer</classname> and <classname>boost::asio::ip::tcp::socket</classname> are supported on all platforms. However, Boost.Asio also provides platform-specific I/O objects because some asynchronous operations are only available on certain platforms, for example, Windows or Linux.</para>
    <example xml:id="ex.asio_08">
      <title>Using <classname>boost::asio::windows::object_handle</classname></title>
      <programlisting><xi:include href="../src/asio_08/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.asio_08" xrefstyle="enp" /> uses the I/O object <classname>boost::asio::windows::object_handle</classname><indexterm><primary>asio::windows::object_handle</primary></indexterm><indexterm><primary>object_handle, asio::windows</primary></indexterm>, which is only available on Windows. <classname>boost::asio::windows::object_handle</classname>, which is based on the Windows function <function>RegisterWaitForSingleObject</function>, lets you start asynchronous operations for object handles. All handles accepted by <function>RegisterWaitForSingleObject</function> can be used with <classname>boost::asio::windows::object_handle</classname>. With <methodname>async_wait</methodname><indexterm><primary>asio::windows::object_handle::async_wait</primary></indexterm><indexterm><primary>async_wait, asio::windows::object_handle</primary></indexterm>, it is possible to wait asynchronously for an object handle to change.</para>
    <para><xref linkend="ex.asio_08" xrefstyle="enp"/> initializes the object <varname>obj_handle</varname> of type <classname>boost::asio::windows::object_handle</classname> with an object handle created with the Windows function <function>CreateEvent</function>. The handle is part of an <classname>OVERLAPPED</classname> structure whose address is passed to the Windows function <function>ReadDirectoryChangesW</function>. Windows uses <classname>OVERLAPPED</classname> structures to start asynchronous operations.</para>
    <para><function>ReadDirectoryChangesW</function> can be used to monitor a directory and wait for changes. To call the function asynchronously, an <classname>OVERLAPPED</classname> structure must be passed to <function>ReadDirectoryChangesW</function>. To report the completion of the asynchronous operation through Boost.Asio, an event handler is stored in the <classname>OVERLAPPED</classname> structure before it is passed to <function>ReadDirectoryChangesW</function>. This event handler is passed to <varname>obj_handle</varname> afterwards. When <methodname>async_wait</methodname><indexterm><primary>asio::windows::object_handle::async_wait</primary></indexterm><indexterm><primary>async_wait, asio::windows::object_handle</primary></indexterm> is called on <varname>obj_handle</varname>, the handler is executed when a change is detected in the observed directory.</para>
    <para>When you run <xref linkend="ex.asio_08" xrefstyle="enp"/>, create a new file in the directory from which you will run the example. The program will detect the new file and write a message to the standard output stream.</para>
    <example xml:id="ex.asio_09">
      <title>Using <classname>boost::asio::windows::overlapped_ptr</classname></title>
      <programlisting><xi:include href="../src/asio_09/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.asio_09" xrefstyle="enp"/> uses <function>ReadDirectoryChangesW</function> like the previous one to monitor a directory. This time, the asynchronous call to <function>ReadDirectoryChangesW</function> isn’t linked to an event handle. The example uses the class <classname>boost::asio::windows::overlapped_ptr</classname><indexterm><primary>asio::windows::overlapped_ptr</primary></indexterm><indexterm><primary>overlapped_ptr, asio::windows</primary></indexterm>, which uses an <classname>OVERLAPPED</classname> structure internally. <methodname>get</methodname><indexterm><primary>asio::windows::overlapped_ptr::get</primary></indexterm><indexterm><primary>get, asio::windows::overlapped_ptr</primary></indexterm> retrieves a pointer to the internal <classname>OVERLAPPED</classname> structure. In the example, the pointer is then passed to <function>ReadDirectoryChangesW</function>.</para>
    <para><classname>boost::asio::windows::overlapped_ptr</classname> is an I/O object that has no member function to start an asynchronous operation. The asynchronous operation is started by passing a pointer to the internal <classname>OVERLAPPED</classname> variable to a Windows function. In addition to an I/O service object, the constructor of <classname>boost::asio::windows::overlapped_ptr</classname> expects a handler that will be called when the asynchronous operation completes.</para>
    <para><xref linkend="ex.asio_09" xrefstyle="enp"/> uses <function>boost::asio::use_service</function><indexterm><primary>asio::use_service</primary></indexterm><indexterm><primary>use_service, asio</primary></indexterm> to get a reference to a service in the I/O service object <varname>ioservice</varname>. <function>boost::asio::use_service</function> is a function template. The type of the I/O service you want to fetch has to be passed as a template parameter. In the example, <type>boost::asio::detail::io_service_impl</type><indexterm><primary>asio::detail::io_service_impl</primary></indexterm><indexterm><primary>io_service_impl, asio::detail</primary></indexterm> is passed. This type of the I/O service is closest to the operating system. On Windows, <type>boost::asio::detail::io_service_impl</type> uses <acronym>IOCP</acronym>, and on Linux it uses <function>epoll</function>. <type>boost::asio::detail::io_service_impl</type> is a type definition that is set to <classname>boost::asio::detail::win_iocp_io_service</classname><indexterm><primary>asio::detail::win_iocp_io_service</primary></indexterm><indexterm><primary>win_iocp_io_service, asio::detail</primary></indexterm> on Windows and to <classname>boost::asio::detail::task_io_service</classname><indexterm><primary>asio::detail::task_io_service</primary></indexterm><indexterm><primary>task_io_service, asio::detail</primary></indexterm> on Linux.</para>
    <para><classname>boost::asio::detail::win_iocp_io_service</classname> provides the member function <methodname>register_handle</methodname><indexterm><primary>asio::detail::win_iocp_io_service::register_handle</primary></indexterm><indexterm><primary>register_handle, asio::detail::win_iocp_io_service</primary></indexterm> to link a handle to an <acronym>IOCP</acronym> handle. <methodname>register_handle</methodname> calls the Windows function <function>CreateIoCompletionPort</function>. This call is required for the example to work correctly. The handle returned by <function>CreateFileA</function> may be passed through <varname>overlapped</varname> to <function>ReadDirectoryChangesW</function> only after it is linked to an <acronym>IOCP</acronym> handle.</para>
    <para><xref linkend="ex.asio_09" xrefstyle="enp"/> checks whether <function>ReadDirectoryChangesW</function> has failed. If <function>ReadDirectoryChangesW</function> failed, <methodname>complete</methodname><indexterm><primary>asio::windows::overlapped_ptr::complete</primary></indexterm><indexterm><primary>complete, asio::windows::overlapped_ptr</primary></indexterm> is called on <varname>overlapped</varname> to complete the asynchronous operation for Boost.Asio. The parameters passed to <methodname>complete</methodname> are forwarded to the handler.</para>
    <para>If <function>ReadDirectoryChangesW</function> succeeds, <methodname>release</methodname><indexterm><primary>asio::windows::overlapped_ptr::release</primary></indexterm><indexterm><primary>release, asio::windows::overlapped_ptr</primary></indexterm> is called. The asynchronous operation is then pending and is only completed after the operation which was initiated with the Windows function <function>ReadDirectoryChangesW</function> has completed.</para>
    <example xml:id="ex.asio_10">
      <title>Using <classname>boost::asio::posix::stream_descriptor</classname></title>
      <programlisting><xi:include href="../src/asio_10/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.asio_10" xrefstyle="enp"/> introduces an I/O object for POSIX platforms.</para>
    <para><classname>boost::asio::posix::stream_descriptor</classname><indexterm><primary>asio::posix::stream_descriptor</primary></indexterm><indexterm><primary>stream_descriptor, asio::posix</primary></indexterm> can be initialized with a file descriptor to start an asynchronous operation on that file descriptor. In the example, <varname>stream</varname> is linked to the file descriptor <code>STDOUT_FILENO</code> to write a string asynchronously to the standard output stream.</para>
  </sect1>
</chapter>
