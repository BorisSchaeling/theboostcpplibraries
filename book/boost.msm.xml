<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.msm">
  <title>Boost.MetaStateMachine</title><indexterm><primary>Boost.MetaStateMachine</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/msm">Boost.MetaStateMachine</link> is used to define state machines. State machines describe objects through their states. They describe what states exist and what transitions between states are possible.</para>
  <para>Boost.MetaStateMachine provides three different ways to define state machines. The code you need to write to create a state machine depends on the front-end.</para>
  <para>If you go with the basic front-end or the function front-end, you define state machines in the conventional way: you create classes, derive them from other classes provided by Boost.MetaStateMachine, define required member variables, and write the required C++ code yourself. The fundamental difference between the basic front-end and the function front-end is that the basic front-end expects function pointers, while the function front-end lets you use function objects.</para>
  <para>The third front-end is called eUML and is based on a domain-specific language. This front-end makes it possible to define state machines by reusing definitions of a <acronym>UML</acronym> state machine. Developers familiar with <acronym>UML</acronym> can copy definitions from a <acronym>UML</acronym> behavior diagram to C++ code. You don’t need to translate <acronym>UML</acronym> definitions to C++ code.</para>
  <para>eUML is based on a set of macros that you must use with this front-end. The advantage of the macros is that you don’t need to work directly with many of the classes provided by Boost.MetaStateMachine. You just need to know which macros to use. This means you can’t forget to derive your state machine from a class, which can happen with the basic front-end or the function front-end. This chapter introduces Boost.MetaStateMachine with eUML.</para>
  <example xml:id="ex.metastatemachine_01">
    <title>Simple state machine with eUML</title>
    <programlisting><xi:include href="../src/metastatemachine_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.metastatemachine_01" xrefstyle="enp"/> uses the simplest state machine possible: A lamp has exactly two states. It is either on or off. If it is off, it can be switched on. If it is on, it can be switched off. It is possible to switch from every state to every other state.</para>
  <para><xref linkend="ex.metastatemachine_01" xrefstyle="enp"/> uses the eUML front-end to describe the state machine of a lamp. Boost.MetaStateMachine doesn’t have a master header file. Therefore, the required header files have to be included one by one. <filename class="headerfile">boost/msm/front/euml/euml.hpp</filename> and <filename class="headerfile">boost/msm/front/euml/state_grammar.hpp</filename> provide access to eUML macros. <filename class="headerfile">boost/msm/back/state_machine.hpp</filename> is required to link a state machine from the front-end to a state-machine from the back-end. While front-ends provide various possibilities to define state machines, the actual implementation of a state machine is found in the back-end. Since Boost.MetaStateMachine contains only one back-end, you don’t need to select an implementation.</para>
  <para>All of the definitions from Boost.MetaStateMachine are in the namespace <package>boost::msm</package>. Unfortunately, many eUML macros don’t refer explicitly to classes in this namespace. They use either the namespace <package>msm</package> or no namespace at all. That’s why <xref linkend="ex.metastatemachine_01" xrefstyle="enp" /> creates an alias for the namespace <package>boost::msm</package> and makes the definitions in <package>boost::msm::front::euml</package> available with a <code>using</code> directive. Otherwise the eUML macros lead to compiler errors.</para>
  <para>To use the state machine of a lamp, first define the states for off and on. States are defined with the macro <code>BOOST_MSM_EUML_STATE</code><indexterm><primary>BOOST_MSM_EUML_STATE, Boost.MetaStateMachine</primary></indexterm>, which expects the name of the state as its second parameter. The first parameter describes the state. You’ll see later how these descriptions look like. The two states defined in <xref linkend="ex.metastatemachine_01" xrefstyle="enp"/> are called <varname>Off</varname> and <varname>On</varname>.</para>
  <para>To switch between states, events are required. Events are defined with the macro <code>BOOST_MSM_EUML_EVENT</code><indexterm><primary>BOOST_MSM_EUML_EVENT, Boost.MetaStateMachine</primary></indexterm>, which expects the name of the event as its sole parameter. <xref linkend="ex.metastatemachine_01" xrefstyle="enp"/> defines an event called <varname>press</varname>, which represents the action of pressing the light switch. Since the same event switches a light on and off, only one event is defined.</para>
  <para>When the required states and events are defined, the macro <code>BOOST_MSM_EUML_TRANSITION_TABLE</code> is used to create a <emphasis role="concept">transition table</emphasis><indexterm><primary>transition table, Boost.MetaStateMachine</primary></indexterm>. This tables defines valid transitions between states and which events trigger which state transitions.</para>
  <para><code>BOOST_MSM_EUML_TRANSITION_TABLE</code><indexterm><primary>BOOST_MSM_EUML_TRANSITION_TABLE, Boost.MetaStateMachine</primary></indexterm> expects two parameters. The first parameter defines the transition table, and the second is the name of the transition table. The syntax of the first parameter is designed to make it easy to recognize how states and events relate to each other. For example, <code>Off + press == On</code> means that the machine in the state <varname>Off</varname> switches to the state <varname>On</varname> with the event <varname>press</varname>. The intuitive and self-explanatory syntax of a transition table definition is one of the strengths of the eUML front-end.</para>
  <para>After the transition table has been created, the state machine is defined with the macro <code>BOOST_MSM_EUML_DECLARE_STATE_MACHINE</code><indexterm><primary>BOOST_MSM_EUML_DECLARE_STATE_MACHINE, Boost.MetaStateMachine</primary></indexterm>. The second parameter is again the simpler one: it sets the name of the state machine. The state machine in <xref linkend="ex.metastatemachine_01" xrefstyle="enp"/> is named <classname>light_state_machine</classname>.</para>
  <para>The first parameter of <code>BOOST_MSM_EUML_DECLARE_STATE_MACHINE</code> is a tuple. The first value is the name of the transition table. The second value is an expression using <varname>init_</varname>, which is an attribute provided by Boost.MetaStateMachine. You’ll learn more about attributes later. The expression <code>init_ &lt;&lt; Off</code> is required to set the initial state of the state machine to <varname>Off</varname>.</para>
  <para>The state machine <classname>light_state_machine</classname>, defined with <code>BOOST_MSM_EUML_DECLARE_STATE_MACHINE</code>, is a class. You use this class to instantiate a state machine from the back-end. In <xref linkend="ex.metastatemachine_01" xrefstyle="enp"/> this is done by passing <classname>light_state_machine</classname> to the class template <classname>boost::msm::back::state_machine</classname><indexterm><primary>msm::back::state_machine</primary></indexterm><indexterm><primary>state_machine, msm::back</primary></indexterm> as a parameter. This creates a state machine called <varname>light</varname>.</para>
  <para>State machines provide a member function <methodname>process_event</methodname><indexterm><primary>msm::back::state_machine::process_event</primary></indexterm><indexterm><primary>process_event, msm::back::state_machine</primary></indexterm> to process events. If you pass an event to <methodname>process_event</methodname>, the state machines changes its state depending on its transition table.</para>
  <para>To make it easier to see what happens in <xref linkend="ex.metastatemachine_01" xrefstyle="enp"/> when <methodname>process_event</methodname> is called multiple times, <methodname>current_state</methodname> is called. This member function should only be used for debugging purposes. It returns a pointer to an <type>int</type>. Every state is an <type>int</type> value assigned in the order the states have been accessed in <code>BOOST_MSM_EUML_TRANSITION_TABLE</code>. In <xref linkend="ex.metastatemachine_01" xrefstyle="enp"/> <varname>Off</varname> is assigned the value 0 and <varname>On</varname> is assigned the value 1. The example writes <computeroutput>0</computeroutput>, <computeroutput>1</computeroutput>, and <computeroutput>0</computeroutput> to standard output. The light switch is pressed two times, which switches the light on and off.</para>
  <example xml:id="ex.metastatemachine_02">
    <title>State machine with state, event, and action</title>
    <programlisting><xi:include href="../src/metastatemachine_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.metastatemachine_02" xrefstyle="enp"/> extends the state machine for the lamp by an action. An action is executed by an event triggering a state transition. Because actions are optional, a state machine could be defined without them.</para>
  <para>Actions are defined with <code>BOOST_MSM_EUML_ACTION</code><indexterm><primary>BOOST_MSM_EUML_ACTION, Boost.MetaStateMachine</primary></indexterm>. Strictly speaking, a function object is defined. You must overload the operator <methodname role="operator">operator()</methodname>. The operator must accept four parameters. The parameters reference an event, a state machine and two states. You are free to define a template or use concrete types for all of the parameters. In <xref linkend="ex.metastatemachine_02" xrefstyle="enp"/>, concrete types are only set for the last two parameters. Because these parameters describe the beginning and ending states, you can overload <methodname role="operator">operator()</methodname> so that different member functions are executed for different switches.</para>
  <para>Please note that the states <varname>On</varname> and <varname>Off</varname> are objects. Boost.MetaStateMachine provides a macro <code>BOOST_MSM_EUML_STATE_NAME</code><indexterm><primary>BOOST_MSM_EUML_STATE_NAME, Boost.MetaStateMachine</primary></indexterm> to get the type of a state. If you use C++11, you can use the operator <code>decltype</code> instead of the macro.</para>
  <para>The action <varname>switch_light</varname>, which has been defined with <code>BOOST_MSM_EUML_ACTION</code>, is executed when the light switch is pressed. The transition table has been changed accordingly. The first transition is now <code>Off + press / switch_light == On</code>. You pass actions after a slash after the event. This transition means that the operator <methodname role="operator">operator()</methodname> of <varname>switch_light</varname> is called if the current state is <varname>Off</varname> and the event <varname>press</varname> happens. After the action has been executed, the new state is <varname>On</varname>.</para>
  <para><xref linkend="ex.metastatemachine_02" xrefstyle="enp"/> writes <computeroutput>Switching on</computeroutput> and then <computeroutput>Switching off</computeroutput> to standard output.</para>
  <example xml:id="ex.metastatemachine_03">
    <title>State machine with state, event, guard, and action</title>
    <programlisting><xi:include href="../src/metastatemachine_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.metastatemachine_03" xrefstyle="enp"/> uses a guard in the transition table. The definition of the first transition is <code>Off + press [!is_broken] / switch_light == On</code>. Passing <varname>is_broken</varname> in brackets means that the state machine checks before the action <varname>switch_light</varname> is called whether the transition may occur. This is called a guard. A guard must return a result of type <type>bool</type>.</para>
  <para>A guard like <varname>is_broken</varname> is defined with <code>BOOST_MSM_EUML_ACTION</code> in the same way as actions. Thus, the operator <methodname role="operator">operator()</methodname> has to be overloaded for the same four parameters. <methodname role="operator">operator()</methodname> must have a return value of type <type>bool</type> to be used as a guard.</para>
  <para>Please note that you can use logical operators like <methodname role="operator">operator!</methodname> on guards inside brackets.</para>
  <para>If you run the example, you’ll notice that nothing is written to standard output. The action <varname>switch_light</varname> is not executed &#x2013; the light stays off. The guard <varname>is_broken</varname> returns <literal>true</literal>. However, because the operator <methodname role="operator">operator!</methodname> is used, the expression in brackets evaluates to <literal>false</literal>.</para>
  <para>You can use guards to check whether a state transition can occur. <xref linkend="ex.metastatemachine_03" xrefstyle="enp"/> uses <varname>is_broken</varname> to check whether the lamp is broken. While a transition from off to on is usually possible and the transition table describes lamps correctly, in this example, the lamp cannot be switched on. Despite two calls to <methodname>process_event</methodname>, the state of <varname>light</varname> is <varname>Off</varname>.</para>
  <example xml:id="ex.metastatemachine_04">
    <title>State machine with state, event, entry action, and exit action</title>
    <programlisting><xi:include href="../src/metastatemachine_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para>In <xref linkend="ex.metastatemachine_04" xrefstyle="enp"/>, the first parameter passed to <code>BOOST_MSM_EUML_STATE</code> is a tuple consisting of <code>state_entry</code> and <code>state_exit</code>. <code>state_entry</code> is an entry action, and <code>state_exit</code> is an exit action. These actions are executed when a state is entered or exited.</para>
  <para>Like actions, entry and exit actions are defined with <code>BOOST_MSM_EUML_ACTION</code>. However, the overloaded operator <methodname role="operator">operator()</methodname> expects only three parameters: references to an event, a state machine, and a state. Transitions between states don’t matter for entry and exit actions, so only one state needs to be passed to <methodname role="operator">operator()</methodname>. For entry actions, this state is entered. For exit actions, this state is exited.</para>
  <para>In <xref linkend="ex.metastatemachine_04" xrefstyle="enp"/>, both states <varname>Off</varname> and <varname>On</varname> have entry and exit actions. Because the event <varname>press</varname> occurs twice, <computeroutput>Entering</computeroutput> and <computeroutput>Exiting</computeroutput> is displayed twice. Please note that <computeroutput>Exiting</computeroutput> is displayed first and <computeroutput>Entering</computeroutput> afterwards because the first action executed is an exit action.</para>
  <para>The first event <varname>press</varname> triggers a transition from <varname>Off</varname> to <varname>On</varname>, and <computeroutput>Exiting</computeroutput> and <computeroutput>Entering</computeroutput> are each displayed once. The second event <varname>press</varname> switches the state to <varname>Off</varname>. Again <computeroutput>Exiting</computeroutput> and <computeroutput>Entering</computeroutput> are each displayed once. Thus, state transitions execute the exit action first, then the entry action of the new state.</para>
  <example xml:id="ex.metastatemachine_05">
    <title>Attributes in a state machine</title>
    <programlisting><xi:include href="../src/metastatemachine_05/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.metastatemachine_05" xrefstyle="enp"/> uses the guard <varname>is_broken</varname> to check whether a state transition from <varname>Off</varname> to <varname>On</varname> is possible. This time the return value of <varname>is_broken</varname> depends on how often the light switch has been pressed. It is possible to switch the light on two times before the lamp is broken. To count how often the light has been switched on, an attribute is used.</para>
  <para>Attributes are variables that can be attached to objects. They let you adapt the behavior of state machines at run time. Because data such as how often the light has been switched on has to be stored somewhere, it makes sense to store it directly in the state machine, in a state, or in an event.</para>
  <para>Before an attribute can be used, it has to be defined. This is done with the macro <code>BOOST_MSM_EUML_DECLARE_ATTRIBUTE</code><indexterm><primary>BOOST_MSM_EUML_DECLARE_ATTRIBUTE, Boost.MetaStateMachine</primary></indexterm>. The first parameter passed to <code>BOOST_MSM_EUML_DECLARE_ATTRIBUTE</code> is the type, and the second is the name of the attribute. <xref linkend="ex.metastatemachine_05" xrefstyle="enp"/> defines the attribute <varname>switched_on</varname> of type <type>int</type>.</para>
  <para>After the attribute has been defined, it must be attached to an object. The example attaches the attribute <varname>switched_on</varname> to the state machine. This is done via the fifth value in the tuple, which is passed as the first parameter to <code>BOOST_MSM_EUML_DECLARE_STATE_MACHINE</code>. With <varname>attributes_</varname>, a keyword from Boost.MetaStateMachine is used to create a lambda function. To attach the attribute <varname>switched_on</varname> to the state machine, write <varname>switched_on</varname> to <varname>attributes_</varname> as though it were a stream, using <methodname role="operator">operator&lt;&lt;</methodname>.</para>
  <para>The third and fourth values in the tuples are both set to <varname>no_action</varname>. The attribute is passed as the fifth value in the tuple. The third and fourth values can be used to define entry and exit actions for the state machine. If no entry and exit actions are defined, use <varname>no_action</varname>.</para>
  <para>After the attribute has been attached to the state machine, it can be accessed with <methodname>get_attribute</methodname>. In <xref linkend="ex.metastatemachine_05" xrefstyle="enp"/>, this member function is called in the entry action <code>state_entry</code> to increment the value of the attribute. Because <code>state_entry</code> is only linked to the state <varname>On</varname>, <varname>switched_on</varname> is only incremented when the light is switched on.</para>
  <para><varname>switched_on</varname> is also accessed from the guard <varname>is_broken</varname>, which checks whether the value of the attribute is greater than 1. If it is, the guard returns <literal>true</literal>. Because attributes are initialized with the default constructor and <varname>switched_on</varname> is set to 0, <varname>is_broken</varname> returns <literal>true</literal> if the light has been switched on two times.</para>
  <para>In <xref linkend="ex.metastatemachine_05" xrefstyle="enp"/>, the event <varname>press</varname> occurs five times. The light is switched on and off two times and then switched on again. The first two times the light is switched on, <computeroutput>Switched on</computeroutput> is displayed. However, the third time the light is switched on there is no output. This happens because <varname>is_broken</varname> returns <literal>true</literal> after the light has been switched on two times, and therefore, there is no state transition from <varname>Off</varname> to <varname>On</varname>. This means the entry action for the state <varname>On</varname> is not executed, and the example does not write to standard output.</para>
  <example xml:id="ex.metastatemachine_06">
    <title>Accessing attributes in transition tables</title>
    <programlisting><xi:include href="../src/metastatemachine_06/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.metastatemachine_06" xrefstyle="enp"/> does the same thing as <xref linkend="ex.metastatemachine_05" xrefstyle="enp"/>: after switching the light on two times, the light is broken and can’t be switched on anymore. While the previous example accessed the attribute <varname>switched_on</varname> in actions, this example uses attributes in the transition table.</para>
  <para>Boost.MetaStateMachine provides the function <function>fsm_</function><indexterm><primary>msm::front::euml::fsm_</primary></indexterm><indexterm><primary>fsm_, msm::front::euml</primary></indexterm> to access an attribute in a state machine. That way a guard is defined that checks whether <varname>switched_on</varname> is smaller than 2. And an action is defined that increments <varname>switched_on</varname> every time the state switches from <varname>Off</varname> to <varname>On</varname>.</para>
  <para>Please note that the smaller-than comparison in the guard is done with <code>Int_&lt;2&gt;()</code>. The number 2 must be passed as a template parameter to <classname>Int_</classname><indexterm><primary>msm::front::euml::Int_</primary></indexterm><indexterm><primary>Int_, msm::front::euml</primary></indexterm> to create an instance of this class. That creates a function object that has the type needed by Boost.MetaStateMachine.</para>
  <para><xref linkend="ex.metastatemachine_06" xrefstyle="enp"/> also uses the macro <code>BOOST_MSM_EUML_FUNCTION</code><indexterm><primary>BOOST_MSM_EUML_FUNCTION, Boost.MetaStateMachine</primary></indexterm> to make a function an action. The first parameter passed to <code>BOOST_MSM_EUML_FUNCTION</code> is the name of the action that can be used in the function front-end. The second parameter is the name of the function. The third parameter is the name of the action as it is used in eUML. The fourth and fifth parameters are the return values for the function &#x2013; one for the case where the action is used for a state transition, and the other for the case where the action describes an entry or exit action. After <function>write_message</function> has been turned into an action this way, an object of type <classname>write_message_</classname> is created and used following <code>++fsm_(switched_on)</code> in the transition table. In a state transition from <varname>Off</varname> to <varname>On</varname>, the attribute <varname>switched_on</varname> is incremented and then <function>write_message</function> is called.</para>
  <para><xref linkend="ex.metastatemachine_06" xrefstyle="enp"/> displays <computeroutput>Switched on</computeroutput> twice, as in <xref linkend="ex.metastatemachine_05" xrefstyle="enp" />.</para>
  <para>Boost.MetaStateMachine provides additional functions, such as <function>state_</function><indexterm><primary>msm::front::euml::state_</primary></indexterm><indexterm><primary>state_, msm::front::euml</primary></indexterm> and <function>event_</function><indexterm><primary>msm::front::euml::event_</primary></indexterm><indexterm><primary>event_, msm::front::euml</primary></indexterm>, to access attributes attached to other objects. Other classes, such as <classname>Char_</classname><indexterm><primary>msm::front::euml::Char_</primary></indexterm><indexterm><primary>Char_, msm::front::euml</primary></indexterm> and <classname>String_</classname><indexterm><primary>msm::front::euml::String_</primary></indexterm><indexterm><primary>String_, msm::front::euml</primary></indexterm>, can also be used like <classname>Int_</classname>.</para>
  <tip>
    <para>As you can see in the examples, the front-end eUML requires you to use many macros. The header file <filename class="headerfile">boost/msm/front/euml/common.hpp</filename> contains definitions for all of the eUML macros, which makes it a useful reference.</para>
  </tip>
  <simplesect role="exercises" xml:id="boost.msm-exercises">
    <title>Exercises</title>
    <orderedlist>
      <listitem><para>Create a state machine for a window that can be closed, opened or tilted. A closed window can be opened or tilted. An open window can’t be tilted though without closing it first. Nor can a tilted window be opened without closing it first. Test your state machine by opening and tilting your window a couple of times. Use <methodname>current_state</methodname> to write states to standard output.</para></listitem>
      <listitem><para>Extend the state machine: The window should be part of a smart home. The state machine should now count how often the window was opened and tilted. To test your state machine open and tilt your window a couple of times. At the end of your program write to standard output how often the window was opened and how often it was tilted.</para></listitem>
    </orderedlist>
  </simplesect>
</chapter>
