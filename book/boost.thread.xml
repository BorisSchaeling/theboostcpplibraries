<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.thread">
  <title>Boost.Thread</title><indexterm><primary>Boost.Thread</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/thread">Boost.Thread</link> is the library that allows you to use threads. Furthermore, it provides classes to synchronize access on data which is shared by multiple threads.</para>
  <para>Threads have been supported by the standard library since C++11. You will also find classes in the standard library that threads can be created and synchronized with. While Boost.Thread resembles the standard library in many regards, it offers extensions. For example, you can interrupt threads created with Boost.Thread. You will also find special locks in Boost.Thread that will probably be added to the standard library with C++14. Thus, it can make sense to use Boost.Thread even if you work in a C++11 development environment.</para>
  <sect1 xml:id="boost.thread-management">
    <title>Creating and Managing Threads</title>
    <para>The most important class in this library is <classname>boost::thread</classname><indexterm><primary>thread, Boost.Thread</primary></indexterm>, which is defined in <filename class="headerfile">boost/thread.hpp</filename>. This class is used to create a new thread. <xref linkend="ex.thread_01" xrefstyle="enp"/> is a simple example that creates a thread.</para>
    <example xml:id="ex.thread_01">
      <title>Using <classname>boost::thread</classname></title>
      <programlisting><xi:include href="../src/thread_01/main.cpp" parse="text"/></programlisting>
    </example>
    <para>The name of the function that the new thread should execute is passed to the constructor of <classname>boost::thread</classname>. Once the variable <varname>t</varname> in <xref linkend="ex.thread_01" xrefstyle="enp"/> is created, the function <function>thread</function> starts immediately executing in its own thread. At this point, <function>thread</function> executes concurrently with the <function>main</function> function.</para>
    <para>To keep the program from terminating, <methodname>join</methodname><indexterm><primary>thread::join</primary></indexterm><indexterm><primary>join, thread</primary></indexterm> is called on the newly created thread. <methodname>join</methodname> blocks the current thread until the thread for which <methodname>join</methodname> was called has terminated. This causes <function>main</function> to wait until <function>thread</function> returns.</para>
    <para>A particular thread can be accessed using a variable &#x2013; <varname>t</varname> in this example &#x2013; to wait for its termination. However, the thread will continue to execute even if <varname>t</varname> goes out of scope and is destroyed. A thread is always bound to a variable of type <classname>boost::thread</classname> in the beginning, but once created, the thread no longer depends on that variable. There is even a member function called <methodname>detach</methodname><indexterm><primary>thread::detach</primary></indexterm><indexterm><primary>detach, thread</primary></indexterm> that allows a variable of type <classname>boost::thread</classname> to be decoupled from its corresponding thread. It’s not possible to call member functions like <methodname>join</methodname> after calling <methodname>detach</methodname> because the detached variable no longer represents a valid thread.</para>
    <para>Anything that can be done inside a function can also be done inside a thread. Ultimately, a thread is no different from a function, except that it is executed concurrently to another function. In <xref linkend="ex.thread_01" xrefstyle="np"/>, five numbers are written to the standard output stream in a loop. To slow down the output, every iteration of the loop calls the <function>wait</function> function to stall for one second. <function>wait</function> uses the function <function>sleep_for</function><indexterm><primary>this_thread::sleep_for</primary></indexterm><indexterm><primary>sleep_for, this_thread</primary></indexterm>, which is also provided by Boost.Thread and resides in the namespace <package>boost::this_thread</package>.</para>
    <para><function>sleep_for</function> expects as its sole parameter a period of time that indicates how long the current thread should be stalled. By passing an object of type <classname>boost::chrono::seconds</classname>, a period of time is set. <classname>boost::chrono::seconds</classname> comes from Boost.Chrono which is introduced in <xref linkend="boost.chrono"/>.</para>
    <para><function>sleep_for</function> only accepts types from Boost.Chrono. Even though Boost.Chrono has been part of the standard library with C++11, types from <package>std::chrono</package> cannot be used with Boost.Thread. Doing so will lead to compiler errors.</para>
    <para>If you don’t want to call <methodname>join</methodname> at the end of <methodname>main</methodname>, you can use the class <classname>boost::scoped_thread</classname>.</para>
    <example xml:id="ex.thread_02">
      <title>Waiting for a thread with <classname>boost::scoped_thread</classname></title>
      <programlisting><xi:include href="../src/thread_02/main.cpp" parse="text"/></programlisting>
    </example>
    <para>The constructor of <classname>boost::scoped_thread</classname><indexterm><primary>scoped_thread, Boost.Thread</primary></indexterm> expects an object of type <classname>boost::thread</classname>. In the destructor of <classname>boost::scoped_thread</classname> an action has access to that object. By default, <classname>boost::scoped_thread</classname> uses an action that calls <methodname>join</methodname> on the thread. Thus, <xref linkend="ex.thread_02" xrefstyle="enp"/> works like <xref linkend="ex.thread_01" xrefstyle="np"/>.</para>
    <para>You can pass a user-defined action as a template parameter. The action must be a class with an operator <methodname role="operator">operator()</methodname> that accepts an object of type <classname>boost::thread</classname>. <classname>boost::scoped_thread</classname> guarantees that the operator will be called in the destructor.</para>
    <para>You can find the class <classname>boost::scoped_thread</classname> only in Boost.Thread. There is no counterpart in the standard library. Make sure you include the header file <filename class="headerfile">boost/thread/scoped_thread.hpp</filename> for <classname>boost::scoped_thread</classname>.</para>
    <para><xref linkend="ex.thread_03" xrefstyle="enp"/> introduces <emphasis role="concept">interruption points</emphasis><indexterm><primary>interruption point, Boost.Thread</primary></indexterm>, which make it possible to interrupt threads. Interruption points are only supported by Boost.Thread and not by the standard library.</para>
    <example xml:id="ex.thread_03">
      <title>An interruption point with <function>boost::this_thread::sleep_for</function></title>
      <programlisting><xi:include href="../src/thread_03/main.cpp" parse="text"/></programlisting>
    </example>
    <para>Calling <methodname>interrupt</methodname><indexterm><primary>thread::interrupt</primary></indexterm><indexterm><primary>interrupt, thread</primary></indexterm> on a thread object interrupts the corresponding thread. In this context, interrupt means that an exception of type <exceptionname>boost::thread_interrupted</exceptionname><indexterm><primary>thread_interrupted, Boost.Thread</primary></indexterm> is thrown in the thread. However, this only happens when the thread reaches an interruption point.</para>
    <para>Simply calling <methodname>interrupt</methodname> does not have an effect if the given thread does not contain an interruption point. Whenever a thread reaches an interruption point it will check whether <methodname>interrupt</methodname> has been called. If it has been called, an exception of type <exceptionname>boost::thread_interrupted</exceptionname> will be thrown.</para>
    <para>Boost.Thread defines a series of interruption points such as the <function>sleep_for</function> function. Because <function>sleep_for</function> is called five times in <xref linkend="ex.thread_03" xrefstyle="enp"/>, the thread checks five times whether or not it has been interrupted. Between the calls to <function>sleep_for</function>, the thread can not be interrupted.</para>
    <para><xref linkend="ex.thread_03" xrefstyle="enp"/> doesn’t display five numbers, because <methodname>interrupt</methodname> is called after three seconds in <methodname>main</methodname>. Thus, the corresponding thread is interrupted and throws a <exceptionname>boost::thread_interrupted</exceptionname> exception. The exception is correctly caught inside the thread even though the <code>catch</code> handler is empty. Because the <function>thread</function> function returns after the handler, the thread terminates as well. This, in turn, will cause the program to terminate because <function>main</function> was waiting for the thread to terminate.</para>
    <?dbfo-need height="1in"?>
    <para>Boost.Thread defines about fifteen interruption points, including <function>sleep_for</function>. These interruption points make it easy to interrupt threads in a timely manner. However, interruption points may not always be the best choice because they must be reached before the thread can check for a <exceptionname>boost::thread_interrupted</exceptionname> exception.</para>
    <example xml:id="ex.thread_04">
      <title>Disabling interruption points with <classname>disable_interruption</classname></title>
      <programlisting><xi:include href="../src/thread_04/main.cpp" parse="text"/></programlisting>
    </example>
    <para>The class <classname>boost::this_thread::disable_interruption</classname><indexterm><primary>this_thread::disable_interruption</primary></indexterm><indexterm><primary>disable_interruption, this_thread</primary></indexterm> prevents a thread from being interrupted. If you instantiate <classname>boost::this_thread::disable_interruption</classname>, interruption points in a thread will be disabled as long as the object exists. Thus, <xref linkend="ex.thread_04" xrefstyle="enp"/> displays five numbers because the attempt to interrupt the thread is ignored.</para>
    <example xml:id="ex.thread_05">
      <title>Setting thread attributes with <classname>boost::thread::attributes</classname></title>
      <programlisting><xi:include href="../src/thread_05/main.cpp" parse="text"/></programlisting>
    </example>
    <para><classname>boost::thread::attributes</classname><indexterm><primary>thread::attributes</primary></indexterm><indexterm><primary>attributes, thread</primary></indexterm> is used to set thread attributes. In version 1.56.0, you can only set one platform-independent attribute, the stack size. In <xref linkend="ex.thread_05" xrefstyle="enp" />, the stack size is set to 1024 bytes by <methodname>boost::thread::attributes::set_stack_size</methodname><indexterm><primary>thread::attributes::set_stack_size</primary></indexterm><indexterm><primary>set_stack_size, thread::attributes</primary></indexterm>.</para>
    <example xml:id="ex.thread_06">
      <title>Detecting the thread ID and number of available processors</title>
      <programlisting><xi:include href="../src/thread_06/main.cpp" parse="text"/></programlisting>
    </example>
    <para>In the namespace <package>boost::this_thread</package>, free-standing functions are defined that apply to the current thread. One of these functions is <function>sleep_for</function>, which we have seen before. Another one is <function>get_id</function><indexterm><primary>this_thread::get_id</primary></indexterm><indexterm><primary>get_id, this_thread</primary></indexterm>, which returns a number to uniquely identify the current thread (see <xref linkend="ex.thread_06" xrefstyle="enp"/>). <function>get_id</function> is also provided as a member function by the class <classname>boost::thread</classname>.</para>
    <para>The static member function <methodname>boost::thread::hardware_concurrency</methodname><indexterm><primary>thread::hardware_concurrency</primary></indexterm><indexterm><primary>hardware_concurrency, thread</primary></indexterm> returns the number of threads that can physically be executed at the same time, based on the underlying number of CPUs or CPU cores. Calling this function on a dual-core processor returns a value of 2. This function provides a simple method to identify the theoretical maximum number of threads that should be used.</para>
    <para>Boost.Thread also provides the class <classname>boost::thread_group</classname><indexterm><primary>thread_group, Boost.Thread</primary></indexterm> to manage threads in groups. One function this class provides, the member function <methodname>join_all</methodname><indexterm><primary>thread_group::join_all</primary></indexterm><indexterm><primary>join_all, thread_group</primary></indexterm>, waits for all threads in the group to terminate.</para>
    <simplesect role="exercises" xml:id="boost.thread-management-exercises">
      <title>Exercises</title>
      <orderedlist>
        <listitem>
          <para>Use two threads to calculate the sum of all numbers which are added up in the <code>for</code>-loop:</para>
          <informalexample>
            <programlisting><xi:include href="../exercises/thread_01/main.cpp" parse="text"/></programlisting>
          </informalexample>
        </listitem>
        <listitem><para>Generalize the program so that it uses as many threads as can be executed concurrently on a computer. For example, the program should use four threads if it is run on a computer with a CPU with four cores.</para></listitem>
      </orderedlist>
    </simplesect>
  </sect1>
  <sect1 xml:id="boost.thread-synchronization">
    <title>Synchronizing Threads</title>
    <para>While using multiple threads can increase the performance of an application, it usually also increases complexity. If several functions execute at the same time, access to shared resources must be synchronized. This involves significant programming effort once the application reaches a certain size. This section introduces the classes provided by Boost.Thread to synchronize threads.</para>
    <example xml:id="ex.thread_07">
      <title>Exclusive access with <classname>boost::mutex</classname></title>
      <programlisting><xi:include href="../src/thread_07/main.cpp" parse="text"/></programlisting>
    </example>
    <para>Multithreaded programs use <emphasis role="concept">mutexes</emphasis><indexterm><primary>mutex (concept), Boost.Thread</primary></indexterm> for synchronization. Boost.Thread provides different mutex classes with <classname>boost::mutex</classname><indexterm><primary>mutex, Boost.Thread</primary></indexterm> being the simplest. The basic principle of a mutex is to prevent other threads from taking ownership while a particular thread owns the mutex. Once released, a different thread can take ownership. This causes threads to wait until the thread that owns the mutex has finished processing and releases its ownership of the mutex.</para>
    <para><xref linkend="ex.thread_07" xrefstyle="enp"/> uses a global mutex of type <classname>boost::mutex</classname> called <varname>mutex</varname>. The <function>thread</function> function takes ownership of this object by calling <methodname>lock</methodname><indexterm><primary>mutex::lock</primary></indexterm><indexterm><primary>lock, mutex</primary></indexterm>. This is done right before the function writes to the standard output stream. Once a message has been written, ownership is released by calling <methodname>unlock</methodname><indexterm><primary>mutex::unlock</primary></indexterm><indexterm><primary>unlock, mutex</primary></indexterm>.</para>
    <para><function>main</function> creates two threads, both of which are executing the <function>thread</function> function. Each thread counts to five and writes a message to the standard output stream in each iteration of the <code>for</code> loop. Because <varname>std::cout</varname> is a global object shared by the threads, access must be synchronized. Otherwise, messages could get mixed up. Synchronization guarantees that at any given time, only one thread has access to <varname>std::cout</varname>. Both threads try to acquire the mutex before writing to the standard output stream, but only one thread at a time actually accesses <varname>std::cout</varname>. No matter which thread successfully calls <methodname>lock</methodname>, all other threads need to wait until <methodname>unlock</methodname> has been called.</para>
    <para>Acquiring and releasing mutexes is a typical scheme and is supported by Boost.Thread through different types. For example, instead of using <methodname>lock</methodname> and <methodname>unlock</methodname>, you can use <classname>boost::lock_guard</classname><indexterm><primary>lock_guard, Boost.Thread</primary></indexterm>.</para>
    <example xml:id="ex.thread_08">
      <title><classname>boost::lock_guard</classname> with guaranteed mutex release</title>
      <?dbfo keep-together="auto"?>
      <programlisting><xi:include href="../src/thread_08/main.cpp" parse="text"/></programlisting>
    </example>
    <para><classname>boost::lock_guard</classname> automatically calls <methodname>lock</methodname> and <methodname>unlock</methodname> in its constructor and its destructor, respectively. Access to the shared resource is synchronized in <xref linkend="ex.thread_08" xrefstyle="enp"/> just as it was when both member functions were called explicitly. The class <classname>boost::lock_guard</classname> is an example of the RAII idiom to make sure resources are released when they are no longer needed.</para>
    <para>Besides <classname>boost::mutex</classname> and <classname>boost::lock_guard</classname>, Boost.Thread provides additional classes to support variants of synchronization. One of the essential ones is <classname>boost::unique_lock</classname><indexterm><primary>unique_lock, Boost.Thread</primary></indexterm> which provides several helpful member functions.</para>
    <example xml:id="ex.thread_09">
      <title>The versatile lock <classname>boost::unique_lock</classname></title>
      <programlisting><xi:include href="../src/thread_09/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.thread_09" xrefstyle="enp"/> uses two variants of the <function>thread</function> function. Both variants still write five numbers in a loop to the standard output stream, but they now use the class <classname>boost::unique_lock</classname> to lock a mutex.</para>
    <para><function>thread1</function> passes the variable <varname>mutex</varname> to the constructor of <classname>boost::unique_lock</classname>, which makes <classname>boost::unique_lock</classname> try to lock the mutex. In this case <classname>boost::unique_lock</classname> behaves no differently than <classname>boost::lock_guard</classname>. The constructor of <classname>boost::unique_lock</classname> calls <methodname>lock</methodname> on the mutex.</para>
    <para>However, the destructor of <classname>boost::unique_lock</classname> doesn’t release the mutex in <function>thread1</function>. In <function>thread1</function> <methodname>release</methodname><indexterm><primary>unique_lock::release</primary></indexterm><indexterm><primary>release, unique_lock</primary></indexterm> is called on the lock, which decouples the mutex from the lock. By default, the destructor of <classname>boost::unique_lock</classname> releases a mutex, like the destructor of <classname>boost::lock_guard</classname> &#x2013; but not if the mutex is decoupled. That’s why there is an explicit call to <methodname>unlock</methodname> in <function>thread1</function>.</para>
    <para><function>thread2</function> passes <varname>mutex</varname> and <varname>boost::try_to_lock</varname><indexterm><primary>try_to_lock, Boost.Thread</primary></indexterm> to the constructor of <classname>boost::unique_lock</classname>. This makes the constructor of <classname>boost::unique_lock</classname> not call <methodname>lock</methodname> on the mutex but <methodname>try_lock</methodname>. Thus, the constructor only tries to lock the mutex. If the mutex is owned by another thread, the try fails.</para>
    <para><methodname>owns_lock</methodname><indexterm><primary>unique_lock::owns_lock</primary></indexterm><indexterm><primary>owns_lock, unique_lock</primary></indexterm> lets you detect whether <classname>boost::unique_lock</classname> was able to lock a mutex. If <methodname>owns_lock</methodname> returns <literal>true</literal>, <function>thread2</function> can access <varname>std::cout</varname> immediately. If <methodname>owns_lock</methodname> returns <literal>false</literal>, <methodname>try_lock_for</methodname><indexterm><primary>unique_lock::try_lock_for</primary></indexterm><indexterm><primary>try_lock_for, unique_lock</primary></indexterm> is called. This member function also tries to lock a mutex, but it waits for the mutex for a specified period of time before failing. In <xref linkend="ex.thread_09" xrefstyle="enp"/> the lock tries for one second to obtain the mutex. If <methodname>try_lock_for</methodname> returns <literal>true</literal>, <varname>std::cout</varname> may be accessed. Otherwise, <function>thread2</function> gives up and skips a number. Thus, it is possible that the second thread in the example won’t write five numbers to the standard output stream.</para>
    <para>Please note that in <xref linkend="ex.thread_09" xrefstyle="enp"/>, the type of <varname>mutex</varname> is <classname>boost::timed_mutex</classname><indexterm><primary>timed_mutex, Boost.Thread</primary></indexterm>, not <classname>boost::mutex</classname>. The example uses <classname>boost::timed_mutex</classname> because this mutex is the only one that provides the member function <methodname>try_lock_for</methodname><indexterm><primary>timed_mutex::try_lock_for</primary></indexterm><indexterm><primary>try_lock_for, timed_mutex</primary></indexterm>. This member function is called when <methodname>try_lock_for</methodname> is called on the lock. <classname>boost::mutex</classname> provides only the member functions <methodname>lock</methodname> and <methodname>try_lock</methodname><indexterm><primary>mutex::try_lock</primary></indexterm><indexterm><primary>try_lock, mutex</primary></indexterm>.</para>
    <para><classname>boost::unique_lock</classname> is an <emphasis role="concept">exclusive lock</emphasis><indexterm><primary>exclusive lock, Boost.Thread</primary></indexterm>. An exclusive lock is always the sole owner of a mutex. Another lock can only get control of the mutex after the exclusive lock has released it. Boost.Thread also supports <emphasis role="concept">shared locks</emphasis><indexterm><primary>shared lock, Boost.Thread</primary></indexterm> with the class <classname>boost::shared_lock</classname><indexterm><primary>shared_lock, Boost.Thread</primary></indexterm>, which is used with <classname>shared_mutex</classname><indexterm><primary>shared_mutex, Boost.Thread</primary></indexterm>.</para>
    <example xml:id="ex.thread_10">
      <title>Shared locks with <classname>boost::shared_lock</classname></title>
      <programlisting><xi:include href="../src/thread_10/main.cpp" parse="text"/></programlisting>
    </example>
    <para>Non-exclusive locks of type <classname>boost::shared_lock</classname> can be used if threads only need read-only access to a specific resource. A thread modifying the resource needs write access and thus requires an exclusive lock. Since a thread with read-only access is unaffected by other threads reading the same resource at the same time, it can use a non-exclusive lock and share a mutex.</para>
    <para>In <xref linkend="ex.thread_10" xrefstyle="enp"/>, both <function>print</function> and <function>count</function> only read the variable <varname>random_numbers</varname>. The <function>print</function> function writes the last value in <varname>random_numbers</varname> to the standard output stream, and the <function>count</function> function adds it to the variable <varname>sum</varname>. Because neither function modifies <varname>random_numbers</varname>, both can access it at the same time using a non-exclusive lock of type <classname>boost::shared_lock</classname>.</para>
    <para>Inside the <function>fill</function> function, an exclusive lock of type <classname>boost::unique_lock</classname> is required because it inserts new random numbers into <varname>random_numbers</varname>. <function>fill</function> releases the mutex using the <methodname>unlock</methodname> member function and then waits for one second. Unlike the previous examples, <function>wait</function> is called at the end of the <code>for</code> loop to guarantee that at least one random number is placed in the container before it is accessed by either <function>print</function> or <function>count</function>. Both of these functions call the <function>wait</function> function at the beginning of their <code>for</code> loops.</para>
    <para>Looking at the individual calls to the <function>wait</function> function from different locations, one potential issue becomes apparent: The order of the function calls is directly affected by the order in which the CPU actually executes the individual threads. Using <emphasis role="concept">condition variables</emphasis><indexterm><primary>condition variable, Boost.Thread</primary></indexterm>, the individual threads can be synchronized so that values added to <varname>random_numbers</varname> are immediately processed by a different thread.</para>
    <example xml:id="ex.thread_11">
      <title>Condition variables with <classname>boost::condition_variable_any</classname></title>
      <programlisting><xi:include href="../src/thread_11/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.thread_11" xrefstyle="enp"/> removes the <function>wait</function> and <function>count</function> functions. Threads no longer wait for one second in every iteration; rather, they execute as fast as possible. In addition, no total is calculated; numbers are just written to the standard output stream.</para>
    <para>To ensure correct processing of the random numbers, the individual threads are synchronized using a condition variable, which can be checked for certain conditions between multiple threads.</para>
    <para>As before, the <function>fill</function> function generates a random number with each iteration and places it in the <varname>random_numbers</varname> container. To block other threads from accessing the container at the same time, an exclusive lock is used. Instead of waiting for one second, this example uses a condition variable. Calling <methodname>notify_all</methodname><indexterm><primary>condition_variable_any::notify_all</primary></indexterm><indexterm><primary>notify_all, condition_variable_any</primary></indexterm> will wake up every thread that has been waiting for this notification with <methodname>wait</methodname><indexterm><primary>condition_variable_any::wait</primary></indexterm><indexterm><primary>wait, condition_variable_any</primary></indexterm>.</para>
    <para>Looking at the <code>for</code> loop of the <function>print</function> function, you can see that the member function <methodname>wait</methodname> is called for the same condition variable. When the thread is woken up by a call to <function>notify_all</function>, it tries to acquire the mutex, which will only succeed after the mutex has been successfully released in the <function>fill</function> function.</para>
    <para>The trick here is that calling <methodname>wait</methodname> also releases the mutex which was passed as a parameter. After calling <methodname>notify_all</methodname>, the <function>fill</function> function releases the mutex by calling <methodname>wait</methodname>. It then blocks and waits for some other thread to call <methodname>notify_all</methodname>, which happens in the <function>print</function> function once the random number has been written to the standard output stream.</para>
    <para>Notice that the call to the <methodname>wait</methodname> member function inside the <function>print</function> function actually happens within a separate <code>while</code> loop. This is done to handle the scenario where a random number has already been placed in the container before the <methodname>wait</methodname> member function is called for the first time in <function>print</function>. By comparing the number of stored elements in <varname>random_numbers</varname> with the expected number of elements, this scenario is successfully handled and the random number is written to the standard output stream.</para>
    <para><xref linkend="ex.thread_11" xrefstyle="enp" /> also works if the locks aren’t local in the <code>for</code> loop but instantiated in the outer scope. In fact this makes more sense because the locks don’t need to be destroyed and recreated in every iteration. Since the mutex is always released with <methodname>wait</methodname>, you don’t need to destroy the locks at the end of an iteration.</para>
  </sect1>
  <sect1 xml:id="boost.thread-thread-local-storage">
    <title>Thread Local Storage</title>
    <para><emphasis role="concept">Thread Local Storage</emphasis><indexterm><primary>thread local storage, Boost.Thread</primary></indexterm> (TLS<indexterm><primary>TLS</primary><see>thread local storage, Boost.Thread</see></indexterm>) is a dedicated storage area that can only be accessed by one thread. TLS variables can be seen as global variables that are only visible to a particular thread and not the whole program.</para>
    <example xml:id="ex.thread_12">
      <title>Synchronizing multiple threads with static variables</title>
      <programlisting><xi:include href="../src/thread_12/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.thread_12" xrefstyle="enp"/> executes a function <function>thread</function> in three threads. <function>thread</function> calls another function <function>init</function> twice, and <function>init</function> checks whether the boolean variable <varname>done</varname> is <literal>false</literal>. If it is, the variable is set to <literal>true</literal> and <computeroutput>done</computeroutput> is written to standard output.</para>
    <para><varname>done</varname> is a static variable that is shared by all threads. If the first thread sets <varname>done</varname> to <literal>true</literal>, the second and third thread won’t write <computeroutput>done</computeroutput> to standard output. The second call of <function>init</function> in any thread won’t write <computeroutput>done</computeroutput> to standard output either. The example will print <computeroutput>done</computeroutput> once.</para>
    <para>A static variable like <varname>done</varname> can be used to do a one-time initialization in a process. To do a one-time initialization per thread, TLS can be used.</para>
    <example xml:id="ex.thread_13">
      <title>Synchronizing multiple threads with TLS</title>
      <programlisting><xi:include href="../src/thread_13/main.cpp" parse="text"/></programlisting>
    </example>
    <para>In <xref linkend="ex.thread_13" xrefstyle="enp"/>, the static variable <varname>done</varname> has been replaced with a TLS variable, <varname>tls</varname>, which is based on the class template <classname>boost::thread_specific_ptr</classname><indexterm><primary>thread_specific_ptr, Boost.Thread</primary></indexterm> &#x2013; instantiated with the type <type>bool</type>. In principle, <varname>tls</varname> works like <varname>done</varname>: It acts as a condition that indicates whether or not something has already been done. The crucial difference, however, is that the value stored by <varname>tls</varname> is only visible and available to the corresponding thread.</para>
    <para>Once a variable of type <classname>boost::thread_specific_ptr</classname> is created, it can be set. This variable expects the address of a variable of type <type>bool</type> instead of the variable itself. Using the <methodname>reset</methodname><indexterm><primary>thread_specific_ptr::reset</primary></indexterm><indexterm><primary>reset, thread_specific_ptr</primary></indexterm> member function, the address can be stored in <varname>tls</varname>. In <xref linkend="ex.thread_13" xrefstyle="enp"/>, a variable of type <type>bool</type> is dynamically allocated and its address, returned by <code>new</code>, is stored in <varname>tls</varname>. To avoid setting <varname>tls</varname> every time <function>init</function> is called, the member function <methodname>get</methodname><indexterm><primary>thread_specific_ptr::get</primary></indexterm><indexterm><primary>get, thread_specific_ptr</primary></indexterm> is used to check whether an address has already been stored.</para>
    <para>Because <classname>boost::thread_specific_ptr</classname> stores an address, this class behaves like a pointer. For example, it provides the member functions <methodname role="operator">operator*</methodname><indexterm><primary>thread_specific_ptr::operator*</primary></indexterm><indexterm><primary>operator*, thread_specific_ptr</primary></indexterm> and <methodname role="operator">operator-&gt;</methodname><indexterm><primary>thread_specific_ptr::operator-&gt;</primary></indexterm><indexterm><primary>operator-&gt;, thread_specific_ptr</primary></indexterm>, which work as you would expect them to work with pointers.</para>
    <para><xref linkend="ex.thread_13" xrefstyle="enp"/> prints <computeroutput>done</computeroutput> to standard output three times. Each thread prints <computeroutput>done</computeroutput> in the first call to <function>init</function>. Because a TLS variable is used, each thread uses its own variable <varname>tls</varname>. When the first thread initializes <varname>tls</varname> with a pointer to a dynamically allocated boolean variable, the <varname>tls</varname> variables in the second and third thread are still uninitialized. Since TLS variables are global per thread, not global per process, using <varname>tls</varname> in one thread does not change the variable in any other thread.</para>
  </sect1>
  <sect1 xml:id="boost.thread-futures-and-promises">
    <title>Futures and Promises</title>
    <para>Futures and promises are tools to pass data from one thread to another. While this could also be done with other capabilities, such as global variables, futures and promises work without them. Furthermore, you don’t need to handle synchronization yourself.</para>
    <para>A <emphasis role="concept">future</emphasis><indexterm><primary>future (concept), Boost.Thread</primary></indexterm> is a variable which receives a value from another thread. If you access a future to get the value, you might need to wait until the other thread has provided the value. Boost.Thread provides <classname>boost::future</classname><indexterm><primary>future, Boost.Thread</primary></indexterm> to define a future. The class defines a member function <methodname>get</methodname><indexterm><primary>future::get</primary></indexterm><indexterm><primary>get, future</primary></indexterm> to get the value. <methodname>get</methodname> is a blocking function that may have to wait for another thread.</para>
    <para>To set a value in a future, you need to use a <emphasis role="concept">promise</emphasis><indexterm><primary>promise (concept), Boost.Thread</primary></indexterm>, because <classname>boost::future</classname> does not provide a member function to set a value.</para>
    <para>Boost.Thread provides the class <classname>boost::promise</classname><indexterm><primary>promise, Boost.Thread</primary></indexterm>, which has a member function <methodname>set_value</methodname><indexterm><primary>promise::set_value</primary></indexterm><indexterm><primary>set_value, promise</primary></indexterm>. You always use future and promise as a pair. You can get a future from a promise with <methodname>get_future</methodname><indexterm><primary>promise::get_future</primary></indexterm><indexterm><primary>get_future, promise</primary></indexterm>. You can use the future and the promise in different threads. If a value is set in the promise in one thread, it can be fetched from the future in another thread.</para>
    <example xml:id="ex.thread_14">
      <title>Using <classname>boost::future</classname> and <classname>boost::promise</classname></title>
      <programlisting><xi:include href="../src/thread_14/main.cpp" parse="text"/><?dbhtml source="src/thread_14/main.cpp"?></programlisting>
    </example>
    <para><xref linkend="ex.thread_14" xrefstyle="enp"/> uses a future and a promise. The future <varname>f</varname> is received from the promise <varname>p</varname>. A reference to the promise is then passed to the thread <varname>t</varname> which executes the <function>accumulate</function> function. <function>accumulate</function> calculates the total of all numbers between 0 and 5 and saves it in the promise. In <function>main</function> <methodname>get</methodname> is called on the future to write the total to standard output.</para>
    <para>The future <varname>f</varname> and the promise <varname>p</varname> are linked. When <methodname>get</methodname> is called on the future, the value stored in the promise with <methodname>set_value</methodname> is returned. Because the example uses two threads, it is possible that <methodname>get</methodname> will be called in <function>main</function> before <function>accumulate</function> has called <methodname>set_value</methodname>. In that case, <methodname>get</methodname> blocks until a value has been stored in the promise with <methodname>set_value</methodname>.</para>
    <para><xref linkend="ex.thread_14" xrefstyle="enp"/> displays <computeroutput>10</computeroutput>.</para>
    <para><function>accumulate</function> had to be adapted to be executed in a thread. It has to take a parameter of type <classname>boost::promise</classname> and store the result in it. <xref linkend="ex.thread_15" xrefstyle="enp"/> introduces <classname>boost::packaged_task</classname>, a class that forwards a value from any function to a future as long as the function returns the result with <code>return</code>.</para>
    <example xml:id="ex.thread_15">
      <title>Using <classname>boost::packaged_task</classname></title>
      <programlisting><xi:include href="../src/thread_15/main.cpp" parse="text"/><?dbhtml source="src/thread_15/main.cpp"?></programlisting>
    </example>
    <para><xref linkend="ex.thread_15" xrefstyle="enp"/> is similar to the previous one, but this time <classname>boost::promise</classname> is not used. Instead, this example uses the class <classname>boost::packaged_task</classname><indexterm><primary>packaged_task, Boost.Thread</primary></indexterm>, which, like <classname>boost::promise</classname>, provides a member function <methodname>get_future</methodname><indexterm><primary>packaged_task::get_future</primary></indexterm><indexterm><primary>get_future, packaged_task</primary></indexterm> that returns a future.</para>
    <para>The constructor of <classname>boost::packaged_task</classname> expects as a parameter the function that will be executed in a thread, but <classname>boost::packaged_task</classname> doesn’t start a thread itself. An object of type <classname>boost::packaged_task</classname> has to be passed to the constructor of <classname>boost::thread</classname> for the function to be executed in a new thread.</para>
    <para>The advantage of <classname>boost::packaged_task</classname> is that it stores the return value of a function in a future. You don’t need to adapt a function to store its value in a future. <classname>boost::packaged_task</classname> can be seen as an adapter which can store the return value of any function in a future.</para>
    <para>While the example got rid of <classname>boost::promise</classname>, the following example doesn’t use <classname>boost::packaged_task</classname> and <classname>boost::thread</classname> either.</para>
    <example xml:id="ex.thread_16">
      <title>Using <function>boost::async</function></title>
      <programlisting><xi:include href="../src/thread_16/main.cpp" parse="text"/><?dbhtml source="src/thread_16/main.cpp"?></programlisting>
    </example>
    <para>In <xref linkend="ex.thread_16" xrefstyle="enp"/> <function>accumulate</function> is passed to the function <function>boost::async</function><indexterm><primary>async, Boost.Thread</primary></indexterm>. This function unifies <classname>boost::packaged_task</classname> and <classname>boost::thread</classname>. It starts <function>accumulate</function> in a new thread and returns a future.</para>
    <para>It is possible to pass a launch policy to <function>boost::async</function>. This additional parameter determines whether <function>boost::async</function> will execute the function in a new thread or in the current thread. If you pass <varname>boost::launch::async</varname><indexterm><primary>launch::async</primary></indexterm><indexterm><primary>async, launch</primary></indexterm>, <function>boost::async</function> will start a new thread; this is the default behavior. If you pass <varname>boost::launch::deferred</varname><indexterm><primary>launch::deferred</primary></indexterm><indexterm><primary>deferred, launch</primary></indexterm>, the function will be executed in the current thread when <function>get</function> is called.</para>
    <para>Although Boost 1.56.0 allows either <varname>boost::launch::async</varname> or <varname>boost::launch::deferred</varname> to be passed to <function>boost::async</function>, executing the function in the current thread is not yet implemented. If you pass <varname>boost::launch::deferred</varname>, the program will terminate.</para>
  </sect1>
</chapter>
