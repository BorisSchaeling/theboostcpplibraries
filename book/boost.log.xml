<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.log">
  <title>Boost.Log</title><indexterm><primary>Boost.Log</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/log">Boost.Log</link> is the logging library in Boost. It supports numerous back-ends to log data in various formats. Back-ends are accessed through front-ends that bundle services and forward log entries in different ways. For example, there is a front-end that uses a thread to forward log entries asynchronously. Front-ends can have filters to ignore certain log entries. And they define how log entries are formatted as strings. All these functions are extensible, which makes Boost.Log a powerful library.</para>
  <example xml:id="ex.log_01">
    <title>Back-end, front-end, core, and logger</title>
    <programlisting><xi:include href="../src/log_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.log_01" xrefstyle="enp" /> introduces the essential components of Boost.Log. Boost.Log gives you access to back-ends, front-ends, the core, and loggers:</para>
  <itemizedlist>
    <listitem>
      <para>Back-ends decide where data is written. <classname>boost::log::sinks::text_ostream_backend</classname><indexterm><primary>log::sinks::text_ostream_backend</primary></indexterm><indexterm><primary>text_ostream_backend, log::sinks</primary></indexterm> is initialized with a stream of type <classname>std::ostream</classname> and writes log entries to it.</para>
    </listitem>
    <listitem>
      <para>Front-ends are the connection between the core and a back-end. They implement various functions that don’t need to be implemented by each individual back-end. For example, filters can be added to a front-end to choose which log entries get forwarded to the back-end and which don’t.</para>
      <para><xref linkend="ex.log_01" xrefstyle="enp"/> uses the front-end <classname>boost::log::sinks::asynchronous_sink</classname><indexterm><primary>log::sinks::asynchronous_sink</primary></indexterm><indexterm><primary>asynchronous_sink, log::sinks</primary></indexterm>. You must use a front-end even if you don’t use filters. <classname>boost::log::sinks::asynchronous_sink</classname> uses a thread that forwards log entries to a back-end asynchronously. This can improve the performance but defers write operations.</para>
    </listitem>
    <listitem>
      <para>The core is the central component that all log entries are routed through. It is implemented as a singleton. To get a pointer to the core, call <methodname>boost::log::core::get</methodname><indexterm><primary>log::core::get</primary></indexterm><indexterm><primary>get, log::core</primary></indexterm>.</para>
      <para>Front-ends must be added to the core to receive log entries. Whether log entries are forwarded to front-ends depends on the filter in the core. Filters can be registered either in front-ends or in the core. Filters registered in the core are global, and filters registered in front-ends are local. If a log entry is filtered out by the core, it isn’t forwarded to any front-end. If it is filtered by a front-end, it can still be processed by other front-ends and forwarded to their back-ends.</para>
    </listitem>
    <listitem>
      <para>The logger is the component in Boost.Log you will use most often. While you access back-ends, front-ends, and the core only when you initialize the logging library, you use a logger every time you write a log entry. The logger forwards the entry to the core.</para>
      <para>The logger in <xref linkend="ex.log_01" xrefstyle="enp"/> is of the type <classname>boost::log::sources::logger</classname><indexterm><primary>log::sources::logger</primary></indexterm><indexterm><primary>logger, log::sources</primary></indexterm>. This is the simplest logger. When you want to write a log entry, use the macro <code>BOOST_LOG</code><indexterm><primary>BOOST_LOG, Boost.Log</primary></indexterm> and pass the logger as a parameter. The log entry is created by writing data into the macro as if it is a stream of type <classname>std::ostream</classname>.</para>
    </listitem>
  </itemizedlist>
  <para>Back-end, front-end, core, and logger work together. <classname>boost::log::sinks::asynchronous_sink</classname>, a front-end, is a template that receives the back-end <classname>boost::log::sinks::text_ostream_backend</classname> as a parameter. Afterwards, the front-end is instantiated with <classname>boost::shared_ptr</classname>. The smart pointer is required to register the front-end in the core: the call to <methodname>boost::log::core::add_sink</methodname><indexterm><primary>log::core::add_sink</primary></indexterm><indexterm><primary>add_sink, log::core</primary></indexterm> expects a <classname>boost::shared_ptr</classname>.</para>
  <para>Because the back-end is a template parameter of the front-end, it can only be configured after the front-end has been instantiated. The back-end determines how this is done. The member function <methodname>add_stream</methodname><indexterm><primary>log::sinks::text_ostream_backend::add_stream</primary></indexterm><indexterm><primary>add_stream, log::sinks::text_ostream_backend</primary></indexterm> is provided by the back-end <classname>boost::log::sinks::text_ostream_backend</classname> to add streams. You can add more than one stream to <classname>boost::log::sinks::text_ostream_backend</classname>. Other back-ends provide different member functions for configuration. Consult the documentation for details.</para>
  <para>To get access to a back-end, all front-ends provide the member function <methodname>locked_backend</methodname>. This member function is called <methodname>locked_backend</methodname> because it returns a pointer that provides synchronized access to the back-end as long as the pointer exists. You can access a back-end through pointers returned by <methodname>locked_backend</methodname> from multiple threads without having to synchronize access yourself.</para>
  <para>You can instantiate a logger like <classname>boost::log::sources::logger</classname> with the default constructor. The logger automatically calls <methodname>boost::log::core::get</methodname> to forward log entries to the core.</para>
  <para>You can access loggers without macros. Loggers are objects with member functions you can call. However, macros like <code>BOOST_LOG</code> make it easier to write log entries. Without macros it wouldn’t be possible to write a log entry in one line of code.</para>
  <para><xref linkend="ex.log_01" xrefstyle="enp"/> calls <methodname>boost::log::sinks::asynchronous_sink::flush</methodname><indexterm><primary>log::sinks::asynchronous_sink::flush</primary></indexterm><indexterm><primary>flush, log::sinks::asynchronous_sink</primary></indexterm> at the end of <function>main</function>. This call is required because the front-end is asynchronous and uses a thread to forward log entries. The call makes sure that all buffered log entries are passed to the back-end and are written. Without the call to <methodname>flush</methodname>, the example could terminate without displaying <computeroutput>note</computeroutput>.</para>
  <example xml:id="ex.log_02">
    <title><classname>boost::sources::severity_logger</classname> with a filter</title>
    <programlisting><xi:include href="../src/log_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.log_02" xrefstyle="enp"/> is based on <xref linkend="ex.log_01" xrefstyle="enp"/>, but it replaces <classname>boost::sources::logger</classname> with the logger <classname>boost::sources::severity_logger</classname><indexterm><primary>sources::severity_logger</primary></indexterm><indexterm><primary>severity_logger, sources</primary></indexterm>. This logger adds an attribute for a log level to every log entry. You can use the macro <code>BOOST_LOG_SEV</code><indexterm><primary>BOOST_LOG_SEV, Boost.Log</primary></indexterm> to set the log level.</para>
  <para>The type of the log level depends on a template parameter passed to <classname>boost::sources::severity_logger</classname>. <xref linkend="ex.log_02" xrefstyle="enp"/> uses <type>int</type>. That’s why numbers like 0 and 1 are passed to <code>BOOST_LOG_SEV</code>. If <code>BOOST_LOG</code> is used, the log level is set to 0.</para>
  <para><xref linkend="ex.log_02" xrefstyle="enp"/> also calls <methodname>set_filter</methodname><indexterm><primary>log::sinks::asynchronous_sink::set_filter</primary></indexterm><indexterm><primary>set_filter, log::sinks::asynchronous_sink</primary></indexterm> to register a filter at the front-end. The filter function is called for every log entry. If the function returns <literal>true</literal>, the log entry is forwarded to the back-end. <xref linkend="ex.log_02" xrefstyle="enp"/> defines the function <function>only_warnings</function> with a return value of type <type>bool</type>.</para>
  <para><function>only_warnings</function> expects a parameter of type <classname>boost::log::attribute_value_set</classname><indexterm><primary>log::attribute_value_set</primary></indexterm><indexterm><primary>attribute_value_set, log</primary></indexterm>. This type represents log entries while they are being passed around in the logging framework. <classname>boost::log::record</classname><indexterm><primary>log::record</primary></indexterm><indexterm><primary>record, log</primary></indexterm> is another type for log entries that is like a wrapper for <classname>boost::log::attribute_value_set</classname>. This type provides the member function <methodname>attribute_values</methodname><indexterm><primary>log::attribute_value_set::attribute_values</primary></indexterm><indexterm><primary>attribute_values, log::attribute_value_set</primary></indexterm>, which retrieves a reference to the <classname>boost::log::attribute_value_set</classname>. Filter functions receive a <classname>boost::log::attribute_value_set</classname> directly and no <classname>boost::log::record</classname>. <classname>boost::log::attribute_value_set</classname> stores key/value pairs. Think of it as a <classname>std::unordered_map</classname>.</para>
  <para>Log entries consist of attributes. Attributes have a name and a value. You can create attributes yourself. They can also be created automatically &#x2013; for example by loggers. In fact, that’s why Boost.Log provides multiple loggers. <classname>boost::log::sources::severity_logger</classname> adds an attribute called Severity to every log entry. This attribute stores the log level. That way a filter can check whether the log level of a log entry is greater than 0.</para>
  <para><classname>boost::log::attribute_value_set</classname> provides several member functions to access attributes. The member functions are similar to the ones provided by <classname>std::unordered_map</classname>. For example, <classname>boost::log::attribute_value_set</classname> overloads the operator <methodname role="operator">operator[]</methodname>. This operator returns the value of an attribute whose name is passed as a parameter. If the attribute doesn’t exist, it is created.</para>
  <para>The type of attribute names is <classname>boost::log::attribute_name</classname><indexterm><primary>log::attribute_name</primary></indexterm><indexterm><primary>attribute_name, log</primary></indexterm>. This class provides a constructor that accepts a string, so you can pass a string directly to <methodname role="operator">operator[]</methodname>, as in <xref linkend="ex.log_02" xrefstyle="enp"/>.</para>
  <para>The type of attribute values is <classname>boost::log::attribute_value</classname><indexterm><primary>log::attribute_value</primary></indexterm><indexterm><primary>attribute_value, log</primary></indexterm>. This class provides member functions to receive the value in the attribute’s original type. Because the log level is an <type>int</type> value, <type>int</type> is passed as a template parameter to <methodname>extract</methodname><indexterm><primary>log::attribute_name::extract</primary></indexterm><indexterm><primary>extract, log::attribute_name</primary></indexterm>.</para>
  <para><classname>boost::log::attribute_value</classname> also defines the member functions <methodname>extract_or_default</methodname><indexterm><primary>log::attribute_name::extract_or_default</primary></indexterm><indexterm><primary>extract_or_default, log::attribute_name</primary></indexterm> and <methodname>extract_or_throw</methodname><indexterm><primary>log::attribute_name::extract_or_throw</primary></indexterm><indexterm><primary>extract_or_throw, log::attribute_name</primary></indexterm>. <methodname>extract</methodname> returns a value created with the default constructor if a type conversion fails &#x2013; for example 0 in case of an <type>int</type>. <methodname>extract_or_default</methodname> returns a default value which is passed as another parameter to that member function. <methodname>extract_or_throw</methodname> throws an exception of type <exceptionname>boost::log::runtime_error</exceptionname> in the event of an error.</para>
  <para>For type-safe conversions, Boost.Log provides the visitor function <function>boost::log::visit</function><indexterm><primary>log::visit</primary></indexterm><indexterm><primary>visit, log</primary></indexterm>, which you can use instead of <methodname>extract</methodname>.</para>
  <para><xref linkend="ex.log_02" xrefstyle="enp"/> displays <computeroutput>warning</computeroutput>. This log entry has a log level greater than 0 and thus isn’t filtered.</para>
  <example xml:id="ex.log_03">
    <title>Changing the format of a log entry with <methodname>set_formatter</methodname></title>
    <programlisting><xi:include href="../src/log_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.log_03" xrefstyle="enp"/> is based on <xref linkend="ex.log_02" xrefstyle="enp"/>. This time the log level is displayed.</para>
  <para>Front-ends provide the member function <methodname>set_formatter</methodname>, which can be passed a format function. If a log entry isn’t filtered by a front-end, it is forwarded to the format function. This function formats the log entry as a string that is then passed from the front-end to the back-end. If you don’t call <methodname>set_formatter</methodname>, by default the back-end only receives what is on the right side of a macro like <code>BOOST_LOG</code>.</para>
  <para><xref linkend="ex.log_03" xrefstyle="enp"/> passes the function <function>severity_and_message</function> to <methodname>set_formatter</methodname><indexterm><primary>log::sinks::asynchronous_sink::set_formatter</primary></indexterm><indexterm><primary>set_formatter, log::sinks::asynchronous_sink</primary></indexterm>. <function>severity_and_message</function> expects parameters of type <classname>boost::log::record_view</classname><indexterm><primary>log::record_view</primary></indexterm><indexterm><primary>record_view, log</primary></indexterm> and <classname>boost::log::formatting_ostream</classname><indexterm><primary>log::formatting_ostream</primary></indexterm><indexterm><primary>formatting_ostream, log</primary></indexterm>. <classname>boost::log::record_view</classname> is a view on a log entry. It’s similar to <classname>boost::log::record</classname>. However, <classname>boost::log::record_view</classname> is an immutable log entry.</para>
  <para><classname>boost::log::record_view</classname> provides the member function <methodname>attribute_values</methodname><indexterm><primary>log::record_view::attribute_values</primary></indexterm><indexterm><primary>attribute_values, log::record_view</primary></indexterm>, which returns a constant reference to <classname>boost::log::attribute_value_set</classname>. <classname>boost::log::formatting_ostream</classname> is the stream used to create the string that is passed to the back-end.</para>
  <para><function>severity_and_message</function> accesses the attributes Severity and Message. <methodname>extract</methodname> is called to get the attribute values, which are then written to the stream. Severity returns the log level as an <type>int</type> value. Message provides access to what is on the right side of a macro like <code>BOOST_LOG</code>. Consult the documentation for a complete list of available attribute names.</para>
  <para><xref linkend="ex.log_03" xrefstyle="enp"/> uses no filter. The example writes two log entries: <computeroutput>0: note</computeroutput> and <computeroutput>1: warning</computeroutput>.</para>
  <example xml:id="ex.log_04">
    <title>Filtering log entries and formatting them with lambda functions</title>
    <programlisting><xi:include href="../src/log_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.log_04" xrefstyle="enp"/> uses both a filter and a format function. This time the functions are implemented as lambda functions &#x2013; not as C++11 lambda functions but as Boost.Phoenix lambda functions.</para>
  <para>Boost.Log provides helpers for lambda functions in the namespace <package>boost::log::expressions</package>. For example, <varname>boost::log::expressions::stream</varname><indexterm><primary>log::expressions::stream</primary></indexterm><indexterm><primary>stream, log::expressions</primary></indexterm> represents the stream. <varname>boost::log::expressions::smessage</varname><indexterm><primary>log::expressions::smessage</primary></indexterm><indexterm><primary>smessage, log::expressions</primary></indexterm> provides access to everything on the right side of a macro like <code>BOOST_LOG</code>. You can use <function>boost::log::expressions::attr</function><indexterm><primary>log::expressions::attr</primary></indexterm><indexterm><primary>attr, log::expressions</primary></indexterm> to access any attribute. Instead of <varname>smessage</varname> <xref linkend="ex.log_04" xrefstyle="enp"/> could use <code>attr&lt;std::string&gt;("Message")</code>.</para>
  <para><xref linkend="ex.log_04" xrefstyle="enp"/> displays <computeroutput>1: warning</computeroutput> and <computeroutput>2: error</computeroutput>.</para>
  <example xml:id="ex.log_05">
    <title>Defining keywords for attributes</title>
    <programlisting><xi:include href="../src/log_05/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Boost.Log supports user-defined keywords. You can use the macro <code>BOOST_LOG_ATTRIBUTE_KEYWORD</code><indexterm><primary>BOOST_LOG_ATTRIBUTE_KEYWORD, Boost.Log</primary></indexterm> to define keywords to access attributes without having to repeatedly pass attribute names as strings to <function>boost::log::expressions::attr</function>.</para>
  <para><xref linkend="ex.log_05" xrefstyle="enp"/> uses the macro <code>BOOST_LOG_ATTRIBUTE_KEYWORD</code> to define a keyword <varname>severity</varname>. The macro expects three parameters: the name of the keyword, the attribute name as a string, and the type of the attribute. The new keyword can be used in filter and format lambda functions. This means you are not restricted to using keywords, such as <varname>boost::log::expressions::smessage</varname>, that are provided by Boost.Log &#x2013; you can also define new keywords.</para>
  <para>In all of the examples so far, the attributes used are the ones defined in Boost.Log. <xref linkend="ex.log_06" xrefstyle="enp"/> shows how to create user-defined attributes.</para>
  <example xml:id="ex.log_06">
    <title>Defining attributes</title>
    <programlisting><xi:include href="../src/log_06/main.cpp" parse="text"/></programlisting>
  </example>
  <para>You create a global attribute by calling <methodname>add_global_attribute</methodname><indexterm><primary>log::core::add_global_attribute</primary></indexterm><indexterm><primary>add_global_attribute, log::core</primary></indexterm> on the core. The attribute is global because it is added to every log entry automatically.</para>
  <para><methodname>add_global_attribute</methodname> expects two parameters: the name and the type of the new attribute. The name is passed as a string. For the type you use a class from the namespace <package>boost::log::attributes</package>, which provides classes to define different attributes. <xref linkend="ex.log_06" xrefstyle="enp"/> uses <classname>boost::log::attributes::counter</classname><indexterm><primary>log::attributes::counter</primary></indexterm><indexterm><primary>counter, log::attributes</primary></indexterm> to define the attribute LineCounter, which adds a line number to every log entry. This attribute will number log entries starting at 1.</para>
  <para><methodname>add_global_attribute</methodname> is not a function template. <classname>boost::log::attributes::counter</classname> isn’t passed as a template parameter. The attribute type must be instantiated and passed as an object.</para>
  <para><xref linkend="ex.log_06" xrefstyle="enp"/> uses a second attribute called Timestamp. This is a scoped attribute that is created with <code>BOOST_LOG_SCOPED_LOGGER_ATTR</code><indexterm><primary>BOOST_LOG_SCOPED_LOGGER_ATTR, Boost.Log</primary></indexterm>. This macro adds an attribute to a logger. The first parameter is the logger, the second is the attribute name, and the third is the attribute object. The type of the attribute object is <classname>boost::log::attribute::local_clock</classname><indexterm><primary>log::attribute::local_clock</primary></indexterm><indexterm><primary>local_clock, log::attribute</primary></indexterm>. The attribute is set to the current time for each log entry.</para>
  <para>The attribute Timestamp is added to the log entry <quote>error</quote> only. Timestamp exists only in the scope where <code>BOOST_LOG_SCOPED_LOGGER_ATTR</code> is used. When the scope ends, the attribute is removed. <code>BOOST_LOG_SCOPED_LOGGER_ATTR</code> is similar to a call to <methodname>add_attribute</methodname> and <methodname>remove_attribute</methodname>.</para>
  <para>As in <xref linkend="ex.log_05" xrefstyle="ewp"/>, <xref linkend="ex.log_06" xrefstyle="enp" /> uses the macro <code>BOOST_LOG_ATTRIBUTE_KEYWORD</code> to define keywords for the new attributes. The format function accesses the keywords to write the line number and current time. The value of <varname>timestamp</varname> will be an empty string for those log entries where the attribute Timestamp is undefined.</para>
  <example xml:id="ex.log_07">
    <title>Helper functions for filters and formats</title>
    <programlisting><xi:include href="../src/log_07/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Boost.Log provides numerous helper functions for filters and formats. <xref linkend="ex.log_07" xrefstyle="enp"/> calls the helper <function>boost::log::expressions::is_in_range</function><indexterm><primary>log::expressions::is_in_range</primary></indexterm><indexterm><primary>is_in_range, log::expressions</primary></indexterm> to filter log entries whose log level is outside a range. <function>boost::log::expressions::is_in_range</function> expects the attribute as its first parameter and lower and upper bounds as its second and third parameters. As with iterators, the upper bound is exclusive and doesn’t belong to the range.</para>
  <para><function>boost::log::expressions::format_date_time</function><indexterm><primary>log::expressions::format_date_time</primary></indexterm><indexterm><primary>format_date_time, log::expressions</primary></indexterm> is called in the format function. It is used to format a timepoint. <xref linkend="ex.log_07" xrefstyle="enp"/> uses <function>boost::log::expressions::format_date_time</function> to write the time without a date. You can also use manipulators from the standard library in format functions. <xref linkend="ex.log_07" xrefstyle="enp"/> uses <function>std::setw</function> to set the width for the counter.</para>
  <example xml:id="ex.log_08">
    <title>Several loggers, front-ends, and back-ends</title>
    <programlisting><xi:include href="../src/log_08/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.log_08" xrefstyle="enp"/> uses several loggers, front-ends, and back-ends. In addition to using the classes <classname>boost::log::sinks::asynchronous_sink</classname>, <classname>boost::log::sinks::text_ostream_backend</classname> and <classname>boost::log::sources::severity_logger</classname>, the example also uses the front-end <classname>boost::log::sinks::synchronous_sink</classname><indexterm><primary>log::sinks::synchronous_sink</primary></indexterm><indexterm><primary>synchronous_sink, log::sinks</primary></indexterm>, the back-end <classname>boost::log::sinks::text_multifile_backend</classname><indexterm><primary>log::sinks::text_multifile_backend</primary></indexterm><indexterm><primary>text_multifile_backend, log::sinks</primary></indexterm>, and the logger <classname>boost::log::sources::channel_logger</classname><indexterm><primary>log::sources::channel_logger</primary></indexterm><indexterm><primary>channel_logger, log::sources</primary></indexterm>.</para>
  <para>The front-end <classname>boost::log::sinks::synchronous_sink</classname> provides synchronous access to a back-end, which lets you use a back-end in a multithreaded application even if the back-end isn’t thread safe.</para>
  <para>The difference between the two front-ends <classname>boost::log::sinks::asynchronous_sink</classname> and <classname>boost::log::sinks::synchronous_sink</classname> is that the latter isn’t based on a thread. Log entries are passed to the back-end in the same thread.</para>
  <para><xref linkend="ex.log_08" xrefstyle="enp"/> uses the front-end <classname>boost::log::sinks::synchronous_sink</classname> with the back-end <classname>boost::log::sinks::text_multifile_backend</classname>. This back-end writes log entries to one or more files. File names are created according to a rule passed by <methodname>set_file_name_composer</methodname><indexterm><primary>log::sinks::text_multifile_backend::set_file_name_composer</primary></indexterm><indexterm><primary>set_file_name_composer, log::sinks::text_multifile_backend</primary></indexterm> to the back-end. If you use the free-standing function <function>boost::log::sinks::file::as_file_name_composer</function><indexterm><primary>log::sinks::file::as_file_name_composer</primary></indexterm><indexterm><primary>as_file_name_composer, log::sinks::file</primary></indexterm>, as in the example, the rule can be created as a lambda function with the same building blocks used for format functions. However, the attributes aren’t used to create the string that is written to a back-end. Instead, the string will be the name of the file that log entries will be written to.</para>
  <para><xref linkend="ex.log_08" xrefstyle="enp"/> uses the keywords <varname>channel</varname> and <varname>severity</varname>, which are defined with the macro <code>BOOST_LOG_ATTRIBUTE_KEYWORD</code>. They refer to the attributes Channel and Severity. The member function <methodname>or_default</methodname><indexterm><primary>log::expressions::attribute_keyword::or_default</primary></indexterm><indexterm><primary>or_default, log::expressions::attribute_keyword</primary></indexterm> is called on the keywords to pass a default value if an attribute isn’t set. If a log entry is written and Channel and Severity are not set, the entry is written to the file <filename>None-0.log</filename>. If a log entry is written with the log level 1, it is stored in the file <filename>None-1.log</filename>. If the log level is 1 and the channel is called Main, the log entry is saved in the file <filename>Main-1.log</filename>.</para>
  <para>The attribute Channel is defined by the logger <classname>boost::log::sources::channel_logger</classname>. The constructor expects a channel name. The name can’t be passed directly as a string. Instead, it must be passed as a named parameter. That’s why the example uses <code>keywords::channel = "Main"</code> even though <classname>boost::log::sources::channel_logger</classname> doesn’t accept any other parameters.</para>
  <para>Please note that the named parameter <classname>boost::log::keywords::channel</classname><indexterm><primary>log::keywords::channel</primary></indexterm><indexterm><primary>channel, log::keywords</primary></indexterm> has nothing to do with the keywords you create with the macro <code>BOOST_LOG_ATTRIBUTE_KEYWORD</code>.</para>
  <para><classname>boost::log::sources::channel_logger</classname> identifies log entries from different components of a program. Components can use their own objects of type <classname>boost::log::sources::channel_logger</classname>, giving them unique names. If components only access their own loggers, it’s clear which component a particular log entry came from.</para>
  <example xml:id="ex.log_09">
    <title>Handling exceptions centrally</title>
    <programlisting><xi:include href="../src/log_09/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Boost.Log provides the option to handle exceptions in the logging framework centrally. This means you don’t need to wrap every <code>BOOST_LOG</code> in a <code>try</code> block to handle exceptions in <code>catch</code>.</para>
  <para><xref linkend="ex.log_09" xrefstyle="enp" /> calls the member function <methodname>set_exception_handler</methodname><indexterm><primary>log::core::set_exception_handler</primary></indexterm><indexterm><primary>set_exception_handler, log::core</primary></indexterm>. The core provides this member function to register a handler. All exceptions in the logging framework will be passed to that handler. The handler is implemented as a function object. It has to overload <methodname role="operator">operator()</methodname> for every exception type expected. An instance of that function object is passed to <methodname>set_exception_handler</methodname> through the function template <function>boost::log::make_exception_handler</function><indexterm><primary>log::make_exception_handler</primary></indexterm><indexterm><primary>make_exception_handler, log</primary></indexterm>. All exception types you want to handle must be passed as template parameters to <function>boost::log::make_exception_handler</function>.</para>
  <para>The function <function>boost::log::make_exception_suppressor</function><indexterm><primary>log::make_exception_suppressor</primary></indexterm><indexterm><primary>make_exception_suppressor, log</primary></indexterm> let’s you discard all exceptions in the logging framework. You call this function instead of <function>boost::log::make_exception_handler</function>.</para>
  <example xml:id="ex.log_10">
    <title>A macro to define a global logger</title>
    <programlisting><xi:include href="../src/log_10/main.cpp" parse="text"/></programlisting>
  </example>
  <para>All of the examples in this chapter use local loggers. If you want to define a global logger, use the macro <code>BOOST_LOG_INLINE_GLOBAL_LOGGER_DEFAULT</code><indexterm><primary>BOOST_LOG_INLINE_GLOBAL_LOGGER_DEFAULT, Boost.Log</primary></indexterm> as in <xref linkend="ex.log_10" xrefstyle="enp"/>. You pass the name of the logger as the first parameter and the type as the second. You don’t access the logger through its name. Instead, you call <methodname>get</methodname>, which returns a pointer to a singleton.</para>
  <para>Boost.Log provides additional macros such as <code>BOOST_LOG_INLINE_GLOBAL_LOGGER_CTOR_ARGS</code><indexterm><primary>BOOST_LOG_INLINE_GLOBAL_LOGGER_CTOR_ARGS, Boost.Log</primary></indexterm>. They let you initialize global loggers. <code>BOOST_LOG_INLINE_GLOBAL_LOGGER_CTOR_ARGS</code> lets you pass parameters to the constructor of a global logger. All of these macros guarantee that global loggers will be correctly initialized.</para>
  <para>Boost.Log provides many more functions that are worth a look. For example, you can configure the logging framework through a container with key/value pairs as strings. Then, you don’t need to instantiate classes and call member functions. For example, a key Destination can be set to Console, which will automatically make the logging framework use the back-end <classname>boost::log::sinks::text_ostream_backend</classname>. The back-end can be configured through additional key/value pairs. Because the container can also be serialized in an INI-file, it is possible to store the configuration in a text file and initialize the logging framework with that file.</para>
</chapter>
