<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.lockfree">
  <title>Boost.Lockfree</title><indexterm><primary>Boost.Lockfree</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/lockfree">Boost.Lockfree</link> provides thread-safe and lock-free containers. Containers from this library can be accessed from multiple threads without having to synchronize access.</para>
  <para>In version 1.56.0, Boost.Lockfree provides only two containers: a queue of type <classname>boost::lockfree::queue</classname> and a stack of type <classname>boost::lockfree::stack</classname>. For the queue, a second implementation is available: <classname>boost::lockfree::spsc_queue</classname>. This class is optimized for use cases where exactly one thread writes to the queue and exactly one thread reads from the queue. The abbreviation <acronym>spsc</acronym> in the class name stands for single producer/single consumer.</para>
  <example xml:id="ex.lockfree_01">
    <title>Using <classname>boost::lockfree::spsc_queue</classname></title>
    <programlisting><xi:include href="../src/lockfree_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.lockfree_01" xrefstyle="enp"/> uses the container <classname>boost::lockfree::spsc_queue</classname><indexterm><primary>lockfree::spsc_queue</primary></indexterm><indexterm><primary>spsc_queue, lockfree</primary></indexterm>. The first thread, which executes the function <function>produce</function>, adds the numbers 1 to 100 to the container. The second thread, which executes <function>consume</function>, reads the numbers from the container and adds them up in <varname>sum</varname>. Because the container <classname>boost::lockfree::spsc_queue</classname> explicitly supports concurrent access from two threads, it isn’t necessary to synchronize the threads.</para>
  <para>Please note that the function <function>consume</function> is called a second time after the threads terminate. This is required to calculate the total of all 100 numbers, which is 5050. Because <function>consume</function> accesses the queue in a loop, it is possible that it will read the numbers faster than they are inserted by <function>produce</function>. If the queue is empty, <methodname>pop</methodname><indexterm><primary>lockfree::spsc_queue::pop</primary></indexterm><indexterm><primary>pop, lockfree::spsc_queue</primary></indexterm> returns <literal>false</literal>. Thus, the thread executing <function>consume</function> could terminate because <function>produce</function> in the other thread couldn’t fill the queue fast enough. If the thread executing <function>produce</function> is terminated, then it’s clear that all of the numbers were added to the queue. The second call to <function>consume</function> makes sure that numbers that may not have been read yet are added to <varname>sum</varname>.</para>
  <para>The size of the queue is passed to the constructor. Because <classname>boost::lockfree::spsc_queue</classname> is implemented with a circular buffer, the queue in <xref linkend="ex.lockfree_01" xrefstyle="enp"/> has a capacity of 100 elements. If a value can’t be added because the queue is full, <methodname>push</methodname><indexterm><primary>lockfree::spsc_queue::push</primary></indexterm><indexterm><primary>push, lockfree::spsc_queue</primary></indexterm> returns <literal>false</literal>. The example doesn’t check the return value of <methodname>push</methodname> because exactly 100 numbers are added to the queue. Thus, 100 elements is sufficient.</para>
  <example xml:id="ex.lockfree_02">
    <title><classname>boost::lockfree::spsc_queue</classname> with <classname>boost::lockfree::capacity</classname></title>
    <programlisting><xi:include href="../src/lockfree_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.lockfree_02" xrefstyle="enp"/> works like the previous example, but this time the size of the circular buffer is set at compile time. This is done with the template <classname>boost::lockfree::capacity</classname><indexterm><primary>lockfree::capacity</primary></indexterm><indexterm><primary>capacity, lockfree</primary></indexterm>, which expects the capacity as a template parameter. <varname>q</varname> is instantiated with the default constructor &#x2013; the capacity cannot be set at run time.</para>
  <para>The function <function>consume</function> has been changed to use <methodname>consume_one</methodname><indexterm><primary>lockfree::spsc_queue::consume_one</primary></indexterm><indexterm><primary>consume_one, lockfree::spsc_queue</primary></indexterm>, rather than <methodname>pop</methodname>, to read the number. A lambda function is passed as a parameter to <methodname>consume_one</methodname>. <methodname>consume_one</methodname> reads a number just like <methodname>pop</methodname>, but the number isn’t returned through a reference to the caller. It is passed as the sole parameter to the lambda function.</para>
  <para>When the threads terminate, <function>main</function> calls the member function <methodname>consume_all</methodname><indexterm><primary>lockfree::spsc_queue::consume_all</primary></indexterm><indexterm><primary>consume_all, lockfree::spsc_queue</primary></indexterm>, instead of <function>consume</function>. <methodname>consume_all</methodname> works like <methodname>consume_one</methodname> but makes sure that the queue is empty after the call. <methodname>consume_all</methodname> calls the lambda function as long as there are elements in the queue.</para>
  <para>Once again, <xref linkend="ex.lockfree_02" xrefstyle="enp"/> writes <computeroutput>5050</computeroutput> to standard output.</para>
  <example xml:id="ex.lockfree_03">
    <title><classname>boost::lockfree::queue</classname> with variable container size</title>
    <programlisting><xi:include href="../src/lockfree_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.lockfree_03" xrefstyle="enp"/> executes <function>consume</function> in two threads. Because more than one thread reads from the queue, the class <classname>boost::lockfree::spsc_queue</classname> must not be used. This example uses <classname>boost::lockfree::queue</classname><indexterm><primary>lockfree::queue</primary></indexterm><indexterm><primary>queue, lockfree</primary></indexterm> instead.</para>
  <para>Thanks to <classname>std::atomic</classname>, access to the variable <varname>sum</varname> is also now thread safe.</para>
  <para>The size of the queue is set to 100 &#x2013; this is the parameter passed to the constructor. However, this is only the initial size. By default, <classname>boost::lockfree::queue</classname> is not implemented with a circular buffer. If more items are added to the queue than the capacity is set to, it is automatically increased. <classname>boost::lockfree::queue</classname> dynamically allocates additional memory if the initial size isn’t sufficient.</para>
  <para>That means that <classname>boost::lockfree::queue</classname> isn’t necessarily lock free. The allocator used by <classname>boost::lockfree::queue</classname> by default is <classname>boost::lockfree::allocator</classname><indexterm><primary>lockfree::allocator</primary></indexterm><indexterm><primary>allocator, lockfree</primary></indexterm>, which is based on <classname>std::allocator</classname>. Thus, this allocator determines whether <classname>boost::lockfree::queue</classname> is lock free without constraints.</para>
  <example xml:id="ex.lockfree_04">
    <title><classname>boost::lockfree::queue</classname> with constant container size</title>
    <programlisting><xi:include href="../src/lockfree_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.lockfree_04" xrefstyle="enp"/> uses a constant size of 10,000 elements. In this example, the queue doesn’t allocate additional memory when it is full. 10,000 is a fixed upper limit.</para>
  <para>The queue’s capacity is constant because <classname>boost::lockfree::fixed_sized</classname><indexterm><primary>lockfree::fixed_sized</primary></indexterm><indexterm><primary>fixed_sized, lockfree</primary></indexterm> is passed as a template parameter. The capacity is passed as a parameter to the constructor and can be updated at any time using <methodname>reserve</methodname><indexterm><primary>lockfree::queue::reserve</primary></indexterm><indexterm><primary>reserve, lockfree::queue</primary></indexterm>. If the capacity must be set at compile time, <classname>boost::lockfree::capacity</classname> can be passed as a template parameter to <classname>boost::lockfree::queue</classname>. <classname>boost::lockfree::capacity</classname> includes <classname>boost::lockfree::fixed_sized</classname>.</para>
  <para>In <xref linkend="ex.lockfree_04" xrefstyle="enp"/>, the queue has a capacity of 10,000 elements. Because <function>consume</function> inserts 10,000 numbers into the queue, the upper limit isn’t exceeded. If it were exceeded, <methodname>push</methodname><indexterm><primary>lockfree::queue::push</primary></indexterm><indexterm><primary>push, lockfree::queue</primary></indexterm> would return <literal>false</literal>.</para>
  <para><classname>boost::lockfree::queue</classname> is similar to <classname>boost::lockfree::spsc_queue</classname> and also provides member functions like <methodname>consume_one</methodname><indexterm><primary>lockfree::queue::consume_one</primary></indexterm><indexterm><primary>consume_one, lockfree::queue</primary></indexterm> and <methodname>consume_all</methodname><indexterm><primary>lockfree::queue::consume_all</primary></indexterm><indexterm><primary>consume_all, lockfree::queue</primary></indexterm>.</para>
  <para>The third class, <classname>boost::lockfree::stack</classname><indexterm><primary>lockfree::stack</primary></indexterm><indexterm><primary>stack, lockfree</primary></indexterm>, is similar to the other ones. As with <classname>boost::lockfree::queue</classname>, <classname>boost::lockfree::fixed_size</classname> and <classname>boost::lockfree::capacity</classname> can be passed as template parameters. The member functions are similar, too.</para>
  <simplesect role="exercises" xml:id="boost.lockfree-exercises">
    <title>Exercise</title>
    <para>Remove the class <classname>boost::lockfree::spsc_queue</classname> from <xref linkend="ex.lockfree_01" xrefstyle="ewp"/> and implement the program with <classname>std::queue</classname>.</para>
  </simplesect>
</chapter>
