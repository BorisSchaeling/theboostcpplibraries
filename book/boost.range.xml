<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.range">
  <title>Boost.Range</title><indexterm><primary>Boost.Range</primary></indexterm>
  <para><link xlink:href="http://www.boost.org/libs/range">Boost.Range</link> is a library that, on the first sight, provides algorithms similar to those provided by the standard library. For example, you will find the function <function>boost::copy</function>, which does the same thing as <function>std::copy</function>. However, <function>std::copy</function> expects two parameters while <function>boost::copy</function> expects a range.</para>
  <sect1 xml:id="boost.range-algorithms">
    <title>Algorithms</title>
    <para>You can think of a <emphasis role="concept">range</emphasis><indexterm><primary>range, Boost.Range</primary></indexterm> as two iterators that refer to the beginning and end of a group of elements that you can iterate over. Because all containers support iterators, every container can be thought of as a range. Since all algorithms from Boost.Range expect a range as a first parameter, a container like <classname>std::vector</classname> can be passed directly. You don’t have to call <methodname>begin</methodname> and <methodname>end</methodname> and then pass two iterators separately. This protects you from mistakes such as passing the begin and end iterator in the wrong order or passing iterators that belong to two different containers.</para>
    <example xml:id="ex.range_01">
      <title>Counting with <function>boost::count</function></title>
      <programlisting><xi:include href="../src/range_01/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.range_01" xrefstyle="enp" /> uses the algorithm <function>boost::count</function><indexterm><primary>count, Boost.Range</primary></indexterm>, which is defined in <filename class="headerfile">boost/range/algorithm.hpp</filename>. This header file provides access to all of the algorithms for which counterparts exist in the standard library header file <filename class="headerfile">algorithm</filename>.</para>
    <para>All algorithms from Boost.Range require the first parameter to be a range. An object of type <classname>std::array</classname> can be passed to <function>boost::count</function> directly since containers are ranges. Because <function>boost::count</function> is equivalent to <function>std::count</function>, you must pass in the value that the elements in the range will be compared with.</para>
    <para>In <xref linkend="ex.range_01" xrefstyle="enp" />, <varname>a</varname> contains three zeros, so <computeroutput>3</computeroutput> is written to standard output.</para>
    <para><xref linkend="ex.range_02" xrefstyle="enp" /> introduces more algorithms which, like <function>boost::count</function>, are similar to algorithms from the standard library.</para>
    <example xml:id="ex.range_02">
      <title>Range algorithms related to algorithms from the standard library</title>
      <programlisting><xi:include href="../src/range_02/main.cpp" parse="text"/></programlisting>
    </example>
    <para><function>boost::random_shuffle</function><indexterm><primary>random_shuffle, Boost.Range</primary></indexterm> works like <function>std::random_shuffle</function>, changing the order of elements in a range randomly. <xref linkend="ex.range_02" xrefstyle="enp" /> uses <function>boost::random_shuffle</function> with a default random number generator. However, you can pass a random number generator as a second parameter. That can be a random number generator either from the C++11 header file <filename class="headerfile">random</filename> or from Boost.Random.</para>
    <para><function>boost::copy</function><indexterm><primary>copy, Boost.Range</primary></indexterm> works like <function>std::copy</function>. <function>boost::max_element</function><indexterm><primary>max_element, Boost.Range</primary></indexterm> and <function>boost::accumulate</function><indexterm><primary>accumulate, Boost.Range</primary></indexterm> work like the identically named algorithms from the standard library. Like <function>std::max_element</function>, <function>boost::max_element</function> returns an iterator to the element with the greatest number.</para>
    <para>The header file <filename class="headerfile">boost/range/numeric.hpp</filename> must be included for <function>boost::accumulate</function>. Just as <function>std::accumulate</function> is defined in <filename class="headerfile">numeric</filename>, <function>boost::accumulate</function> is defined in <filename class="headerfile">boost/range/numeric.hpp</filename> and not in <filename class="headerfile">boost/range/algorithm.hpp</filename>.</para>
    <para>Boost.Range also provides a few algorithms without counterparts in the standard library.</para>
    <example xml:id="ex.range_03">
      <title>Range algorithms without counterparts in the standard library</title>
      <programlisting><xi:include href="../src/range_03/main.cpp" parse="text"/></programlisting>
    </example>
    <para>The algorithms used in <xref linkend="ex.range_03" xrefstyle="enp" /> require the header file <filename class="headerfile">boost/range/algorithm_ext.hpp</filename>. This header file provides access to algorithms that have no counterpart in the standard library.</para>
    <para><function>boost::is_sorted</function><indexterm><primary>is_sorted, Boost.Range</primary></indexterm> tests whether elements in a range are sorted. In <xref linkend="ex.range_03" xrefstyle="enp" />, <function>boost::is_sorted</function> returns <literal>true</literal> because <varname>a</varname> is sorted. A predicate can be passed as the second parameter to <function>boost::is_sorted</function> to check, for example, whether a range is sorted in descending order.</para>
    <para><function>boost::push_back</function><indexterm><primary>push_back, Boost.Range</primary></indexterm> expects as its first parameter a container and as its second parameter a range. The container must define the member function <methodname>push_back</methodname>. All elements from the range are added to the container using this member function, in the order specified by the range. Because <varname>d</varname> starts out empty, it will contain the same numbers as <varname>a</varname>, in the same order, after the call to <function>boost::push_back</function>.</para>
    <para><function>boost::remove_erase</function><indexterm><primary>remove_erase, Boost.Range</primary></indexterm> removes the number 2 from <varname>d</varname>. This algorithm combines a call to the function <function>std::remove</function> and a call to the member function <methodname>erase</methodname> of the respective container. Thanks to <function>boost::remove_erase</function>, you don’t need to find the iterator to the element you need to remove and then pass it to <methodname>erase</methodname> in a second step.</para>
    <para><function>boost::copy_n</function><indexterm><primary>copy_n, Boost.Range</primary></indexterm> is similar to <function>boost::copy</function>, but copies only as many elements as the number passed as its second parameter. <xref linkend="ex.range_03" xrefstyle="enp" /> only writes the first three numbers from <varname>d</varname> to standard output. Because 2 was removed from <varname>d</varname> in the previous line, <computeroutput>0,1,3,</computeroutput> is displayed.</para>
  </sect1>
  <sect1 xml:id="boost.range-adaptors">
    <title>Adaptors</title>
    <para>The standard library provides several algorithms you can pass a predicate to. For example, the predicate passed to <function>std::count_if</function> determines which elements are counted. Boost.Range provides the similar function <function>boost::count_if</function>. However, this algorithm is only provided for completeness because Boost.Range provides adaptors that make algorithms with predicates superfluous.</para>
    <para>You can think of <emphasis role="concept">adaptors</emphasis><indexterm><primary>adaptor, Boost.Range</primary></indexterm> as filters. They return a new range based on another range. Data isn’t necessarily copied. Since a range is just a pair of iterators, an adaptor returns a new pair. The pair can still be used to iterate over the original range but may, for example, skip certain elements. If <function>boost::count</function> is used with such an adaptor, <function>boost::count_if</function> is no longer required. Algorithms don’t have to be defined multiple times just so they can be called with and without predicates.</para>
    <para>The difference between algorithms and adaptors is that algorithms iterate over a range and process data, while adaptors return a new range &#x2013; new iterators &#x2013; that determines what elements the iteration returns. However, no iteration is executed. An algorithm must be called first.</para>
    <example xml:id="ex.range_04">
      <title>Filtering a range with <function>boost::adaptors::filter</function></title>
      <programlisting><xi:include href="../src/range_04/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.range_04" xrefstyle="enp" /> uses an adaptor that can filter ranges. As you can see, the adaptor is just a function. <function>boost::adaptors::filter</function><indexterm><primary>adaptors::filter</primary></indexterm><indexterm><primary>filter, adaptors</primary></indexterm> expects as its first parameter a range to filter and as its second parameter a predicate. The predicate in <xref linkend="ex.range_04" xrefstyle="enp" /> removes all numbers from the range that aren’t greater than 2.</para>
    <para><function>boost::adaptors::filter</function> does not change the range <varname>a</varname>, it returns a new range. Since a range isn’t much different from a pair of iterators, the new range also refers to <varname>a</varname>. However, the iterators for the new range skip all numbers that are less than or equal to 2.</para>
    <para><xref linkend="ex.range_04" xrefstyle="enp"/> writes <computeroutput>5,3,4</computeroutput> to standard output.</para>
    <example xml:id="ex.range_05">
      <title>Using <function>keys</function>, <function>values</function> and <function>indirect</function></title>
      <programlisting><xi:include href="../src/range_05/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.range_05" xrefstyle="enp" /> uses two adaptors, <function>boost::adaptors::keys</function><indexterm><primary>adaptors::keys</primary></indexterm><indexterm><primary>keys, adaptors</primary></indexterm> and <function>boost::adaptors::values</function><indexterm><primary>adaptors::values</primary></indexterm><indexterm><primary>values, adaptors</primary></indexterm>, to access keys and values in a container of type <classname>std::map</classname>. It also shows how adaptors can be nested. Because <varname>m</varname> stores pointers to the values to be printed, rather than the values themselves, the range returned by <function>boost::adaptors::values</function> is passed to <function>boost::adaptors::indirect</function>. This adaptor can always be used when a range consists of pointers, but an iteration should return the values the pointers refer to. That’s why <xref linkend="ex.range_05" xrefstyle="enp" /> writes <computeroutput>a,b,c,0,1,2,</computeroutput> to standard output.</para>
    <example xml:id="ex.range_06">
      <title><function>boost::adaptors::tokenize</function> &#x2013; an adaptor for strings</title>
      <programlisting><xi:include href="../src/range_06/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.range_06" xrefstyle="enp" /> introduces an adaptor for strings. You can use <function>boost::adaptors::tokenize</function><indexterm><primary>adaptors::tokenize</primary></indexterm><indexterm><primary>tokenize, adaptors</primary></indexterm> to get a range from a string with the help of a regular expression. You pass a string and a regular expression of the type <classname>boost::regex</classname> to <function>boost::adaptors::tokenize</function>. In addition, you need to pass a number that refers to a group in the regular expression and a flag. If no group is used, you can pass 0. The flag <varname>boost::regex_constants::match_default</varname> selects the default settings for regular expressions. You can also pass other flags. For example, you can use <varname>boost::regex_constants::match_perl</varname> if you want the regular expression to be applied according to the rules for the programming language Perl.</para>
    <simplesect role="exercises" xml:id="boost.range-adaptors-exercises">
      <title>Exercise</title>
      <para>Create a program which writes all odd numbers between 0 and 100 in ascending order to standard output. Use only algorithms from Boost.Range &#x2013; no manual loops.</para>
    </simplesect>
  </sect1>
  <sect1 xml:id="boost.range-helper-classes-and-functions">
    <title>Helper Classes and Functions</title>
    <para>The algorithms and adaptors provided by Boost.Range are based on templates. You don’t have to transform a container to a range to pass it to an algorithm or adaptor. However, Boost.Range defines a few range classes, with <classname>boost::iterator_range</classname> being the most important. <classname>boost::iterator_range</classname> is required because adaptors and a few algorithms return ranges that must have a type. In addition, helper functions exist that create ranges whose iterators contain all the data required for an iteration. The iterators from these ranges don’t refer to a container or to another data structure. A class like <classname>boost::iterator_range</classname> is used here, too.</para>
    <example xml:id="ex.range_07">
      <title>Creating a range for integers with <function>boost::irange</function></title>
      <programlisting><xi:include href="../src/range_07/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.range_07" xrefstyle="enp" /> uses the function <function>boost::irange</function><indexterm><primary>irange, Boost.Range</primary></indexterm>. This function creates a range for integers without having to use a container or another data structure. You only pass a lower and upper bound to <function>boost::irange</function> with the upper bound being exclusive.</para>
    <para><function>boost::irange</function> returns a range of type <classname>boost::integer_range</classname><indexterm><primary>integer_range, Boost.Range</primary></indexterm>. This class is derived from <classname>boost::iterator_range</classname><indexterm><primary>iterator_range, Boost.Range</primary></indexterm>. <classname>boost::iterator_range</classname> is a template that expects an iterator type as its sole template parameter. The iterator used by <function>boost::irange</function> is tightly coupled to that function and is an implementation detail. Thus, the iterator type isn’t known and can’t be passed as a template parameter to <classname>boost::iterator_range</classname>. However, <classname>boost::integer_range</classname> only expects an integer type, which makes it easier to use than if you had to pass an iterator type.</para>
    <para><xref linkend="ex.range_07" xrefstyle="enp"/> writes <computeroutput>0,1,2</computeroutput> to standard output.</para>
    <example xml:id="ex.range_08">
      <title>Creating a range for an input stream with <function>boost::istream_range</function></title>
      <programlisting><xi:include href="../src/range_08/main.cpp" parse="text"/></programlisting>
    </example>
    <para><xref linkend="ex.range_08" xrefstyle="enp" /> introduces the function <function>boost::istream_range</function><indexterm><primary>istream_range, Boost.Range</primary></indexterm>, which creates a range for an input stream. The function returns the range as a <classname>boost::iterator_range</classname>. This means that an iterator type has to be passed as a template parameter.</para>
    <para>When you start <xref linkend="ex.range_08" xrefstyle="enp" />, type a number, and press <keycap>Enter</keycap>, the number is printed in the next line. If you type another number and press <keycap>Enter</keycap>, that number is printed. The range returned by <function>boost::istream_range</function> makes it possible for <function>boost::copy</function> to iterate over all entered numbers and write them to <varname>std::cout</varname>.</para>
    <para>You can terminate the program any time by typing <keycombo action="simul"><keycap>Ctrl</keycap><keycap>C</keycap></keycombo>.</para>
    <para>Besides <classname>boost::iterator_range</classname>, Boost.Range provides the class <classname>boost::sub_range</classname><indexterm><primary>sub_range, Boost.Range</primary></indexterm>, which is derived from <classname>boost::iterator_range</classname>. <classname>boost::sub_range</classname> is a template like <classname>boost::iterator_range</classname>. However, <classname>boost::sub_range</classname> expects the type of the range as a template parameter, not an iterator type. This can simplify usage.</para>
    <example xml:id="ex.range_09">
      <title>Creating ranges more easily with <function>boost::sub_range</function></title>
      <programlisting><xi:include href="../src/range_09/main.cpp" parse="text"/></programlisting>
    </example>
    <para>A few algorithms from Boost.Range return a range &#x2013; for example, <function>boost::random_shuffle</function><indexterm><primary>random_shuffle, Boost.Range</primary></indexterm>. This algorithm directly modifies the range passed to it by reference and returns the modified range. In <xref linkend="ex.range_09" xrefstyle="enp" />, <function>boost::random_shuffle</function> is called twice, so array <varname>a</varname> is randomly shuffled twice.</para>
    <para>For the first return value, the example uses <classname>boost::iterator_range</classname>; for the second return value, it uses <classname>boost::sub_range</classname>. The usage of both classes only differs in the template parameter. Not only can <classname>boost::sub_range</classname> be instantiated more easily, but it also provides the type definition <type>const_iterator</type>.</para>
  </sect1>
</chapter>
