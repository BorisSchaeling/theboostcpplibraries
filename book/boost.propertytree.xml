<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="5.0" xml:lang="en" xml:id="boost.propertytree">
  <title>Boost.PropertyTree</title><indexterm><primary>Boost.PropertyTree</primary></indexterm>
  <para>With the class <classname>boost::property_tree::ptree</classname><indexterm><primary>property_tree::ptree</primary></indexterm><indexterm><primary>ptree, property_tree</primary></indexterm>, <link xlink:href="http://www.boost.org/libs/property_tree">Boost.PropertyTree</link> provides a tree structure to store key/value pairs. Tree structure means that a trunk exists with numerous branches that have numerous twigs. A file system is a good example of a tree structure. File systems have a root directory with subdirectories that themselves can have subdirectories and so on.</para>
  <para>To use <classname>boost::property_tree::ptree</classname>, include the header file <filename class="headerfile">boost/property_tree/ptree.hpp</filename>. This is a master header file, so no other header files need to be included for Boost.PropertyTree.</para>
  <example xml:id="ex.propertytree_01">
    <title>Accessing data in <classname>boost::property_tree::ptree</classname></title>
    <programlisting><xi:include href="../src/propertytree_01/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.propertytree_01" xrefstyle="enp" /> uses <classname>boost::property_tree::ptree</classname> to store a path to a directory. This is done with a call to <methodname>put</methodname><indexterm><primary>property_tree::ptree::put</primary></indexterm><indexterm><primary>put, property_tree::ptree</primary></indexterm>. This member function expects two parameters because <classname>boost::property_tree::ptree</classname> is a tree structure that saves key/value pairs. The tree doesn’t just consist of branches and twigs, a value must be assigned to each branch and twig. In <xref linkend="ex.propertytree_01" xrefstyle="enp"/> the value is <quote>20 files</quote>.</para>
  <para>The first parameter passed to <methodname>put</methodname> is more interesting. It is a path to a directory. However, it doesn’t use the backlash, which is the common path separator on Windows. It uses the dot.</para>
  <para>You need to use the dot because it’s the separator Boost.PropertyTree expects for keys. The parameter <quote>C:.Windows.System</quote> tells <varname>pt</varname> to create a branch called C: with a branch called Windows that has another branch called System. The dot creates the nested structure of branches. If <quote>C:\Windows\System</quote> had been passed as the parameter, <varname>pt</varname> would only have one branch called C:\Windows\System.</para>
  <para>After the call to <methodname>put</methodname>, <varname>pt</varname> is accessed to read the stored value <quote>20 files</quote> and write it to standard output. This is done by jumping from branch to branch &#x2013; or directory to directory.</para>
  <para>To access a subbranch, you call <methodname>get_child</methodname><indexterm><primary>property_tree::ptree::get_child</primary></indexterm><indexterm><primary>get_child, property_tree::ptree</primary></indexterm>, which returns a reference to an object of the same type <methodname>get_child</methodname> was called on. In <xref linkend="ex.propertytree_01" xrefstyle="enp" />, this is a reference to <classname>boost::property_tree::ptree</classname>. Because every branch can have subbranches, and because there is no structural difference between higher and lower branches, the same type is used.</para>
  <para>The third call to <methodname>get_child</methodname> retrieves the <classname>boost::property_tree::ptree</classname>, which represents the directory System. <methodname>get_value</methodname><indexterm><primary>property_tree::ptree::get_value</primary></indexterm><indexterm><primary>get_value, property_tree::ptree</primary></indexterm> is called to read the value that was stored at the beginning of the example with <methodname>put</methodname>.</para>
  <para>Please note that <methodname>get_value</methodname> is a function template. You pass the type of the return value as a template parameter. That way <methodname>get_value</methodname> can do an automatic type conversion.</para>
  <example xml:id="ex.propertytree_02">
    <title>Accessing data in <classname>basic_ptree&lt;std::string, int&gt;</classname></title>
    <programlisting><xi:include href="../src/propertytree_02/main.cpp" parse="text"/></programlisting>
  </example>
  <para>There are two changes in <xref linkend="ex.propertytree_02" xrefstyle="enp" /> compared with <xref linkend="ex.propertytree_01" xrefstyle="enp" />. These changes are to save paths to directories and the number of files in directories more easily. First, paths use a backslash as the separator when passed to <methodname>put</methodname>. Secondly, the number of files is stored as an <type>int</type>.</para>
  <para>By default, Boost.PropertyTree uses a dot as the separator for keys. If you need to use another character, such as the backslash, as the separator, you don’t pass the key as a string to <methodname>put</methodname>. Instead you wrap it in an object of type <classname>boost::property_tree::ptree::path_type</classname><indexterm><primary>property_tree::ptree::path_type</primary></indexterm><indexterm><primary>path_type, property_tree::ptree</primary></indexterm>. The constructor of this class, which depends on <classname>boost::property_tree::ptree</classname>, takes the key as its first parameter and the separator character as its second parameter. That way, you can use a path such as C:\Windows\System, as shown in <xref linkend="ex.propertytree_02" xrefstyle="enp" />, without having to replace backslashes with dots.</para>
  <para><classname>boost::property_tree::ptree</classname> is based on the class template <classname>boost::property_tree::basic_ptree</classname><indexterm><primary>property_tree::basic_ptree</primary></indexterm><indexterm><primary>basic_ptree, property_tree</primary></indexterm>. Because keys and values are often strings, <classname>boost::property_tree::ptree</classname> is predefined. However, you can use <classname>boost::property_tree::basic_ptree</classname> with different types for keys and values. The tree in <xref linkend="ex.propertytree_02" xrefstyle="enp" /> uses an <type>int</type> to store the number of files in a directory rather than a string.</para>
  <para><classname>boost::property_tree::ptree</classname> provides the member functions <methodname>begin</methodname><indexterm><primary>property_tree::ptree::begin</primary></indexterm><indexterm><primary>begin, property_tree::ptree</primary></indexterm> and <methodname>end</methodname><indexterm><primary>property_tree::ptree::end</primary></indexterm><indexterm><primary>end, property_tree::ptree</primary></indexterm>. However, <classname>boost::property_tree::ptree</classname> only lets you iterate over the branches in one level. <xref linkend="ex.propertytree_02" xrefstyle="enp" /> iterates over the subdirectories of C:\Windows. You can’t get an iterator to iterate over all branches in all levels.</para>
  <para>The <code>for</code> loop in <xref linkend="ex.propertytree_02" xrefstyle="enp" /> reads the number of files in all subdirectories of C:\Windows to calculate a total. As a result, the example displays <computeroutput>70</computeroutput>. The example doesn’t access objects of type <classname>ptree</classname> directly. Instead it iterates over elements of type <classname>std::pair&lt;std::string, ptree&gt;</classname>. <varname>first</varname> contains the key of the current branch. That is System and Cursors in <xref linkend="ex.propertytree_02" xrefstyle="enp" />. <varname>second</varname> provides access to an object of type <classname>ptree</classname>, which represents the possible subdirectories. In the example, only the values assigned to System and Cursors are read. As in <xref linkend="ex.propertytree_01" xrefstyle="enp" />, the member function <methodname>get_value</methodname> is called.</para>
  <para><classname>boost::property_tree::ptree</classname> only stores the value of the current branch, not its key. You can get the value with <methodname>get_value</methodname>, but there is no member function to get the key. The key is stored in <classname>boost::property_tree::ptree</classname> one level up. This also explains why the <code>for</code> loop iterates over elements of type <classname>std::pair&lt;std::string, ptree&gt;</classname>.</para>
  <example xml:id="ex.propertytree_03">
    <title>Accessing data with a translator</title>
    <programlisting><xi:include href="../src/propertytree_03/main.cpp" parse="text"/></programlisting>
  </example>
  <para><xref linkend="ex.propertytree_03" xrefstyle="enp"/> uses with <classname>boost::property_tree::iptree</classname><indexterm><primary>property_tree::iptree</primary></indexterm><indexterm><primary>iptree, property_tree</primary></indexterm> another predefined tree from Boost.PropertyTree. In general, this type behaves like <classname>boost::property_tree::ptree</classname>. The only difference is that <classname>boost::property_tree::iptree</classname> doesn’t distinguish between lower and upper case. For example, a value stored with the key C:\Windows\System can be read with c:\windows\system.</para>
  <para>Unlike <xref linkend="ex.propertytree_01" xrefstyle="ewp" />, <methodname>get_child</methodname> isn’t called multiple times to access subbranches. Just as <methodname>put</methodname> can be used to store a value in a subbranch directly, a value from a subbranch can be read with <methodname>get</methodname><indexterm><primary>property_tree::ptree::get</primary></indexterm><indexterm><primary>get, property_tree::ptree</primary></indexterm>. The key is defined the same way &#x2013; for example using <classname>boost::property_tree::iptree::path_type</classname>.</para>
  <para>Like <methodname>get_value</methodname>, <methodname>get</methodname> is a function template. You have to pass the type of the return value as a template parameter. Boost.PropertyTree does an automatic type conversion.</para>
  <para>To convert types, Boost.PropertyTree uses <emphasis role="concept">translators</emphasis><indexterm><primary>translators, Boost.PropertyTree</primary></indexterm>. The library provides a few translators out of the box that are based on streams and can convert types automatically.</para>
  <para><xref linkend="ex.propertytree_03" xrefstyle="enp" /> defines the translator <classname>string_to_int_translator</classname>, which converts a value of type <classname>std::string</classname> to <type>int</type>. The translator is passed as an additional parameter to <methodname>get</methodname>. Because the translator is just used to read, it only defines one member function, <methodname>get_value</methodname>. If you want to use the translator for writing, too, then you would need to define a member function <methodname>put_value</methodname> and then pass the translator as an additional parameter to <methodname>put</methodname>.</para>
  <para><methodname>get_value</methodname> returns a value of the type that is used in <varname>pt</varname>. However, because a type conversion doesn’t always succeed, <classname>boost::optional</classname> is used. If a value is stored in <xref linkend="ex.propertytree_03" xrefstyle="enp" /> that can’t be converted to an <type>int</type> with <function>std::strtol</function>, an empty object of type <classname>boost::optional</classname> will be returned.</para>
  <para>Please note that a translator must also define the two types <type>internal_type</type> and <type>external_type</type>. If you need to convert types when storing data, define <methodname>put_value</methodname> similar to <methodname>get_value</methodname>.</para>
  <para>If you modify <xref linkend="ex.propertytree_03" xrefstyle="enp" /> to store the value <quote>20</quote> instead of value <quote>20 files</quote>, <methodname>get_value</methodname> can be called without passing a translator. The translators provided by Boost.PropertyTree can convert from <classname>std::string</classname> to <type>int</type>. However, the type conversion only succeeds when the entire string can be converted. The string must not contain any letters. Because <function>std::strtol</function> can do a type conversion as long as the string starts with digits, the more liberal translator <classname>string_to_int_translator</classname> is used in <xref linkend="ex.propertytree_03" xrefstyle="enp"/>.</para>
  <example xml:id="ex.propertytree_04">
    <title>Various member functions of <classname>boost::property_tree::ptree</classname></title>
    <programlisting><xi:include href="../src/propertytree_04/main.cpp" parse="text"/></programlisting>
  </example>
  <para>You can call the member function <methodname>get_optional</methodname><indexterm><primary>property_tree::ptree::get_optional</primary></indexterm><indexterm><primary>get_optional, property_tree::ptree</primary></indexterm> if you want to read the value of a key, but you aren’t sure if the key exists. <methodname>get_optional</methodname> returns the value in an object of type <classname>boost::optional</classname>. The object is empty if the key wasn’t found. Otherwise, <methodname>get_optional</methodname> works the same as <methodname>get</methodname>.</para>
  <para>It might seem like <methodname>put_child</methodname><indexterm><primary>property_tree::ptree::put_child</primary></indexterm><indexterm><primary>put_child, property_tree::ptree</primary></indexterm> and <methodname>add_child</methodname><indexterm><primary>property_tree::ptree::add_child</primary></indexterm><indexterm><primary>add_child, property_tree::ptree</primary></indexterm> are the same as <methodname>put</methodname>. The difference is that <methodname>put</methodname> creates only a key/value pair while <methodname>put_child</methodname> and <methodname>add_child</methodname> insert an entire subtree. Note that an object of type <classname>boost::property_tree::ptree</classname> is passed as the second parameter to <methodname>put_child</methodname> and <methodname>add_child</methodname>.</para>
  <para>The difference between <methodname>put_child</methodname> and <methodname>add_child</methodname> is that <methodname>put_child</methodname> accesses a key if that key already exists, while <methodname>add_child</methodname> always inserts a new key into the tree. That’s why the tree in <xref linkend="ex.propertytree_04" xrefstyle="enp" /> has two keys called <quote>D:.Program Files</quote>. Depending on the use case, this can be confusing. If a tree represents a file system, there shouldn’t be two identical paths. You have to avoid inserting identical keys if you don’t want duplicates in a tree.</para>
  <para><xref linkend="ex.propertytree_04" xrefstyle="enp" /> displays the value of the keys below <quote>D:</quote> in the <code>for</code> loop. The example writes <computeroutput>50 files</computeroutput> and <computeroutput>60 files</computeroutput> to standard output, which proves there are two identical keys called <quote>D:.Program Files</quote>.</para>
  <para>The last member function introduced in <xref linkend="ex.propertytree_04" xrefstyle="enp" /> is <methodname>get_child_optional</methodname><indexterm><primary>property_tree::ptree::get_child_optional</primary></indexterm><indexterm><primary>get_child_optional, property_tree::ptree</primary></indexterm>. This function is used like <methodname>get_child</methodname>. <methodname>get_child_optional</methodname> returns an object of type <classname>boost::optional</classname>. You call <classname>boost::optional</classname> if you aren’t sure whether a key exists.</para>
  <example xml:id="ex.propertytree_05">
    <title>Serializing a <classname>boost::property_tree::ptree</classname> in the <acronym>JSON</acronym> format</title>
    <programlisting><xi:include href="../src/propertytree_05/main.cpp" parse="text"/></programlisting>
  </example>
  <para>Boost.PropertyTree does more than just provide structures to manage data in memory. As can be seen in <xref linkend="ex.propertytree_05" xrefstyle="enp" />, the library also provides functions to save a <classname>boost::property_tree::ptree</classname> in a file and load it from a file.</para>
  <para>The header file <filename class="headerfile">boost/property_tree/json_parser.hpp</filename> provides access to the functions <function>boost::property_tree::json_parser::write_json</function><indexterm><primary>property_tree::json_parser::write_json</primary></indexterm><indexterm><primary>write_json, property_tree::json_parser</primary></indexterm> and <function>boost::property_tree::json_parser::read_json</function><indexterm><primary>property_tree::json_parser::read_json</primary></indexterm><indexterm><primary>read_json, property_tree::json_parser</primary></indexterm>. These functions make it possible to save and load a <classname>boost::property_tree::ptree</classname> serialized in the <acronym>JSON</acronym> format. That way you can support configuration files in the <acronym>JSON</acronym> format.</para>
  <para>If you want to call functions that store a <classname>boost::property_tree::ptree</classname> in a file or load it from a file, you must include header files such as <filename class="headerfile">boost/property_tree/json_parser.hpp</filename>. It isn’t sufficient to only include <filename class="headerfile">boost/property_tree/ptree.hpp</filename>.</para>
  <para>In addition to the functions <function>boost::property_tree::json_parser::write_json</function> and <function>boost::property_tree::json_parser::read_json</function>, Boost.PropertyTree provides functions for additional data formats. You use <function>boost::property_tree::ini_parser::write_ini</function><indexterm><primary>property_tree::ini_parser::write_ini</primary></indexterm><indexterm><primary>write_ini, property_tree::ini_parser</primary></indexterm> and <function>boost::property_tree::ini_parser::read_ini</function><indexterm><primary>property_tree::ini_parser::read_ini</primary></indexterm><indexterm><primary>read_ini, property_tree::ini_parser</primary></indexterm> from <filename class="headerfile">boost/property_tree/ini_parser.hpp</filename> to support INI-files. With <function>boost::property_tree::xml_parser::write_xml</function><indexterm><primary>property_tree::xml_parser::write_xml</primary></indexterm><indexterm><primary>write_xml, property_tree::xml_parser</primary></indexterm> and <function>boost::property_tree::xml_parser::read_xml</function><indexterm><primary>property_tree::xml_parser::read_xml</primary></indexterm><indexterm><primary>read_xml, property_tree::xml_parser::read_xml</primary></indexterm> from <filename class="headerfile">boost/property_tree/xml_parser.hpp</filename>, data can be loaded and stored in <acronym>XML</acronym> format. With <function>boost::property_tree::info_parser::write_info</function><indexterm><primary>property_tree::info_parser::write_info</primary></indexterm><indexterm><primary>write_info, property_tree::info_parser</primary></indexterm> and <function>boost::property_tree::info_parser::read_info</function><indexterm><primary>property_tree::info_parser::read_info</primary></indexterm><indexterm><primary>read_info, property_tree::info_parser</primary></indexterm> from <filename class="headerfile">boost/property_tree/info_parser.hpp</filename>, you can access another format that was developed and optimized to serialize trees from Boost.PropertyTree.</para>
  <para>None of the supported formats guarantees that a <classname>boost::property_tree::ptree</classname> will look the same after it has been saved and reloaded. For example, the <acronym>JSON</acronym> format can lose type information because <classname>boost::property_tree::ptree</classname> can’t distinguish between <literal>true</literal> and <quote>true</quote>. The type is always the same. Even if the various functions make it easy to save and load a <classname>boost::property_tree::ptree</classname>, don’t forget that Boost.PropertyTree doesn’t support the formats completely. The main focus of the library is on the structure <classname>boost::property_tree::ptree</classname> and not on supporting various data formats.</para>
  <simplesect role="exercises" xml:id="boost.propertytree-exercises">
    <title>Exercise</title>
    <para>Create a program that loads this <acronym>JSON</acronym>-file and writes the names of all animals to standard output. If <quote>all</quote> is set to <literal>true</literal> the program should not only write the names but all properties of all animals to standard output:</para>
    <informalexample>
      <programlisting language="json"><xi:include href="../exercises/propertytree_01/config.json" parse="text"/></programlisting>
    </informalexample>
  </simplesect>
</chapter>
